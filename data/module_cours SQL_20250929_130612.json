{
  "filename": "module_cours SQL.pdf",
  "extraction_date": "2025-09-29T13:06:12.716188",
  "statistics": {
    "word_count": 5136,
    "character_count": 35451,
    "line_count": 1260
  },
  "top_keywords": [
    [
      "transaction",
      76
    ],
    [
      "trigger",
      63
    ],
    [
      "table",
      31
    ],
    [
      "lire",
      31
    ],
    [
      "exécution",
      30
    ],
    [
      "données",
      27
    ],
    [
      "peut",
      25
    ],
    [
      "idarticle",
      25
    ],
    [
      "ecrire",
      25
    ],
    [
      "pour",
      24
    ]
  ],
  "extracted_data": {
    "emails": [],
    "urls": [],
    "dates": [
      "08/12/2009"
    ]
  },
  "content_preview": "08/12/2009\n1\nContrainte d’intégrité\nContrainte d'intégrité statique\n–\nrespectée pourchacun des états de la BD\n–\nmécanisme déclaratif\nPRIMARY KEY,\nUNIQUE,\nNOT NULL, DOMAIN, FOREIGN KEY,\nCHECK,\nASSERTION\n–\nprocédural\nTRIGGER (SQL:1999)‏\nContrainte d'intégrité dynamique\n–\ncontrainte sur changements d'états (un changement -> un changement -> etc..)‏\n–\nréférence aux états successifs de la base\n–\nTRIGGER\nContrainte colonne\n Types SQL\n INTEGER\n CHAR\n ...\n NOT NULL\n CHECK\n CREATE DOMAIN (SQL, pas...",
  "full_content": "08/12/2009\n1\nContrainte d’intégrité\nContrainte d'intégrité statique\n–\nrespectée pourchacun des états de la BD\n–\nmécanisme déclaratif\nPRIMARY KEY,\nUNIQUE,\nNOT NULL, DOMAIN, FOREIGN KEY,\nCHECK,\nASSERTION\n–\nprocédural\nTRIGGER (SQL:1999)‏\nContrainte d'intégrité dynamique\n–\ncontrainte sur changements d'états (un changement -> un changement -> etc..)‏\n–\nréférence aux états successifs de la base\n–\nTRIGGER\nContrainte colonne\n Types SQL\n INTEGER\n CHAR\n ...\n NOT NULL\n CHECK\n CREATE DOMAIN (SQL, pas disponible pour Oracle)‏\nNOT NULL\nsalaireEmp INTEGER NOT NULL\n Par défaut : NULL autorisé\nCHECK\n Définition de domaine pour un attribut\n Par intension (conditions nécessaire et suffisante pour appartenir à \nl’ensemble)\nsalaireEmp INTEGER NOT NULL\nCHECK(salaireEmp > 1200 AND salaireEmp < 10000)\n Par extension (liste exhaustive des valeurs de l’ensemble)\ncolor CHAR(1)\nCHECK (color IN ('R', 'G', ‘B’))\n5\nClé primaire (PRIMARY KEY)‏\nColonnes clés primaires: NOT NULL et Indexées\nIdClient INTEGER PRIMARY KEY\nPRIMARY KEY (IdClient, idProduit, dateCommande)\n6\n\n08/12/2009\n2\nUNIQUE\n- occurrence unique dans la table de chaque valeur de la colonne \n(ou des colonnes)\n- colonne(s) indexée(s)\n- clé candidate\nidEmp\nINTEGER,\njob\nVARCHAR(64),\nidDept\nINTEGER,\nPRIMARY KEY \n(idEmp),\nUNIQUE \n(job,idDept),\n7\nContrainte d'intégrité référentielle (FOREIGN KEY ... REFERENCES ... )‏\nCREATE TABLE emp (\n...\nidDept INTEGER,\nFOREIGN KEY (idDept) REFERENCES \nDept(idDept),\n...\n idDept de emp fait référenceà la clé primaire idDept de \nla table dept\n La table dept doit d’abord être créée\n8\nGestion de la contrainte d'intégrité référentielle\n Tentative de mise à jour de la clé primaire\n Options\n NO ACTION: pas de mot clé Oracle, comportement par défaut\n ON DELETE CASCADE: Oracle, tout n-uplet référençant la ligne suppriméeest\naussi supprimée\n ON DELETE SET NULL: Oracle, valeur de l'attribut mis à null\n SET DEFAULT: pas disponiblesur Oracle\n ON UPDATE \n9\nCREATE TABLE Commande \n(noCommande  \nINTEGER   \nNOT NULL, \n dateCommande \nDATE  \n \nNOT NULL, \n noClient  \nINTEGER \n \nNOT NULL, \n PRIMARY KEY (noCommande), \n FOREIGN KEY (noClient) REFERENCES Client(noClient) \n) \nDELETE FROM Client WHERE noClient = 10\nCHECK intra-ligne\nCHECK (age > 18 \nand  sal > 0)\n?\nCHECK ( (sal + NVL(prime,0)) > 1500) \n?\n Plusieurs colonnes de la même ligne peuvent être utilisées\nsimultanémentdans une contrainte CHECK \n10\nCheck inter-ligne d'une même table\n Compare le n-uplet inséré à plusieurs lignes de la table\nCHECK (sal > SELECT MIN(prime) FROM emp)) ?\n Vérifié uniquement pour la ligne touchée\n La contraintepeut être violée (mise à jour)  \n Pas supportépar Oracle\n11\nCHECK inter-tables\n Concerneplusieurs tables\nCHECK (age >= \n(\nSELECT ageMinimumEmployé FROM conventionEntreprise\nWHERE année=2008 ) )\n?\n Vérifié uniquement pour la ligne touchée\n La contrainte peut être violée\n Pas supportépar Oracle\n12\n\n08/12/2009\n3\nNom de contrainte (clause CONSTRAINT)‏\nCONSTRAINT contNoClient\nCHECK(IdClient > 0 AND IdClient < 100000)\n Facilite l'identification de la contraintenon respectéeà \nl ’exécution\n Facilite la supression, désactivation/activation de \ncontrainte\n13\nModification contrainte\n14\nALTER TABLE table\n<constraint_clause>,...\n[{ENABLE|DISABLE} ALL TRIGGERS];\n<constraint_clause>:\nADD CONSTRAINT  ...\nDROP [CONSTRAINT <constraint_name> [CASCADE]] | [PRIMARY KEY|UNIQUE]\n[ENABLE|DISABLE] [CONSTRAINT <constraint_name>\nMODIFY [CONSTRAINT <constraint_name>] |  [PRIMARY KEY|UNIQUE] \n<constrnt_state>\nRENAME CONSTRAINT <constraint_name> TO <constraint_name>\n<constrnt_state>:   \n[[NOT] DEFERRABLE] [INITIALLY {IMMEDIATE|DEFERRED}]\nENABLE|DISABLE]  [VALIDATE|NOVALIDATE]\n\nVALIDATE | NOVALIDATE:  vérifié ou non sur la table existante\n\nENABLE NOVALIDATE: vérifié sur les nouvelles insertions mais pas sur les donnéesexistantes\n\nDEFERRABLE: contrainte déférée, la contrainte n'est vérifiée qu'au moment de la validation des \nmodification (INITIALLY indique le comportement par défaut déférée ou pas)‏\nDéclencheur (TRIGGER)‏\n- Procédure exécutée au niveau serveur\n- BD active\n- Permet le maintien de contraintes d’intégrité\n- statiques: alternatives aux mécanismesdéclaratifs type CHECK par exemple, préférer les \nmécanismesdéclaratif s'il est possible de les utiliser\n- dynamiques\n- Permet le maintien d'éléments dérivés\n- colonne dérivée (contenue d'une colonne calculée à partir d'une ou plusieurs autres colonnes)‏\n- tables dérivée (copie de tables pour base répartie, table d'archivage, ...)‏\n- sécurité (ex: refus de modification), audit des opérations, \n- Généralement, un déclencheur est associé à un événement sur une table\n- Sous ORACLE, un déclencheur (trigger) peutêtre associé à pratiquement tout événementde la \nbase (DDL, startup, logon, ...)‏\nTRIGGER: Procédure déclenchée‏\n- Utilisé pour spécifier des contraintes plus complexes que les contraintes statiques telles que:\n– Contraintes portant sur plusieurs tables\n– Contraintes nécessitant l’utilisation de sous-requêtes\n- Permet d'utiliser des traitement procéduraux: \nécriture de  procédures PL/SQL, JAVA, ...\n- Déclenché par un événement particulier:\n– Le trigger est généralement associé à une table précise,\n– Il est alors déclenché en réaction à un événement sur cette table: INSERT, UPDATE ou DELETE\n– Il est possible de spécifier des conditions supplémentaires: clause WHEN\n– Possible déclenchement en cascade: un trigger peut déclencher d’autres triggers en cascade\nAttention au cycle de déclencheur: \ntrigger A déclenche trigger B qui déclencher trigger A qui ....\n- Résultat du trigger\nLe trigger se termine correctement s’il ne soulève pas d’exception et si les modifications effectuées\nne violent pas d’autres contraintes (autre triggers ou contraintes statiques)‏\nSi le trigger est interrompu, toutes les opérations effectuées sont annulées (rollback implicite)‏\nTRIGGER: Rappel syntaxe\nCREATE [OR REPLACE] TRIGGER nom-trigger    \nBEFORE | AFTER\nINSERT OR UPDATE [OF column] OR DELETE ON nom-table\n[FOR EACH ROW [WHEN (condition)]]\nbloc d’instructions pl/sql\n– INSERT OR UPDATE [OF column] OR DELETE ON nom-table\nprécise le ou les événements provoquant l'exécution du trigger \n– BEFORE | AFTER \n  spécifie l'exécution de la procédure comme étant avant (BEFORE) ou après (AFTER) l’exécution de l’événement\ndéclencheur\n BEFORE : vérification de l'insertion\n AFTER : copie ou archivage des opérations\n– [FOR EACH ROW ]  \n indique que le trigger est exécuté pour  chaque ligne modifiée/insérée/supprimée\nsi cette clause est omis, le trigger est exécuté une seul fois pour chaque commande UPDATE, INSERT, DELETE, \nquelque soit le nombre de lignes modifiées, insérées ou supprimées.\n– [WHEN (condition)]\n conditions optionnelles permettant de restreindre le déclenchement du trigger \n!!! Ne peut contenir de requêtes\n(exemple: WHEN emp.sal > 5000)\n\n08/12/2009\n4\nTRIGGER: référence aux attributs des n-uplets modifiés\nDans le code PL/SQL associé à un trigger de niveau ligne, on peut accéder aux valeurs des \nattributs de la ligne modifiée, avant et après la modification:\n=> utilisation des variables : \n–\n:old (sauf dans WHEN => old)\n–\n:new (sauf dans WHEN => new)\n–\nPossibilité d'utiliser d'autres noms\n(clause REFERENCING \nNEW AS nouveauNom\nOLD AS nouveauNom )\n•‏Pour un trigger sur INSERT\nles valeurs des attributs du n-uplet inséré sont dans\n:new.<nom attribut>\n•‏Pour un trigger sur UPDATE\nles valeurs de l'ancien n-uplet sont dans :old.<nom attribut>\nles valeurs du n-uplet après modification sont dans :new.<nom attribut>\n•‏Pour un trigger sur DELETE\nles valeurs des attributs du n-uplet supprimé sont dans\n:old.<nom attribut>  \nTRIGGER: ligne/instruction\nDéclencheur de ligne (spécifié par FOR EACH ROW),\nExécutés une fois pour chaque ligne affectée par l’événement spécifié.\nPermet d’accéder aux valeurs des lignes affectées avant (:old) et après (:new) l’opération.\nSi le triggers est précisé comme étant déclenché avant l’événement (before) les valeurs du n-\nuplet peuvent être modifiées avant leur insertion dans la base de données (par ex  \n:new.attribut := :new.attribut + 1).\nIl est possible de spécifier des conditions de déclenchement (WHEN) pouvant porter sur\nles valeurs des anciens/nouveaux n-uplet\nDéclencheur d’instruction (par défaut)‏\nExécuté une seule fois avant ou après la totalité de l’événement, indépendamment du \nnombre de lignes affectés\nRestrictions: ne permet pas d’accéder ou de modifier les valeurs des lignes affectées avant ou\naprès l’événement (:old.nomcol et :new.nomcol) ni de spécifier des conditions WHEN\nTRIGGER: remarques\n•   Mutation : tant que les modifications (INSERT, UPDATE ou DELETE) d’une\ntable ne sont pas terminées (modifications totalement terminées et validées), \ncelle-ci est dite en cours de mutation.\nUn trigger ne peut lire ou modifier une table en cours de mutation.\n=> un trigger AFTER un bloc d’instruction (pas de clause FOR EACH ROW), \npeut modifier la table associée à l’événement déclencheur.\n•   Validation : un déclencheur ne peut ni exécuter d’instruction COMMIT ou\nROLLBACK, ni appeler de fonction, procédure ou sous-programme de package \ninvoquant ces instructions.\nTRIGGER: bloc d'instruction\nBloc PL/SQL standard\nDECLARE\nDéclaration de variables et constantes avec leur type\nBEGIN\nBloc d’instructions PL/SQL\nEND\nLe bloc d’instructions PL/SQL peut contenir:\n– des blocs spécifiant des actions différentes fonction de l’événement déclencheur\n- IF INSERTING THEN bloc d’instructions pl/sql END IF\n- IF UPDATING THEN bloc d’instructions pl/sql END IF\n- IF DELETING THEN bloc d’instructions pl/sql END IF\n– des Instructions SQL \nSELECT, INSERT, UPDATE, DELETE, ... mais pas de COMMIT et ROLLBACK\n– Instructions de contrôle de flux (IF, LOOP, WHILE, FOR)‏\n– Générer des exceptions\nraise_application_error(code_erreur,message)‏\ncode_erreur compris entre -20000 et -20999 (sinon code d’erreur oracle)\n– Faire appel à des procédures et fonctions PL/SQL\nTRIGGER: Activation / désactivation / suppression\nDésactivation du trigger :\nALTER TRIGGER <nomTrigger> DISABLE ;\nActivation de déclencheur :\nALTER TRIGGER <nomTrigger> ENABLE ;\nSuppression de déclencheur :\nDROP TRIGGER <nomTrigger> ;\nExemple TRIGGER : \nmaintien d'une contrainte d'intégrité dynamique\nEmpêcher une augmentation du prix d'un circuit de plus de 10% du prix \nactuel\nException Oracle: \nRAISE_APPLICATION_ERROR(code, message)‏\n-> ROLLBACK implicite\nCREATE TRIGGER circuitRestreindreAugmentationPrix \nBEFORE UPDATE OF prixInscription ON Circuit \nREFERENCING \n \nOLD AS rowAvant \n \nNEW AS rowApres \nFOR EACH ROW \nWHEN(   rowApres.prixInscription >  \n        rowAvant.prixInscription *1.1) \nBEGIN \n \n-- souleverUneException; \n \nRAISE_APPLICATION_ERROR(-20200, \n         'Augmentation prix circuit trop importante') ; \nEND ; \n \n \n \n \n \n \n \n \n \n \n\n08/12/2009\n5\nBorner l'augmentation de prix\n Modifier la valeur de l’attribut prix‏d’un‏n-uplet\navant son insertion dans la table\nCREATE TRIGGER circuitBornerAugmentationPrix \nBEFORE UPDATE OF prixInscription ON Circuit \nREFERENCING \n \nOLD AS rowAvant \n \nNEW AS rowApres \nFOR EACH ROW \nWHEN( rowApres.prixInscription >  \n      rowAvant.Inscription*1.1) \nBEGIN \n \n:rowApres.prixInscription :=  \n        :rowAvant.prixInscription * 1.1; \nEND; \n \n \n \n \n \n \n \n \n \n \nExemple TRIGGER: contrainte d'intégrité statique\nNbPlaceDisponible d'un circuit toujours compris entre \n0 et 100\nCHECK préférable\nCREATE TRIGGER PlaceCircuitVerifier \nBEFORE INSERT OR UPDATE OF nbPlaceDisponible \n    ON Circuit \nFOR EACH ROW \nWHEN (:new.nbPlaceDisponible <=0) OR \n     (:new.nbPlaceDisponible > 100) \nBEGIN \n \n-- souleverUneException; \nEND \nExemple TRIGGER: vérification multi-tables\nLors d'une nouvelle livraison, la quantité à livrer ne peut\ndépasser la quantité en stock disponible\nCREATE TRIGGER verifierQuantiteEnStock \nBEFORE INSERT ON Livraison \n     FOR EACH ROW \nDECLARE \n QuantStock_v INTEGER; \nBEGIN \n SELECT  quantitéEnStock INTO QuantStock_v \n FROM  \nArticle \n WHERE  \nIdArticle = :new.IdArticle; \n \n IF (:new.quantiteLivree > QuantStock_v ) \n \n-- souleverUneException; \n END IF ; \nEND \nExemple TRIGGER: limitation de modification\nLa relation Livraison contient les attributs idLivraison, idCommande, idArticle et quantiteLivraison\nSécurité: on n'autorise les modifications uniquement sur l'attribut quantitelivraison\nToutes les autres modifications provoquent une exception\nCREATE TRIGGER EmpecherModifLivraison \nBEFORE UPDATE OF IdLivraison, IdCommande, IdArticle  \n       ON Livraison \nBEGIN \n \n-- souleverUneException; \nEND \nExemple trigger: colonnes liées\n\nLe nombre d’article en stock est ajusté en fonction des livraisons reçues/envoyées\nCREATE TRIGGER AI_AjusterQuantitéEnStock \nAFTER INSERT ON Livraison \nFOR EACH ROW \nBEGIN \n \nUPDATE Article \n \nSET quantiteEnStock = quantiteEnStock - \n \n :new.quantiteLivree \n \nWHERE IdArticle = :new.IdArticle; \nEND \nCREATE TRIGGER AU_AjusterQuantiteStock \nAFTER UPDATE OF quantiteLivree ON Livraison \nFOR EACH ROW \nBEGIN \n \nUPDATE Article \n \nSET quantiteEnStock = quantiteEnStock - \n \n ( :new.quantiteLivree- :old.quantiteLivree) \n \nWHERE IdArticle = :old.IdArticle; \nEND \nTRIGGER: Ordre d'exécution\nOrdre d’exécution des TRIGGER ?\n- BEFORE avant AFTER,...\n- entre TRIGGER de même type ?\nforcer un ordre en les combinant\nCombiner plusieurs TRIGGER: \n- vérifier quel est l ’événement déclencheur\n- pour ORACLE, tester IF INSERTING, DELETING, \nUPDATING\nAttention à l’ordre d’exécution des déclencheurs !!!\n\n08/12/2009\n6\nExécuter les TRIGGER BEFORE STATEMENT\nPour chaque ligne touchée par l'opération\nExécuter les TRIGGER BEFORE ROW\nExécuter l'opération\nExécuter les TRIGGER AFTER ROW\nFin pour\nExécuter les TRIGGER AFTER STATEMENT\nTRIGGER: Ordre d'exécution global \nTRIGGER: limites\n- peuvent être complexes à coder\n- pas de respect de standard:\ncontraintes particulières aux langages de codage\n- pas de mise à jours sur la table affectée\nSQL> CREATE OR REPLACE TRIGGER BUArticleBornerAugPrix \n  2  BEFORE UPDATE OF prixUnitaire ON Article \n  3  REFERENCING \n  4   \n     OLD AS ligneAvant \n  5   \n     NEW AS ligneAprès \n  6  FOR EACH ROW \n  7  WHEN (ligneAprès.prixUnitaire > ligneAvant.prixUnitaire*1.1) \n  8  BEGIN \n  9   \n     :ligneAprès.prixUnitaire := :ligneAvant.prixUnitaire*1.1; \n 10  END; \n 11  / \n \nDéclencheur créé. \n \nTRIGGER: exemple de déclenchement\nSQL> -- Test du TRIGGER BUArticleBornerAugPrix \nSQL> SELECT * FROM Article WHERE IdArticle = 10 \n  2  / \n \nIDARTICLE DESCRIPTION          PRIXUNITAIRE QUANTITÉENSTOCK \n--------- -------------------- ------------ --------------- \n       10 Boule de cèdre              10,99              10 \n \nSQL> UPDATE   Article \n  2  SET      prixUnitaire = 15.99 \n  3  WHERE \nIdArticle = 10 \n  4  / \n \n \n1 ligne mise à jour. \n \nSQL> SELECT * FROM Article WHERE IdArticle = 10 \n  2  / \n \nIDARTICLE DESCRIPTION          PRIXUNITAIRE QUANTITÉENSTOCK \n--------- -------------------- ------------ --------------- \n       10 Boule de cèdre              12,09              10 \n \nTrigger INSTEAD OF pour Vue non modifiable ‏\nSQL> SELECT * FROM Article WHERE IdArticle = 10 \n  2  / \n \n IDARTICLE DESCRIPTION          PRIXUNITAIRE QUANTITÉENSTOCK \n---------- -------------------- ------------ --------------- \n        10 Boule de cèdre            10,99              20 \n \nSQL> CREATE VIEW ArticlePrixPlusTaxe AS \n  2   SELECT  IdArticle, description, prixUnitaire * 1.15 AS prixPlusTaxe \n  3   FROM  Article \n  4  / \n \nView created. \n \nSQL> UPDATE ArticlePrixPlusTaxe \n  2  SET prixPlusTaxe = 23 \n  3  WHERE IdArticle = 10 \n  4  / \nSET prixPlusTaxe = 23 \n    * \nERROR at line 2: \nORA-01733: virtual column not allowed here \nSQL> CREATE OR REPLACE TRIGGER InsteadUpdate  \n  2  INSTEAD OF UPDATE ON ArticlePrixPlusTaxe \n  3  REFERENCING \n  4   OLD AS ligneAvant \n  5   NEW AS ligneAprès \n  6  FOR EACH ROW \n  7  BEGIN \n  8   UPDATE Article \n  9   SET  \n 10    \nIdArticle = :ligneAprès.IdArticle, \n 11   \ndescription = :ligneAprès.description, \n 12    \nprixUnitaire = :ligneAprès.prixPlusTaxe / 1.15 \n 13   WHERE IdArticle = :ligneAvant.noArticle; \n 14  END; \n 15  / \n \nTrigger created. \n \nSQL> UPDATE ArticlePrixPlusTaxe \n  2  SET prixPlusTaxe = 23 \n  3  WHERE IdArticle = 10 \n  4  / \n \n1 row updated. \n \nSQL> SELECT * FROM Article WHERE IdArticle = 10 \n  2  / \n \n IDARTICLE DESCRIPTION          PRIXUNITAIRE QUANTITÉENSTOCK \n---------- -------------------- ------------ --------------- \n        10 Boule de cèdre               20              20 \n\n08/12/2009\n7\nimport java.sql.*; \nimport java.io.*; \npublic class RoutineServeur extends Object { \n \n  public static int getQuantiteEnStock (int noArticle) throws SQLException { \n      // Retourne -1 si l'article n'existe pas \n      PreparedStatement unEnoncéSQL = null; \n      int quantitéEnStock = -1; \n      try { \n        Connection uneConnection = \n          DriverManager.getConnection(\"jdbc:default:connection:\"); \n        unEnoncéSQL = uneConnection.prepareStatement \n        (\"SELECT quantitéEnStock FROM Article WHERE idArticle = ? \"); \n        unEnoncéSQL.setInt(1,noArticle); \n        ResultSet résultatSelect = unEnoncéSQL.executeQuery(); \n        if (résultatSelect.next ()){ \n           quantitéEnStock = résultatSelect.getInt(1); \n        } \n      } \n      catch (SQLException e) {System.err.println(e.getMessage());} \n      finally{unEnoncéSQL.close();} \n      return quantitéEnStock; \n  } \n \n  public static void setQuantiteEnStock (int noArticle, int quantitéEnStock) throws \nSQLException { \n      PreparedStatement unEnoncéSQL = null; \n      try { \n        Connection uneConnection = \n          DriverManager.getConnection(\"jdbc:default:connection:\"); \n        unEnoncéSQL = uneConnection.prepareStatement \n        (\"UPDATE Article SET quantitéEnStock = ? WHERE idArticle = ? \"); \n        unEnoncéSQL.setInt(1,quantitéEnStock); \n        unEnoncéSQL.setInt(2,noArticle); \n        unEnoncéSQL.executeUpdate(); \n      } \n      catch (SQLException e) {System.err.println(e.getMessage());} \n      finally{unEnoncéSQL.close();} \n  } \n} \nProcédures stokées en Java\n\nCharger le code dans la base:\n\nPublier sous forme de routine stockée :\n\nAppeler la fonction en SQL:\n\nPossibilité de définir un déclencheur utilisant une procédure/fonction écrit\nen Java\nloadjava -user Scott/Tiger RoutineServeur.class \nSQL> CREATE OR REPLACE FUNCTION getQuantiteEnStock(noArticle NUMBER)\n  2  RETURN NUMBER\n  3  AS LANGUAGE JAVA\n  4  NAME ' RoutineServeur.getQuantiteEnStock (int) return int';\n  5  /\nFunction created.\nSQL> select getQuantiteEnStock(10) from dual;\nGETQUANTITEENSTOCK(10)\n----------------------\n                    20\nDéploiement Oracle\nArchitecture des Application Web\nNiveau Logique (architecture trois tier) \n Couche Présentation\n Couche Métier/Application\n Couche Accès aux données\nNiveau Physique \n Client\n Serveur Web\n Serveur d'application\n Serveur de données\nCouche Présentation\nArchitecture trois tier\nCouche Métier\nCouche donnée persistante\nAutorise l'utilisateur final à interagir avec \nl'application\nEffectue les calculs (partie fonctionnelle de \nl'application)‏\nIntégration des systèmes\nConservation des données\nDonnées utilisées pour générer la présentation\nDonnées collectées par l'application\nPartie visible de l'application (ex: page \nHTML), contenu mis à disposition du client\n3 - Tier architecture\nPHP script\nServeur Web \n(Apache, IIS)‏\nBrowser\n(IE, FireFox, \nOpera)‏\nBureau \n(PC or MAC)‏\nBase de données\nServeur Base de \ndonnées\n(Oracle, PostGres, \nmySQL, ...)‏\nSQL\nHTTP \nHTML\nDonnées\nCouche Présentation \nCouche Application \nCouche données\nCouche Présentation \n\n08/12/2009\n8\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n<body>\n<h1>Region list</h1>\n<?php\n$link = pg_Connect(\"host=localhost user=login dbname=login\");\n$result = pg_query(\"SELECT * FROM regions\", $link) or \ndie(\"ERROR: Request failed\");\nif (pg_numrows($result) == 0)‏\nprint(\"<h2>Sorry, no region, db is empty.</h2><br>\");\nelse\nwhile ($row = pg_fetch_array($result))‏\n{\nprint(\"<a href=\\\"BrowseCategories.php?region=\".\n$row[\"id\"].\"\\\">\".$row[\"name\"].\"</a><br>\\n\"); }\npg_free_result($result);\npg_close($link);\n?>\n</body>\n</html>\nExemple PHP\nConcurrence des accès\n un SGBD est multi-utilisateurs\n une même donnée peut être manipulée par \nplusieurs utilisateurs à la fois\n problèmes d'accès concurrents (perte de mise \nà jour, lecture incohérente, …)\n comment garantir la cohérence des données ?\n contraintes de temps réel\n45\nTransaction\n Une transaction est une séquence d'opérations\nqui accèdent ou modifient le contenu d'une base\nde données .\n Granularité des opérations de lecture/modification de\nla base: table, n-uplet, donnée, …\n Une transaction permet de passer d’un état\ncohérent de la base à un autre état cohérent\nDurant la transaction\nPossible état incohérent\nDébut de la transaction\nEtat cohérent de la BD\nFin de la transaction\nEtat cohérent de la BD\n46\nTransaction\n Une transaction peut être validée ou annulée\n Le début d'une transaction peut être implicite ou\nexplicite\n La fin d'une transaction peut être implicite ou\nexplicite\n Contraintes sur les transactions:\n Vitesse d’exécution\n Sécurité\n47\nTransaction\nCommandes de transaction\n Début de transaction implicite\n Début d’une session\n Un début de transaction explicite est définie par :\n COMMIT (fin de la transaction précédente)\n BEGIN_TRANSACTION (SQL standard, pas Oracle)\n Une fin explicite est définie par :\n ROLLBACK (annulation) \n COMMIT (validation)\n Une fin implicite est définie par :\n Exécution d'une commande du langage de définition de données\n Fin d’une session\n48\n\n08/12/2009\n9\nExemple de transaction\n-- livraison de 10 exemplaires du produit 113\n-- les stocks sont mis à jour\nCOMMIT;\nINSERT INTO \nlivraison (idProduit, quantité, idClient)\nVALUES \n(113, 12, 1125); \nUPDATE produit SET quantité=quantité - 12 \nWHERE idProduit = 113;\nCOMMIT COMMENT ‘Virement effectué’; -- Ou ROLLBACK \n49\nTransaction : propriétés ACID\n Atomicité : Une transaction est indivisible. Elle est\nsoit complètement exécutée soit pas du tout (unité\natomique de traitement)\n Cohérence : une transaction doit effectuer une\ntransition d’un état cohérent de la base à un autre état\ncohérent (par ex: pas de violation de contrainte\nd’intégrité). La cohérence peut être non respectée\npendant l'exécution d'une transaction. En cas d’échec\nde la transaction, la base doit retourner dans l’état\ncohérent initial\n50\nTransaction : propriétés ACID\n Isolation : le résultat d’un ensemble de \ntransactions concurrentes et validées correspond à \nune exécution successive des mêmes transactions \n(pas d’inférence entre les transactions)\n Durabilité : après la fin d'une transaction, les mises \nà jour sont définitives même en cas de problèmes \nmatériels (mécanisme de reprise en cas de panne) \n51\nEtats des données avant COMMIT ou ROLLBACK\nComportement standard:\n L’état précédentde la base peut être récupéré,\n L’utilisateurcourant peut voir le résultat de ses mises à \njour de données,\n Les autres utilisateurs ne peuvent généralement pas voir\nles mises à jour effectuées par l’utilisateurcourant,\n Certaines donnéespeuvent être verrouillées,\n Les autres utilisateurs ne peuvent modifier les données\nverrouillées.\n52\nEtat après le COMMIT\n Les modifications de la base sont permanentes,\n L’etat précédentde la base est définitivement perdu,\n Tous les utilisateurs peuvent voir le résultat des \nopérationsde DML,\n Les verrous sont relachés,\n Tous les points de sauvegarde sont effacés.\n53\nTransaction\nValidationde transaction partielle\n On peut découper une transaction en créant des points\nd'arrêts (savepoint).\n SAVEPOINT S1;\n Ces points d'arrêts permettent d’annuler seulement\nune partie de la transaction. La commande ROLLBACK\npermet de retournerà un point d’arrêts:\n ROLLBACK TO S1;\n54\n\n08/12/2009\n10\nContrôle de la concurrence\nObjectif: synchroniser les transactions concurrentes de façon \nà maintenir la cohérence de la BD tout en minimisant les \nrestrictions d’accès.\nPrincipes:\n Exécution simultanée des transactions\n Opération 1 de la transaction T1, opération 1 de la transaction \nT2, opération 2 de la transaction T1, …\n permet d’améliorer la performance du SGBD\n L’exécution simultanée de transactions concurrentes doit \nêtre équivalent à une exécution non simultanée (propriété \nIsolation)\n55\nContrôle de la concurrence\nOpérations élémentaires d’accès à la base de données\nLire(X)\nLit la granule X, qui sera généralement stockée dans \nune variable (par convention la variable sera aussi \nnommée X)\nEcrire (X)\nEcrit la valeur de la variable X dans la granule X\n56\nExemple de transactions concurrentes\nTransaction T1\nLire(X);\nX = X – 500;\nEcrire(X);\nLire(Y);\nY = Y + 500;\nEcrire(Y);\nAccède aux granules X et Y\n57\nTransaction T2\nLire(X);\nX = X + 1000;\nEcrire(X);\nAccède à la granule X\nExemple d’exécution simultanée\nTransaction T1\nLire(X);\nX = X – 500;\nEcrire(X);\nLire(Y);\nY = Y + 500;\nEcrire(Y);\n58\nTransaction T2\nLire(X);\nX = X + 1000;\nEcrire(X);\nX = 2000\nY = 0\nX = 2500\nY = 500\nContrôle de concurrence\nTransaction T1\nLire(X);\nX = X – 500;\nEcrire(X);\nLire(Y);\nY = Y + 500;\nEcrire(Y);\n59\nTransaction T2\nLire(X);\nX = X + 1000;\nEcrire(X);\nLa mise à jour de la granule X \npar la transaction T1 est perdue\nNécessité de contrôler les transaction pour éviter les \nincohérence: ici perte de mise à jour\nX = 2000\nY = 0\nX = 3000\nY = 500\nIntroduction d’incohérence\nTransaction T1\nLire(X);\nX = 2 * X;\nEcrire(X);\nLire(Y);\nY = 2 * Y;\nEcrire(Y);\n60\nTransaction T2\nLire(X);\nX = X + 1;\nEcrire(X);\nLire(Y);\nY = Y + 1;\nEcrire(Y);\nContrainte:   X = Y\nX = 100\nY = 100\nX = Y\nX = 201\nY = 202\nX != Y\n\n08/12/2009\n11\nMise à jour temporaire (dirty read)\nTransaction T1\nLire(X);\nX = X + 500;\nEcrire(X);\nROLLBACK;\n61\nTransaction T2\nLire(X);\nX = X + 1000;\nEcrire(X);\nT2 a lu une valeur temporaire \nde X et s’en est servi pour \neffectuer une mise à jour\nLecture non répétable\nTransaction T1\nLire(X);\nX = X – 500;\nEcrire(Y);\nCOMMIT;\n62\nTransaction T2\nS = 0;\nLire(X);\nS = S + X;\nLire(X);\nS = S + X;\nLa valeur de X lu par T2 à la fin \nde la transaction n’est pas la \nmême que celle lu au début (elle \npeut même avoir été supprimée)\nLecture fantôme\nTransaction T1\nINSERT INTO P1 VALUES (500000); \n63\nTransaction T2\nS = 0;\nLire(X); // Select max(X) from P1;\nS = S + X;\nLe contenu de la table P1 a été \nmodifié. La valeur précédemment \nlue n’est plus le maximum de la \nvaleur X de la table P1\nDegrés d’isolation SQL-92\nOn peut préciser si l’on souhaite éviter ou non les cas suivants:\n Lecture sale : Une transaction lit des données écrites par une \ntransaction concurrente mais non validée\n Lecture non reproductible : Une transaction lit de nouveau des \ndonnées qu’elle a lues précédemment et trouve que les données \nont été modifiées par une autre transaction (qui a validé depuis \nla lecture initiale)\n Lecture fantôme : Une transaction ré-exécute une requête \nrenvoyant un ensemble de lignes satisfaisant une condition de \nrecherche et trouve que l’ensemble des lignes satisfaisant la \ncondition a changé à cause d’une transaction récemment validée\n64\nExécution\nExécution: ordonnancement des opérations d’un ensemble de transaction\nExemple : \n3  transactions  T1,  T2, et T3\n3  granules  X, Y et Z\nT1 : Lire(X),  \nEcrire(X)\nT2 : Ecrire(X), Ecrire(Y), \nEcrire(Z)\nT3 : Lire(X), \nLire(Y), \nLire(Z)\nExemple d’exécution:\nK = E2(X), L1(X), L3(X), E1(X), E2(Y), L3(Y), E2(Z), L3(Z)\n65\nExécution en série\nExécution sérielle: exécution sans entrelacement \nd’opérations de différentes transactions. Equivalent à une \nexécution successive par un unique utilisateur des \ndifférentes transactions.\nExemple:\nK = L1(X), E1(X), E2(X), E2(Y), E2(Z),  L3(X), L3(Y), L3(Z)\n66\nT1\nT2\nT3\n\n08/12/2009\n12\nExécutions correctement synchronisées\n Deux exécutions sont équivalentes si elles ont les \nmêmes transactions, l’ordre des opérations des \ntransactions est le même et qu’elles produisent les \nmêmes effets sur la base\n Sérialisabilité\nLes exécutions concurrentes sont correctes si et \nseulementsi leur résultat est équivalent à celui d'une\nexécution sérielle (non simultanée)\n Critères couramment accepté (cas particulier les bases de \ndonnées distribués)\n67\nExécutions équivalentes\nT1 : Lire(X),   Ecrire(X)\nT2 : Ecrire(X), Ecrire(Y), Ecrire(Z)\nT3 : Lire(X),   Lire(Y),   Lire(Z)\nK1 = E2(X), L1(X), L3(X), E1(X), E2(Y), L3(Y), E2(Z), L3(Z) \nK2 = E2(X), L3(X), L1(X), E1(X), E2(Y), L3(Y), E2(Z), L3(Z) \nK3 = E2(X), L1(X), L3(X), E1(X), L3(Y), E2(Y), E2(Z), L3(Z) \nK1 et K2 sont 2 exécutions équivalentes.\nK2 et K3 ne sont pas équivalentes.\nKs = E2(X), E2(Y), E2(Z), L3(X), L3(Y), L3(Z), L1(X), E1(X) \n= T2, T3, T1\nK1 et K2 sont équivalent à Ks qui est une exécution en série. K1 et K2 sont sérialisable.\n68\nGraphe de précédence\nLe graphe (orienté) de précédence Gk = {S,A} pour une \nexécution K est défini tel que :\n S = ensemble des transactions de l’exécution K\n Il existe un arc entre (Ti,Tj) si\n Ti lit/écrit la granule X avant une écriture dans X de Tj\n Ti écrit une granule X avant une lecture de X de Tj\n On dit que Ti précéde Tj\n69\nGraphe de précédence\nK2 = E2(X), L3(X), L1(X), E1(X), E2(Y), L3(Y), E2(Z), L3(Z) \nK3 = E2(X), L1(X), L3(X), E1(X), L3(Y), E2(Y), E2(Z), L3(Z) \n70\nT1\nT2\nT3\nx\nx\nx\nY Z\nT1\nT2\nT3\nx\nx\nY Z\nx\nGraphe de précédence de K2\nGraphe de précédence de K3\nOn‏peut‏prouver‏qu’une‏exécution‏est‏sérialisable si et seulement si \nle graphe de précédence ne contient aucun cycle.\nK3 contient‏un‏cycle,‏donc‏l’exécution‏n’est‏pas‏sérialisable.\nDegrés d'isolation\n Sérialisabilitétotalecoûte cher\n Elle n'est pas nécessaires pour toutes transactions\n Les SGBD et SQL-92 offrent dès lors différents niveaux\nd'isolation de transactions\n à utiliser avec des précautions\n71\nIsolation \nLevel\nDirty \nRead\nNonrepeatable \nRead\nPhantom \nRead\nRead \nuncommitted\nY\nY\nY\nRead committed\nN\nY\nY\nRepeatable read\nN\nN\nY\nSerializable\nN\nN\nN\nDegrés d’isolation SQL-92\n\n08/12/2009\n13\nOracle isolation levels\nRead committed\nChaque requête ne voit que les données\nvalidées (isolation level d’Oracle par \ndéfaut)\nSerializable\nVoit les données telles qu’elles étaient au \ndébut de la transaction. Une transaction \nvoit aussi ses propres modifications.\nRead-only\nLa transaction voit les données telles\nqu’elles étaient au début de la transaction. \nToutes commandes DML est interdites.\nCommande SQL (Oracle):\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED; \nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE; \nSET TRANSACTION READ ONLY;\nOracle isolation levels\nContrôle de concurrence\nLe contrôle de concurrence permet de s’assurer que seul des \nexécutions sérialisables soient générées.\n2 types de techniques existent pour garantir la sérialisation des \nopérations:\n- Techniques optimistes: détection des conflits et annulation de leur \neffet si possible (permutation d’opérations). Sinon annulation de \ntransactions.\nValable uniquement si les conflits sont rares. Il est alors acceptable \nde réexécuteroccasionnellement certaines transactions.\n- Techniques pessimiste: empêcher l’apparition des conflits de mise \nà jour en verrouillant les objets de la base.\nOn suppose dans ce cas que les conflits sont fréquents et qu’il faut \nles traiter le plus rapidement possible.\n75\nContrôle de concurrence\nLes techniques de contrôle de concurrence pessimistes \nsont les plus souvent utilisées.\nElles consistent à poser des verrous sur les objets de la \nbase.\n76\nVerrou\nUn verrou est une variable d'état associée à un objet X de\nla base et indiquant son état vis à vis des opérations de\nlecture/écriture\n Verrou binaire:\n2 états :\n\nverrouillé (pose de verrou): l’accès à un objet est bloqué dès qu’il est lu ou écrit par une \ntransaction \n\nlibre:  le verrou sur un objet est libéré à la fin de la transaction\n Verrou ternaire :\n3 états :\n\nverrou partagé (\"shared lock\"): plusieurs transactions peuvent lire l’objet \n\nverrou exclusif (\"exclusive lock\"): réserve l’objet en écriture pour la transaction qui pose ce \nverrou\n\nlibre. \n77\n Un verrou peut toujours être posé sur une donnée non \nverrouillée, la donnée est alors verrouillée\n Plusieurs verrous en lecture peuvent être posés sur une \ndonnée déjà verrouillée en lecture\n Si une donnée est verrouillée en écriture, aucun autre \nverrou ne peut être posé tant que ce verrou n’a pas été \nsupprimé\n Deux verrous sont dits compatibles si deux transactions qui \naccèdent à la même donnée peuvent obtenir les verrous sur \ncette donnée au même moment.\n\n08/12/2009\n14\nVerrouillage de ressources\nUn verrou peut intervenir à différents niveau de la base:\n sur la base données,\n sur les tables,\n sur les n-uplets,\n sur les données.\n79\nVerrouillage à deux phases \n Chaque transaction verrouille l’objet avant de l’utiliser\n Quand une demande de verrou est en conflit avec un \nverrou posé par une autre transaction en cours, la \ntransaction qui demande doit attendre\n Quand une transaction libère son premier verrou, elle \nne peut plus demander d’autres verrous\n Toute exécution obtenue par un verrouillage à deux \nphases est sérialisable\n80\nProblème avec le verrouillage: interblocage\nVerrou mortel\n81\nT1\nT2\nT3\nRésolution du verrou mortel\n Prévention\n définir des critères de priorité de sorte à ce que le \nproblème ne se pose pas\n exemple : priorité aux transactions les plus anciennes\n Détection\n gérer le graphe des attentes\n lancer un algorithme de détection de circuits dès qu’une \ntransaction attend trop longtemps\n choisir une victime qui brise le circuit\nAméliorations du verrouillage\n Relâchement des verrous en lecture après opération\n- non garantie de la reproductibilité des lectures\n+ verrous conservés moins longtemps\n Accès à la version précédente lors d'une lecture \nbloquante\n- nécessité de conserver une version (journaux)\n+ une lecture n'est jamais bloquante\nOracle durée des verrous\n Tous les verrous acquis durant une transaction reste actif\ntous le temp de la transaction.\n Les verrous sont relachés lors d’un commit ou rollback\n84\n\n08/12/2009\n15\nOracle DML Locks\nLes opérations de manipulation de données peuvent\nacquerir un verrou à deux niveaux: ligne ou table.\n85\nTable Locks\nRS: row share\nLes autres transactions peuvent\nmodifier la table mais pas la verrouiller\nen mode exclusif\nRX: row exclusive\nComme row share mais la table ne peut\npas être verrouiller en share\nS: share\nAccès concurrents autorisés sur la table \nmais pas les modifications\nSRX: share row exclusive\nLes accès sont autorisés sur la table mais\npas les modifications ou de la verrouiller\nen share\nX: exclusive\nSeuls les accès à la table sont autorisés\n* Attends si une autre transaction a déjà \nposé le verrou\nOrdonnancement par estampillage\nOn affecte \n à chaque transaction t une estampille unique TS(t) dans un \ndomaine ordonné.\n à chaque granule g \n une étiquette de lecture EL(g)\n une étiquette d’écriture EE(g)\nqui contient l’estampille de la dernière transaction la plus \njeune (max(TS(t))) qui a lu (respectivement) écrit g.\nOrdonnancement par estampillage\nLa transaction t veut lire g :\n Si TS(t) ≥EE(g),la lecture est acceptée  et \nEL(g) := max(EL(g), TS(t))\n Sinon la lecture est refusée et T est relancée avec une nouvelle \nestampille (plus grande que tous les autres)\nLa transaction t veut écrire g :\n Si TS(t) ≥max(EE(g), EL(g)),l’écriture est acceptée et \nEE(g) := TS(t)\n Sinon l’écriture est refusée et T est relancée avec une nouvelle \nestampille (plus grande que tous les autres).\n88\nBilan Estampillage\n Approche optimiste\n coût assez faible\n détecte et guérit les problèmes\n Guérison difficile\n catastrophique en cas de nombreux \nconflits\n gère mal les pics d’accès",
  "file_type": "document",
  "original_path": "data/uploads\\module_cours SQL.pdf"
}