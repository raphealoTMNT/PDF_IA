{
  "filename": "module_poly2013.pdf",
  "extraction_date": "2025-09-02T00:52:47.961681",
  "statistics": {
    "word_count": 8739,
    "character_count": 51512,
    "line_count": 860
  },
  "top_keywords": [
    [
      "valeur",
      81
    ],
    [
      "méthode",
      75
    ],
    [
      "type",
      70
    ],
    [
      "dans",
      56
    ],
    [
      "string",
      56
    ],
    [
      "variable",
      53
    ],
    [
      "objet",
      42
    ],
    [
      "instructions",
      41
    ],
    [
      "tableau",
      41
    ],
    [
      "sont",
      38
    ]
  ],
  "extracted_data": {
    "emails": [],
    "urls": [],
    "dates": []
  },
  "content_preview": "Résumé du cours de Programmation Java\nCarole Frindel et Céline Robardet\nTABLE DES MATIÈRES\n1 Notions élémentaires 1\n1.1 Qu’est-ce qu’un programme ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n1.2 Les variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n1.2.1 Les types primitifs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.2.2 Les conversions . . . . . ...",
  "full_content": "Résumé du cours de Programmation Java\nCarole Frindel et Céline Robardet\nTABLE DES MATIÈRES\n1 Notions élémentaires 1\n1.1 Qu’est-ce qu’un programme ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n1.2 Les variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n1.2.1 Les types primitifs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.2.2 Les conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.2.3 Les opérateurs de comparaison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 Le programme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.4 Les structures de contrôle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n1.4.1 Bloc d’instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n1.4.2 Structures conditionnelles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6\n1.4.3 Structures itératives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n2 Les méthodes 9\n2.1 Les méthodes prédéﬁnies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n2.2 Les méthodes propres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n2.3 Les méthodes récursives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2.4 Un exemple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3 Les types non primitifs 12\n3.1 Généralités . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n3.2 Les tableaux . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n3.2.1 Tableaux à 1 dimension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n3.2.2 Tableaux à n dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n3.3 Méthodes à paramètres de type non-primitif . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n3.3.1 Instanciation des variables de type non-primitif dans une méthode . . . . . . . . . . . . . 14\n3.3.2 Modiﬁcation des valeurs d’une variable de type non-primitif dans une méthode . . . . . 14\n3.4 Les objets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n3.4.1 L’objet prédéﬁni String . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n3.4.2 Les objets propres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n4 Glossaire 19\nCe support de cours couvre l’intégralité du programme de première année et vous permettra de com-\nprendre les concepts liés à la programmation en Java. La section 3.4.2 introduit quelques concepts de la\nprogrammation objet, qui sont vus en deuxième année du premier cycle.\n1 N OTIONS ÉLÉMENTAIRES\n1.1 Q U’EST-CE QU ’UN PROGRAMME ?\nL’objectif de la programmation est de créer des logiciels ou programmes. Ceux-ci sont constitués d’un en-\nsemble de traitements qui permettent de transformer des données numériques (les entrées) en d’autres don-\nnées numériques (les sorties). Les données de sortie peuvent être afﬁchées sous une forme graphique (avec\n1\ndes fenêtres comme le fond les programmes tels que Word et Excel) ou plus simplement afﬁchées dans une\nconsole?1sous forme de texte.\nQue se passe-t-il pour l’ordinateur lorsqu’on exécute un programme ? Il va lire le ﬁchier exécutable du\nprogramme comme une suite de 0 et de 1 (codage binaire) et exécuter l’une après l’autre les instructions\nainsi codées. Cette suite de 0 et de 1 est appelée langage machine et est directement exécutable par le micro-\nprocesseur de l’ordinateur. Or il est très difﬁcile pour un humain de programmer directement en binaire,\nc’est pourquoi on utilise un langage de programmation écrit en langage textuel dans un ﬁchier source (ﬁchier\n.java). Le ﬁchier source est ensuite compilé?en langage binaire (ﬁchier .class) puis exécuté pour réaliser les\ntraitements :\nCompilation Exécution\n$  javac Bonjour.java\n $ java Bonjour\n1.2 L ES VARIABLES\nLes variables constituent l’aspect le plus important de la programmation, puisqu’elles permettent de stocker\ndans un emplacement mémoire les données et de les transformer en utilisant des opérateurs?. On peut se\nreprésenter une variable comme une étiquette associée à une unique boîte dans laquelle est rangée une valeur\nd’un certain type (entier ou réel, par exemple) :\nAvant de pouvoir utiliser une variable, il est nécessaire de la déclarer?, c’est-à-dire d’associer la variable à un\nemplacement de la mémoire et de spéciﬁer son type. C’est en fonction du type de la variable que la taille\nde l’emplacement mémoire (en octet, soit 8 bits) et le codage binaire de la valeur seront déterminés. La\ndéclaration se fait par une instruction de la forme :\ntypeVariable nomVariable;\nLa variable nomVariable est de type typeVariable . Il lui est associé un emplacement mémoire qui con-\ntient une valeur qu’il faut initialiser?. Cela se fait en utilisant l’opérateur d’affectation “ =” :\nnomVariable = uneValeur;\nL’affectation?écrit dans l’emplacement mémoire associé à nomVariable la valeur uneValeur . On dit alors\nquenomVariable “prend la valeur” uneValeur .\nuneValeur doit être compatible avec le type de nomVariable . Par exemple si typeVariable est un\nentier, uneValeur doit être une valeur entière. On peut faire ici le parallèle entre le type d’une variable\net l’unité de mesure d’une grandeur physique qui spéciﬁe la nature de la grandeur manipulée.\nOn peut également faire la déclaration et l’initialisation d’une variable en une seule instruction :\n1Le symbole?indique que le mot est déﬁni dans la section Glossaire.\nProgrammation Java page 2 of 20\ntypeVariable nomVariable = uneValeur;\nDans la suite, nous allons détailler les quatre types dits “primitifs”?, qui sont directement accessibles en\nmémoire (contrairement aux types non primitifs que nous verrons dans la section 3), c’est-à-dire que la valeur\naffectée à la variable est stockée dans l’emplacement mémoire associée à celle-ci. Pour chacun de ces types,\nnous verrons également les opérateurs que l’on peut appliquer sur des variables de ce type pour transformer\nleur valeur.\n1.2.1 L ES TYPES PRIMITIFS\nOn distingue 4 catégories de types primitifs (entier, réel, booléens, caractères). L’intervalle de valeurs représenta-\nbles pour chacun des types peut varier en fonction de l’espace mémoire qu’ils occupent.\nLES ENTIERS En Java, tous les types permettant de représenter des entiers sont signés. Ainsi, sur nbits, on\npeut coder les entiers de \u0000(2n\u00001)à 2n\u00001\u00001. Les valeurs négatives sont encodées en complément à 2. Pour\nun rappel sur cet encodage, nous vous renvoyons au cours de numération disponible sur la page du CIPC.\nLes différents types d’entiers sont les suivants :\nNom Taille Intervalle représentable\nbyte 1 octet [\u0000128 . . . 127 ]ou[\u000027. . . 27\u00001]\nshort 2 octets [\u000032768 . . . 32767 ] [\u0000215. . . 215\u00001]\nint 4 octets [\u0000231. . . 231\u00001]\nlong 8 octets [\u0000263. . . 263\u00001]\nOn peut appliquer des opérateurs arithmétiques ( +,-,*,/) à deux variables ou deux expressions de type entier\n(la composition étant possible comme en mathématiques). Le résultat de cette opération est également du\ntype entier (ce qui permet la composition).\nLorsque les deux opérandes sont de type entier, l’opérateur /calcule la division entière et l’opérateur %\ncalcule le reste de cette division.\nPar exemple2:\nint valA = 7;\nint valB = 2;\nint valC = valA / valB; // valC contient la valeur 3\nint valD = valA % valB; // valD contient la valeur 1\nLES RÉELS La description du codage des réels est décrite dans le cours de numération sur la page du CIPC. En\nJava il existe deux types de représentation pour les nombres réels : simple et double précision (respectivement\nles types float etdouble ).\nNom Taille Intervalle représentable\nfloat 4 octets [\u00003.4 . 1038,\u0001\u0001\u0001,\u00001.4 . 10\u000045, 0, 1.4 . 10\u000045,\u0001\u0001\u0001, 3.4 . 1038]\ndouble 8 octets [\u00001.8 . 10308,\u0001\u0001\u0001,\u00004.9 . 10\u0000324, 0, 4.9 . 10\u0000324,\u0001\u0001\u0001, 1.8 . 10308]\nLorsqu’au moins une des opérandes est de type réel, l’opérateur /calcule la division réelle.\ndouble reelA = 7;\ndouble reelB = 2;\ndouble division = reelA / reelB; //La variable division contient la valeur 3.5\n2//indique que la suite de la ligne est un commentaire.\nProgrammation Java page 3 of 20\nLES BOOLÉENS Un type de variable très utile en informatique est le type booléen, qui prend deux valeurs\nVRAI ou FAUX.\nNom Taille Intervalle représentable\nboolean 1 octet [true,false ]\nOn peut appliquer des opérateurs logiques ( et, ou, non ) à des variables ou des expressions booléennes. Le\nrésultat de cette opération est également du type booléen.\n\u000f&& désigne l’opérateur etlogique\n\u000f|| désigne l’opérateur oulogique\n\u000f! désigne l’opérateur nonlogique (qui transforme une valeur true en valeur false et inversement)\na b aetb\nFaux Faux Faux\nFaux Vrai Faux\nVrai Faux Faux\nVrai Vrai Vraia b aoub\nFaux Faux Faux\nFaux Vrai Vrai\nVrai Faux Vrai\nVrai Vrai Vrai\nboolean boolA = TRUE;\nboolean boolB = FALSE;\nboolean nonA = !boolA; // nonA vaut FALSE\nboolean AetB = boolA && boolB; // AetB vaut FALSE\nLES CARACTÈRES Le type caractère peut correspondre à n’importe quel symbole du clavier (lettre en majus-\ncule ou minuscule, chiffre, ponctuation et symboles).\nNom Taille Intervalle représentable\nchar 2 octets [a...z,A...Z,0...9,:,;.?!... ]\nPour distinguer la valeur correspondant au caractère a de la variable dénommée a, on utilise l’apostrophe\npour la première.\nchar caractere = ’a’; // La variable caractere contient la valeur a\nint a = 3; // La variable a contient la valeur 3\nComme toute donnée numérique, un caractère est encodé sous forme d’une suite de 0 et de 1 que l’on peut\ninterpréter comme un entier non signé. Dans certains contextes, il est utile de manipuler directement ce code.\nOn convertit alors la variable de type char en une variable de type intcomme expliqué ci-dessous.\n1.2.2 L ES CONVERSIONS\nLa conversion (également appelée transtypage) d’un type primitif en un autre se fait de la manière suiv-\nante :\ntypeVariableA variableA =(typeVariableA) valeurB\nSivariableA etvaleurB ne sont pas du même type, cette instruction affecte à variableA la conversion\nde la valeur de valeurB dans le type typeVariableA :\nEntier vers Réel la même valeur codée en réel\nRéel vers Entier la partie entière du réel\nEntier vers caractère le caractère dont le code est l’entier\nCaractère vers Entier le code numérique correspondant au caractère\nProgrammation Java page 4 of 20\nint i;\ndouble x = 2;\ni = (int) (x * 42.3); // i vaut 84\n1.2.3 L ES OPÉRATEURS DE COMPARAISON\nLes opérateurs de comparaison permettent de comparer deux variables d’un même type primitif (entier, ﬂot-\ntant, booléen et caractère) et renvoient une valeur booléenne :\n== comparaison d’égalité\n!= différence\n< inférieur strict\n<= inférieur ou égal (s’écrit de la même manière dont on le prononce)\n> supérieur strict\n>= supérieur ou égal (s’écrit de la même manière dont on le prononce)\nAttention, l’opérateur =correspond à l’affectation alors que l’opérateur ==correspond à la comparaison\nd’égalité, c’est-à-dire au signe =utilisé en mathématiques !!\nLes expressions composées doivent être complètement parenthésées :\ndouble a = 8;\nboolean estDansIntervalle = ((a >= 0) && (a <= 10));\n// vaut true ssi a appartient à [0,10]\n1.3 L E PROGRAMME\nDe manière générale, la structure d’un programme simple est toujours la même. Cette structure de base doit\nêtre apprise par cœur, car elle constitue le squelette du programme. Il est conseillé, lors de la création d’un\nprogramme, de commencer par écrire cette structure. En effet, une fois cette structure créée, le programme\nest fonctionnel : il peut être compilé?et exécuté?. Bien entendu à ce stade, le programme ne fait strictement\nrien puisqu’il n’y a aucune instruction, seulement des commentaires.\npublic class Exemple{ //Exemple est le nom du programme\n// écrit dans le fichier Exemple.java\npublic static void main (String[] args){\n//bloc d’instructions du programme\n//exécutées lors du lancement du programme\n}\n}\nDéclare et initialise deux variables celsius et fahrenheit, fahrenheit étant calculée à partir de celsius,\npour ensuite les afﬁcher à l’écran.\npublic class ConversionCelsiusVersFahrenheit{\npublic static void main (String[] args){\ndouble celsius = 12.0;\ndouble fahrenheit = ((9.0/5.0) * celsius) + 32.0;\nSystem.out.print(celsius);\nSystem.out.print(\" degrés Celsius convertit en Fahrenheit vaut \");\nSystem.out.println(fahrenheit);\n}\n}\nL’instruction System.out.print permet d’afﬁcher la valeur d’une variable de type primitif ou un texte\ndélimité par des guillemets.\nProgrammation Java page 5 of 20\n1.4 L ES STRUCTURES DE CONTRÔLE\nLe principe d’un programme est de modiﬁer le contenu des variables à l’aide des instructions élémentaires\nque nous venons de voir (affectation et opérateurs). Or, nous pouvons vouloir que ces instructions ne soient\nréalisées que dans certains cas, ou bien nous pouvons vouloir répéter l’exécution de ces instructions. Ce sont\nles structures de contrôle qui permettent de spéciﬁer si l’exécution d’un traitement est conditionnée ou bien\nsi elle se fait de manière répétée.\n1.4.1 B LOC D ’INSTRUCTIONS\nLes accoladesfgpermettent de délimiter un bloc d’instructions, c’est-à-dire un ensemble d’instructions qui\nvont être exécutées les unes à la suite des autres. Un bloc d’instructions peut, par exemple, être exécuté que\nlorsqu’une condition est vériﬁée ou bien il peut être exécuté plusieurs fois de suite. Ce sont les structures de\ncontrôle conditionnelles et itératives qui permettent d’exprimer cela. Les variables déclarées?dans un bloc\nsont accessibles à l’intérieur de ce bloc uniquement.\nDeux variables de même nom peuvent être déclarées dans deux blocs distincts. Ce sont deux variables\ndifférentes associées à deux emplacements mémoires différents. Ainsi, leurs valeurs sont généralement\ndifférentes. Confondre l’une avec l’autre peut être une source d’erreur de programmation.\n1.4.2 S TRUCTURES CONDITIONNELLES\nLes structures de contrôle conditionnelles permettent de spéciﬁer à quelles conditions un bloc d’instructions\nva être exécuté. Cette condition est exprimée par une expression logique.\nLA STRUCTURE ALTERNATIVE Le premier type de conditionnelle s’écrit comme suit :\nif (condition) {// équivalent à (condition == true)\n// bloc d’instructions exécutées si condition est vraie\n} else {\n// bloc d’instructions exécutées si condition est fausse\n}\nCette structure de contrôle exprime une alternative. Or, il est possible de vouloir qu’un bloc soit exécuté sous\nune certaine condition et que sinon, aucune instruction ne soit exécutée. Dans ce cas, la clause else et son\nbloc sont supprimés. Les parenthèses autour de condition , qui est variable ou une expression à valeur\nbooléenne, sont obligatoires.\nAfﬁche un message si la température est supérieure à 50.\npublic class QuelleUnite{\npublic static void main (String[] args){\nint temperature = 36;\nif(temperature > 50) {\nSystem.out.println(\"La température est probablement en Fahrenheit\");\n}\n}\n}\nLA STRUCTURE CHOIX MULTIPLES Le second type de conditionnelle permet de faire plusieurs tests de valeurs\nsur le contenu d’une même variable. Sa syntaxe est la suivante :\nswitch (variable) {\ncase valeur1 :\nListe d’instructions // exécutées si (variable == valeur1)\nbreak;\ncase valeur2 :\nListe d’instructions // exécutées si (variable == valeur2)\nProgrammation Java page 6 of 20\nbreak;\n...\ncase valeurN :\nListe d’instructions // exécutées si (variable == valeurN)\nbreak;\ndefault:\nListe d’instructions // exécutées sinon\n}\nLe mot clé default précède la liste d’instructions qui sont exécutées lorsque variable a une valeur dif-\nférentes de valeur1,..,valeurN . Le mot clé break indique que la liste d’instructions est terminée.\n1.4.3 S TRUCTURES ITÉRATIVES\nIl existe 3 formes de structure itérative, chacune a un cadre d’utilisation bien spéciﬁque que nous allons voir.\nL’ITÉRATION RÉPÉTÉE nFOIS La première forme itérative est la boucle for. Elle permet de répéter un bloc\nd’instructions un nombre de fois ﬁxé. Dans sa syntaxe, il faut déclarer et initialiser la variable qui sert de\ncompteur de tours de boucle, indiquer la condition sur le compteur pour laquelle la boucle s’arrête et enﬁn\ndonner l’instruction qui incrémente?ou décrémente?le compteur :\nfor (int compteur = 0 ; compteur < n ; compteur = compteur + 1) {\n// bloc instructions répétées n fois\n}\nou\nfor (int compteur = n ; compteur > 0 ; compteur = compteur - 1) {\n// bloc instructions répétées n fois\n}\nAfﬁche la conversion en Fahrenheit des degrés Celsius de 0 à 39.\npublic class ConversionCelsiusVersFahrenheit{\npublic static void main (String[] args){\nfor(int celsius = 0; celsius < 40; celsius = celsius + 1) {\ndouble fahrenheit = ((9.0/5.0) * celsius) + 32.0;\nSystem.out.print(celsius);\nSystem.out.print(\" degres Celsius convertit en Fahrenheit vaut \");\nSystem.out.println(fahrenheit);\n}\n}\n}\nLa boucle fors’utilise lorsque l’on connaît a priori le nombre de répétitions à effectuer.\nL’ITÉRATION RÉPÉTÉE TANT QU ’UNE CONDITION EST VRAIE La seconde forme d’itérative est la boucle while .\nElle exécute le bloc d’instructions tant que la condition est vraie. Le bloc peut ne jamais être exécuté. La\nsyntaxe est la suivante :\nwhile (condition) { // équivalent à (condition == true)\n// bloc d’instructions répétées tant que condition est vraie.\n// condition doit être modifiée dans ce bloc\n}\nCette structure exécute le bloc d’instructions tant que (while en anglais) la condition est réalisée.\nProgrammation Java page 7 of 20\nIl est important de toujours s’assurer que la condition deviendra fausse lors d’une itération de la structure\nitérative. Dans le cas contraire, l’exécution du programme ne s’arrêtera jamais.\nAfﬁche la conversion en Fahrenheit des degrés Celsius tant que la conversion est inférieur à 100.\npublic class ConversionCelsiusVersFahrenheit{\npublic static void main (String[] args){\nint celsius = 0;\ndouble fahrenheit = ((9.0/5.0) * celsius) + 32.0;\nwhile(fahrenheit < 100) {\nSystem.out.print(celsius);\nSystem.out.print(\" degres Celsius convertit en Fahrenheit vaut \");\nSystem.out.println(fahrenheit);\ncelsius = celsius + 1;\nfahrenheit = ((9.0/5.0) * celsius) + 32.0;\n}\n}\n}\nLa boucle while s’utilise lorsque le nombre d’itérations n’est pas connu a priori mais peut s’exprimer au\nmoyen d’une expression à valeur booléenne qui devient fausse lorsque la répétition doit s’arrêter.\nL’ITÉRATION EXÉCUTÉE AU MOINS UNE FOIS La troisième forme d’itérative est la boucle “ do while ”. C’est\nune variante de la boucle while , où la condition d’arrêt est testée après que les instructions ont été exé-\ncutées :\ndo {\n// bloc d’instructions exécutées\n// condition doit être modifiée dans ce bloc\n} while (condition); // si condition est vraie,\n// le bloc est exécuté à nouveau\nNe pas oublier le ; après la condition d’arrêt. Le bloc d’instructions est exécuté au moins une fois.\nAfﬁche la conversion en Fahrenheit des degrés Celsius jusqu’à ce que le degré Fahrenheit soit supérieur\nou égale à 100.\npublic class ConversionCelsiusVersFahrenheit{\npublic static void main (String[] args){\ndouble fahrenheit;\nint celsius = 0;\ndo {\nfahrenheit = ((9.0/5.0) * celsius) + 32.0;\nSystem.out.print(celsius);\nSystem.out.print(\" degres Celsius convertit en Fahrenheit vaut \");\nSystem.out.println(fahrenheit);\ncelsius = celsius + 1;\n} while (fahrenheit < 100);\n}\n}\nProgrammation Java page 8 of 20\n2 L ES MÉTHODES\nUne méthode est un bloc d’instructions pouvant être exécutées par un simple appel?de la méthode dans le bloc\ndu programme principal (méthode main ) ou dans une autre méthode. Les méthodes permettent d’exécuter\ndans plusieurs parties du programme un même bloc d’instructions. On est amené à créer une méthode dans\ndeux cas de ﬁgure :\n\u000fPour regrouper un ensemble d’instructions qui participent à la réalisation d’une même tâche. Cela\npermet de rendre le programme plus lisible et compréhensible par une autre personne (ou vous-même\nlors du TP suivant) et de faciliter la mise au point du programme (correction et tests3). A ce bloc\nd’instructions est associé un nom, choisi en rapport avec le traitement réalisé par la méthode.\n\u000fPour regrouper un ensemble d’instructions qui sont répétées à différents endroits du programme (con-\ntrairement aux formes itératives qui répètent le bloc d’instructions de manière consécutive).\nLe rôle d’une méthode est de traiter des données. Cela signiﬁe qu’en général, la méthode effectue un traite-\nment à partir des données qui entrent, et renvoie un résultat.\n2.1 L ES MÉTHODES PRÉDÉFINIES\nEn Java, il existe de nombreuses méthodes prédéﬁnies. La plus connue est sans doute la méthode suivante\nqui permet d’afﬁcher une chaîne de caractères à l’écran :\nSystem.out.println(\"la chaîne de caractères à afficher\");\nD’autres exemples de méthodes que vous pouvez utiliser sont celles de la librairie Math :sqrt, cos, sin,\nabs, etc. . Lorsqu’on appelle une méthode, on utilise son nom suivi de la liste de ses paramètres effectifs\n(séparés par une virgule) entre parenthèses :\nnomMethode(parametre_1,... , parametre_n);\nSi cette méthode renvoie un résultat, il faut alors affecter ce résultat à une variable de type compatible pour\npouvoir ensuite utiliser ce résultat :\ndouble racine = Math.sqrt(5.2);\n2.2 L ES MÉTHODES PROPRES\nDÉCLARATION D ’UNE MÉTHODE La déﬁnition d’une méthode s’appelle déclaration?. La déclaration d’une\nméthode se fait selon la syntaxe suivante :\nstatic TypeRetour nomMethode(Type1 param1,..., TypeN paramN) {\n//bloc d’instructions\nreturn valeurRetournee;\n}\nLe fait que l’on doive précéder la déclaration d’une méthode par le mot clé static est expliqué page 15.\nTypeRetour est le type de valeurRetournee , la valeur renvoyée par la méthode. Si la méthode ne renvoie\naucune valeur, le mot-clé void est utilisé à la place du type de la valeur retournée.\nPour une raison inconnue des enseignants, il y a souvent confusion entre le fait de retourner une valeur et\nle fait de l’afﬁcher.\nLes paramètres correspondent aux données d’entrée de la méthode. Au niveau de la déclaration, les\nparamètres sont dits “formels” : ce sont des variables qui représentent chaque donnée d’entrée. On peut\nfaire ici l’analogie avec la variable xutilisée en mathématique lorsque l’on déﬁnit une fonction f(x). Les\nparamètres sont facultatifs, mais s’il n’y a pas de paramètres, les parenthèses doivent rester présentes.\n3Commenter la ligne d’appel de la fonction commente tout le bloc d’instructions de la méthode à cet endroit du programme.\nProgrammation Java page 9 of 20\nAPPEL D ’UNE MÉTHODE C’est au moment de l’appel de la méthode que les paramètres formels sont initialisés,\nc’est-à-dire qu’une valeur leur est affectée. Les paramètres “effectifs”?de l’appel, ceux passés en argument de\nla méthode au moment de l’appel, sont affectés aux paramètres formels de la méthode (ceux de la déﬁnition\nde la méthode) par position : la valeur du premier paramètre effectif est affectée au premier paramètre formel,\net ainsi de suite. Les paramètres effectifs peuvent être des valeurs ou des variables.\nstatic int addition(int x, int y) {//x et y sont les paramètres formels\nreturn x + y;\n}\npublic static void main (String[] args) {\nint a = 7;\nint somme = addition(a,3);//a et 3 sont les paramètres effectifs de l’appel\n//x prend la valeur de a et y prend la valeur 3\n}\nEn Java, le passage des paramètres se fait par valeur, c’est-à-dire que la valeur du paramètre effectif est\naffectée au paramètre formel. Ainsi, si la valeur du paramètre formel est modiﬁée dans le bloc de la\nméthode, cette modiﬁcation est locale à la méthode mais n’est pas repercutée dans le contexte appelant.\nRien ne vaut un petit exemple ;-)\nstatic int addition(int entierA, int entierB) {\nentierA = entierA + 1; //entierA est modifié\nreturn entierA + entierB;\n}\npublic static void main (String[] args) {\nint a = 7;\nint b = 3;\nint somme = addition(a,b); // la valeur de a est affectée à entierA\n// a vaut toujours 7 après l’appel de la méthode addition\n}\n2.3 L ES MÉTHODES RÉCURSIVES\nNous avons précédemment précisé qu’il était possible qu’une méthode appelle dans son bloc une autre méth-\node. Il est également possible qu’elle s’appelle elle-même. A priori, l’intérêt peut paraître limité, mais la\nrécursivité permet d’effectuer certains calculs mathématiques, en particulier avec les suites déﬁnies par récur-\nrence. Par exemple, on peut calculer la factorielle d’un nombre entier en utilisant la récursivité. Pour cela,\non peut procéder de la manière suivante, par exemple si l’on souhaite calculer la factorielle de 4 :\n4!=4\u00023!\n3!=3\u00022!\n2!=2\u00021!\n1!=0!\n0!=1\nDans ce calcul, on constate une récurrence : pour calculer 4!, il sufﬁt de calculer 3!, puis 2!, et ainsi de\nsuite, jusqu’à un cas directement résolu (sans expression récursive, le cas de base). Nous pouvons alors\ncréer une méthode calculeFactorielle ayant comme paramètre un entier n, et renvoyant l’entier n!.\nOn voit qu’il sufﬁt que la fonction s’appelle elle-même suivant ce même principe pour calculer facilement la\nfactorielle de n’importe quel nombre entier. Cependant, arrivé au calcul de 0!, il est nécessaire que la fonction\nrenvoie directement la valeur 1, sans faire d’appel récursif. En d’autres mots, il ne faut pas que l’appel de\ncalculeFactorielle(0) provoque l’appel de calculeFactorielle(-1) . Il renvoie directement 1, aﬁn\nde ne pas provoquer une inﬁnité d’appels :\nProgrammation Java page 10 of 20\npublic class Factorielle {\nstatic int calculeFactorielle(int n) {\nif(n > 0) { // cas général\nreturn n * calculeFactorielle (n-1);\n}\nelse { //cas de base ou d’arrêt\nreturn 1;\n}\n}\npublic static void main (String[] args) {\nint valeur = 4;\nSystem.out.println(calculeFactorielle(valeur)); // 5 appels en tout\n}\n}\n2.4 U N EXEMPLE\nL’exemple suivant présente un programme avec deux méthodes : CelsiusVersFahrenheit convertit valeurAConvertir ,\nune valeur réelle représentant une température en degré Celsius, en une température en degré Fahrenheit. La\nvaleur en Fahrenheit est retournée par la méthode. CelsiusVersKelvin convertit valeurAConvertir ,\nune valeur réelle représentant une température en degré Celsius, en une température en degré Kelvin. La\ntempérature en Kelvin est afﬁchée et aucune valeur n’est retournée par la méthode.\nObservez la différence entre les appels des deux méthodes dans le main : la valeur retournée par CelsiusVersFahrenheit\nest affectée à la variable temperature , puis elle est afﬁchée. La méthode CelsiusVersKelvin est directe-\nment appelée, sans affectation de sa valeur de retour, puisque celle-ci n’en n’a pas (mot clé void dans la\ndéclaration).\nLe programme considère les températures entières, en degré Celsius, de 0 à 39 inclus. Une fois sur deux,\nsa conversion en degré Fahrenheit est afﬁchée, l’autre fois c’est sa conversion en degré Kelvin qui est afﬁchée.\nNotez le changement de valeur de la variable calculeFahrenheit à chaque tour de boucle.\npublic class Conversion {\nstatic double CelsiusVersFahrenheit(double valeurAConvertir) {\ndouble Fahrenheit = ((9.0/5.0) * valeurAConvertir) + 32.0;\nreturn Fahrenheit;\n}\nstatic void CelsiusVersKelvin(double valeurAConvertir) {\ndouble Kelvin = 273.15 + valeurAConvertir;\nSystem.out.println(Kelvin);\n}\npublic static void main (String[] args) {\nboolean calculeFahrenheit = true;\nfor(int celsius = 0; celsius < 40; celsius = celsius + 1) {\nif(calculeFahrenheit == true) {\ndouble temperature = CelsiusVersFahrenheit(celsius);\nSystem.out.println(temperature);\n} else {\nCelsiusVersKelvin(celsius);\n}\ncalculeFahrenheit = !calculeFahrenheit;\n}\n}\n}\nProgrammation Java page 11 of 20\n3 L ES TYPES NON PRIMITIFS\n3.1 G ÉNÉRALITÉS\nNous avons vu (section 1.2) qu’une variable permet de stocker dans un emplacement mémoire une donnée\nd’un certain type, et que cette donnée peut être transformée en utilisant des opérateurs spéciﬁques de son\ntype. Or, au lieu de manipuler une seule valeur, il est parfois beaucoup plus commode qu’une variable soit\nassociée à une collection de valeurs. C’est ce que permettent les types non primitifs, appelés objet en Java.\nSupposons que l’on souhaite réaliser un programme permettant d’écrire des courriers de manière automa-\ntique aux abonnés d’une bibliothèque. Pour chaque abonné, nous connaissons son nom, prénom, le nombre\nde volumes empruntés ainsi que le nombre de jours écoulés depuis l’emprunt. Nous devons alors manip-\nuler des centaines d’abonnés, chacun décrit par 4 valeurs, certaines de ces valeurs (nom, prénom) étant\négalement une collection de valeurs primitives (une séquence de caractères). Ce type de traitement est\nimpossible en n’utilisant que des types primitifs.\nTout comme des opérateurs spéciﬁques sont associés à chaque type primitif?, il peut être commode de déﬁnir\ndes opérateurs ou méthodes permettant d’interroger ou transformer les valeurs de ces objets.\nNous souhaitons disposer d’une méthode estEnRetard qui renvoie la liste des abonnés dont le dernier\nemprunt a été effectué il y a plus de 21 jours.\nDans cette section nous allons introduire les concepts relatifs aux objets nécessaires à la création d’un tel\nprogramme. Avant toute chose, nous allons expliquer les mécanismes communs à tout objet Java, c’est-à-\ndire, la façon dont un objet est stocké en mémoire et la manière dont on l’instancie?, c’est-à-dire la façon dont\non réserve l’emplacement mémoire nécessaire à l’objet. Nous verrons également comment fonctionnent les\nopérateurs de comparaison sur les objets.\nSTOCKAGE DES OBJETS EN MÉMOIRE Tout comme les variables de type primitif, une variable de type objet\nest associé à un emplacement mémoire de taille ﬁxe qui contient une unique valeur. Dans cet emplacement\nmémoire est stocké une valeur de type adresse qui indique l’adresse?de l’emplacement mémoire où sont\nstockées, de manière contiguë, toutes les valeurs de l’objet. Ainsi, la variable est liée aux données de manière\nindirecte : elle contient l’adresse à laquelle on peut trouver les données. La variable qui est manipulée est en\nfait une référence?à l’emplacement mémoire où se trouve l’ensemble des données.\nadresse 0001\n        ...\nadresse 0012\nadresse 0013\nadresse 0014\nadresse 0015\n        ... 0012maVariable\nvaleur1\nvaleur2\nvaleur3\nINSTANCIATION?DES OBJETS L’instanciation d’un objet se fait à l’aide du mot clé newqui “réserve” l’emplace-\nment mémoire nécessaire pour stocker toutes les valeurs de l’objet, c’est-à-dire un ensemble de cases mémoire\ncontiguës, et renvoie l’adresse de la première case mémoire.\n//déclaration et instanciation\nTypeObjet maVariable = new TypeObjet;\nCOMPARAISON DE DEUX OBJETS Lorsque l’on compare deux objets, à l’aide des opérateurs ==,<=,>=,<\nou<, ce sont les adresses des objets qui sont comparées. Ainsi, l’opérateur ==renvoie la valeur true si les\ndeux variables font référence au même emplacement mémoire, donc au même objet.\nProgrammation Java page 12 of 20\nif(variableA == variableB){\nSystem.out.println(\"Les deux variables font référence au même objet.\");\n}\n3.2 L ES TABLEAUX\nLes tableaux permettent de regrouper un ensemble de valeurs de même type.\n3.2.1 T ABLEAUX À 1DIMENSION\nUn tableau à 1 dimension est une collection linéaire d’éléments de même type. Chaque case d’un tableau est\nidentiﬁée par un indice et contient une valeur. Les indices d’un tableau commencent à 0. Il s’ensuit, qu’un\ntableau de néléments aura des indices compris entre 0 et n\u00001.\nLe type contenu dans les cases du tableau est choisi lors de la déclaration du tableau. En revanche, la taille\ndu tableau, ne fait pas parti de son type et sera déﬁnie lors de l’instanciation du tableau. La déclaration d’un\ntableau se fait avec la syntaxe [].\nint[] tabInt ; // Déclaration d’un tableau d’entiers\nchar[] tabChar ; // Déclaration d’un tableau de caractères\nL’instanciation quant à elle précise la taille à réserver. Elle se fait avec le mot clé new.\nint[] tabInt ; // Déclaration d’un tableau d’entiers\ntabInt = new int[10]; // Instanciation d’un tableau de 10 entiers\nA noter qu’il est possible, dans le cas de l’initialisation uniquement, de décrire tout le tableau sous la forme\nd’une liste de valeurs. Cela initialise automatiquement le tableau avec le nombre adéquate de cellules et les\nvaleurs sont stockées dans les différentes cases.\nint[] tabCinq = {12,33,44,0,50}; //Initialisation expresse\nUne fois le tableau initialisé, on accède aux éléments du tableau à l’aide de la syntaxe suivante :\nint i = 0;\nint valeur1 = tabCinq[i]; //Renvoie 12, l’élément d’indice 0\nint valeur2 = tabCinq[4]; //Renvoie 50, l’élément d’indice 4\nUne fois initialisé, il est possible à tout moment de connaître la taille d’un tableau (son nombre de cases) à\nl’aide de la syntaxe suivante :\nint taille = tabCinq.length; //Renvoie 5, le nombre de cases du tableau tabCinq\n3.2.2 T ABLEAUX À N DIMENSIONS\nUn tableau à 2 dimensions est un cas particulier de tableaux à 1 dimension. En effet, c’est simplement un\ntableau dont chaque case contient un tableau à 1 dimension d’éléments. Par récurrence, il est donc possible\nde déﬁnir un tableau à ndimensions. Du point de vue de la notation, chaque dimension correspond à un\ncouple de crochets supplémentaires au niveau du type et des accès.\nchar[][] T ; // Déclaration d’un tableau à 2 dimensions de caractères\nT = new char[3][5]; // Instanciation d’un tableau contenant 3 tableaux de\n// 5 caractères chacun. T a donc 3 lignes et 5 colonnes.\nProgrammation Java page 13 of 20\nLes multiples crochets sont lus de gauche à droite, ce qui correspond à regarder les tableaux depuis le plus\nextérieur vers plus plus intérieur. Ainsi, T .length renvoie 3, la taille du tableau extérieur, T [0].length renvoie\n5 la taille du tableau contenu dans la première case de T . C’est la même convension qu’en mathématiques\npour les matrices, d’abord les lignes, puis les colonnes. Pour ﬁnir, comme chaque dimension est un tableau,\nil s’ensuit que chaque dimension est indicée de 0 à n\u00001.\n45 154 58 78 31\n12 15 45 37 789\n457 21 78 89 365\n87 154 58 78 42\n5841 4 45 6 47\nint[][] T = new int[5][5];\nint i = T[0][1];//i vaut 154\nint[] T1 = T[1];//T1 fait référence\n//au tableau [12,15,45,37,789]\nUne matrice Sa représentation informatiqueaLe code Java\naImage provenant de http: //fr.wikipedia.org /wiki/Tableau_(structure_de_données)\n3.3 M ÉTHODES À PARAMÈTRES DE TYPE NON -PRIMITIF\nEn Java, le passage des paramètres à une méthode se fait par valeur. Dans le cas des types non-primitifs, cette\nvaleur est une adresse. Ainsi, une méthode ne pourra pas modiﬁer l’adresse de la variable, en revanche elle\npourra modiﬁer les valeurs stockées à cette adresse.\n3.3.1 I NSTANCIATION DES VARIABLES DE TYPE NON -PRIMITIF DANS UNE MÉTHODE\nL’instanciation d’un objet à l’aide du mot clé newréserve l’emplacement mémoire nécessaire au stockage des\nvaleurs de l’objet et renvoie l’adresse. Ainsi, si cette instruction est effectuée dans une méthode, il faudra\npenser à renvoyer cette adresse pour pouvoir manipuler l’objet en dehors de la méthode.\nPrenons l’exemple suivant où l’on souhaite dupliquer un tableau pour pourvoir le modiﬁer tout en con-\nservant l’original :\nstatic int[] copierTableau(int[] tableau) {\nint[] copie = new int[tableau.length];\nfor(int i = 0; i < tableau.length; i = i + 1) {\ncopie[i] = tableau[i];\n}\nreturn copie;\n}\n3.3.2 M ODIFICATION DES VALEURS D ’UNE VARIABLE DE TYPE NON -PRIMITIF DANS UNE MÉTHODE\nLorsqu’on passe un objet en paramètre d’une méthode, c’est l’adresse de celui-ci qui est affectée au paramètre\nformel de la méthode. Si la méthode modiﬁe cette valeur (l’adresse), celle-ci ne sera pas modiﬁée en de-\nhors (le contexte appelant) de la méthode. En revanche, lorsqu’on modiﬁe les valeurs de l’objet, on change\ndirectement les valeurs dans les cases mémoires de l’objet et ce changement est alors déﬁnitif.\nPrenons l’exemple suivant où l’on permute les valeurs des indices ietjdu tableau :\nstatic void permute(int[] tab, int i, int j) {\nint temp = tab[i];\ntab[i] = tab[j];\ntab[j] = temp;\n}\nint[] unTableau = {1,2,3,4,5};\npermute(unTableau,0,4);\n//unTableau contient les valeurs [5,2,3,4,1]\nProgrammation Java page 14 of 20\n3.4 L ES OBJETS\nLes différentes valeurs d’un objet son appelées attributs?. Pour accéder à la valeur d’un attribut, on utilise la\nsyntaxe suivante :\n//accès à la valeur de l’attribut\nTypeAttribut monAttribut = monObjet.nomAttribut;\n//affectation d’une valeur à l’attribut\nmonObjet.nomAttribut = valeurAttribut;\nIl peut exister des méthodes spéciﬁques permettant d’interroger ou de transformer les valeurs des attributs\nd’un objet. Pour appeler?une méthode sur un objet, on utilise la syntaxe suivante :\nTypeRetour valeurRetour = monObjet.nomMethode(parametre_1,.., parametre_N);\nLa méthode nomMethode permet d’accéder ou de modiﬁer les valeurs des attributs de monObjet .\nSi une méthode n’accède pas ou ne modiﬁe pas les attributs de l’objet, on dit que cette méthode est static .\nLa déclaration de la méthode est précédée du mot clé static . L’appel de la méthode se fait comme expliqué\ndans la section 2.\n3.4.1 L’ OBJET PRÉDÉFINI STRING\nIl existe de nombreux objets prédéﬁnis en Java. Nous allons dans cette section présenter l’un d’entre eux,\nincontournable : le type “chaîne de caractères”, appelé String . Cet objet est le seul qui sera réellement\nmanipulé en première année.\nUne chaîne de caractères représente un texte. C’est une collection linéaire de caractères qu’il n’est pas\npossible de modiﬁer une fois que l’objet a été instancié et initialisé. Ces opérations se font selon la syn-\ntaxe :\n//Déclaration, instanciation et initialisation\nString ecole = new String(\"INSA-Lyon\");\nNoter la présence de guillemets doubles pour distinguer les chaînes de caractères des éléments du langage\nde programmation Java (mots du langage, nom de variables, nom de méthodes).\nComme le type String est très utilisé, une particularité de ce type est que l’on accède à l’attribut principal\nde l’objet, la chaîne de caractères, comme si c’était un type primitif :\nSystem.out.println(ecole); // affiche \"INSA-Lyon\"\nLes objets de type String sont fournis avec un grand nombre de méthodes permettant une manipulation\nfacile de ces objets. Les quatre principales méthodes permettent d’accéder à chaque caractère de la chaîne,\nde connaître le nombre de caractères de la chaîne (sa longueur), d’extraire une partie de la chaîne et de\ncomparer le contenu de deux chaînes :\n\u000fchar charAt(int n) : cette méthode prend en paramètre un entier net renvoie le n+1 ème carac-\ntère de la chaîne (le premier caractère est à l’indice 0 et le n+1 ème à l’indice n).\nString ecole = new String(\"INSA-Lyon\");\nchar c = ecole.charAt(2); //c contient le caractère ’S’\n\u000fint length() : cette méthode renvoie la longueur de la chaîne de caractères.\nProgrammation Java page 15 of 20\nString ecole = new String(\"INSA-Lyon\");\nint longueur = ecole.length(); // longueur contient 9\nNotez les parenthèses de la méthode length , parenthèses absentes lorsque l’on appelle cette méth-\node sur un tableau.\n\u000fString substring(int debut, int fin) : cette méthode renvoie un objet de type String qui\ncontient la sous-chaîne de caractères commençant à l’indice debut et se terminant à l’indice fin-1 .\nString ecole = new String(\"INSA-Lyon\");\nString ville = ecole.substring(5, ecole.length());\n//équivaut à ecole.substring(5, 9), ville contient \"Lyon\"\n\u000fequals(String s) : cette méthode renvoie une variable de type booléen qui vaut vrai si et seulement\nsi la chaîne de caractères sest la même que la chaîne de caractères de l’objet sur lequel on appelle la\nméthode :\nString ecoleA = new String(\"INSA-Lyon\");\nString ecoleB = new String(\"INSA-Lyon\");\nif(ecoleA.equals(ecoleB) == true){\n//cette condition est satisfaite\nif(ecoleA == ecoleB){\n//cette condition n’est pas satisfaite,\n//les deux objets n’ayant pas la même adresse\n}\n}\nUne opération fréquente consiste à “coller” bout-à-bout deux chaînes de caractères. On appelle cela la\nconcaténation. L’opérateur associé est +:\nString ville = new String(\"Lyon\");\nString ecole = new String(\"INSA\");\nString monEcole = ecole + \"-\" + ville; // monEcole contient \"INSA-Lyon\"\nIl peut être nécessaire de pouvoir convertir un type primitif en une chaîne de caractères ou réciproquement.\nLa conversion d’un type primitif en une chaîne de caractères se fait à l’aide de l’instruction\nString.valueOf(valeurPrimitive);\nint valeur = 22;\nString chaine = String.valueOf(valeur); // chaine contient \"22\"\nLa conversion d’une chaîne de caractères en un type primitif se fait à l’aide des instructions suivante :\nInteger.parseInt(chaine); // renvoie une valeur de type int\nDouble.parseDouble(chaine); // renvoie une valeur de type double\nBoolean.parseBoolean(chaine);// renvoie une valeur de type boolean\nchaine.charAt(i); // renvoie une valeur de type char\nProgrammation Java page 16 of 20\nString chaine = \"22\" ;\nint valeur = Integer.parseInt(chaine); //valeur vaut 22\n3.4.2 L ES OBJETS PROPRES\nCette section couvre une partie du programme de deuxième année.\nOn peut également déﬁnir ses propres objets. C’est ce que nous allons apprendre à faire ici, en illustrant\nnotre propos sur l’exemple du début de section.\nLES CLASSES Les classes permettent de déﬁnir des types ou des catégories d’objets (on pourra prendre la\nmétaphore du moule des objets). Elles contiennent la description des objets, (ex : les abonnés), c’est-à-dire\nqu’elles déﬁnissent les attributs et les méthodes communes aux objets d’un certain type.\nLes objets construits à partir de ces classes sont des instances . Les instances sont des éléments créés depuis\nune classe : un abonné particulier. La syntaxe de déclaration d’une classe est :\nclass NomType {\n// le corps de la classe vient ici\n// les attributs\n// les méthodes\n}\nOn commence généralement par déclarer les attributs de la classe :\nclass Abonne {\n//les attributs de la classe Abonne\nString nom;\nString prenom;\nint nbLivres;\nint nbJours;\n}\nLE CONSTRUCTEUR Toute classe doit contenir au moins une méthode particulière appelé constructeur . Cette\nméthode porte le même nom que la classe et est appelée lorsque l’on instancie un nouvel objet. C’est\ncette fonction qui généralement initialise les valeurs des attributs. Cette méthode ne renvoie aucune valeur.\nclass Abonne {\n//les attributs de la classe Abonne\nString nom;\nString prenom;\nint nbLivres;\nint nbJours;\nAbonne() { // premier constructeur\nnom = new String(\"\");\nprenom = new String(\"\");\nnbLivres = 0;\nnbJours = 0;\nage = 0;\n}\nAbonne(String nom, String prenom, int nbLivres, int nbJours) {\n// deuxième constructeur\nProgrammation Java page 17 of 20\nthis.nom = new String(nom);\nthis.prenom = new String(prenom);\nthis.nbLivres = nbLivres;\nthis.nbJours = nbJours;\n}\n}\nIl peut exister plusieurs constructeurs qui se distinguent par leurs paramètres formels. Ainsi, en fonction\ndes paramètres effectifs (nombre de paramètres ou types des paramètres) passés au constructeur au mo-\nment de l’appel, l’un ou l’autre des constructeurs sera appelé. Par exemple, l’instruction Abonne() dé-\nclenchera l’exécution du premier constructeur, alors que l’instruction Abonne(\"Dupond\", \"Luc\",4,0) dé-\nclenchera l’exécution du second constructeur qui instancie les attributs aux valeurs correspondant à l’abonné\nLuc Dupond.\nLe mot clé this permet de spéciﬁer que l’attribut que l’on référence est celui de l’objet en cours de con-\nstruction. En effet, l’expression this.nom = nom; signiﬁe que l’attribut nom de l’objet en cours de con-\nstruction (this.nom) prend la valeur du paramètre formel nom de type String du constructeur.\nEXEMPLE Regardons maintenant comment on peut construire notre programme qui indique les abonnés qui\nont emprunté un livre depuis plus de 21 jours. Nous venons de voir la classe Abonne qui contient les attributs\nd’un abonné. Ajoutons une méthode renseigneUnAbonne qui permet de spéciﬁer les nouvelles valeurs des\nattributs :\nvoid renseigneUnAbonne(String nom, String prenom, int nbLivres, int nbJours) {\nthis.nom = new String(nom);\nthis.prenom = new String(prenom);\nthis.nbLivres = nbLivres;\nthis.nbJours = nbJours;\n}\nLa classe EnsembleDesAbonnes va contenir l’ensemble des abonnés de la bibliothèque. Ses attributs sont\nalors un tableau d’abonnés ( lesAbonnes ) et un entier qui indique le nombre d’abonnés. Son construc-\nteur alloue l’emplacement mémoire nécessaire au tableau lesAbonnes et instancie chacun des abonnés :\nclass EnsembleDesAbonnes {\n//Attributs de la classe EnsembleDesAbonnes\nAbonne[] lesAbonnes;\nint nbAbonnes;\n//Constructeur\nEnsembleDesAbonnes(int nbAbonnes) {\nlesAbonnes = new Abonne[nbAbonnes];\nthis.nbAbonnes = nbAbonnes;\nint i;\nfor(i = 0; i < this.nbAbonnes; i++) {\nlesAbonnes[i] = new Abonne(); // instancie chaque abonné\n}\n}\nLes attributs de la classe doivent être initialisés dans le constructeur, et en particulier, les attributs de type\nnon-primitifs doivent être instanciés via le mot clé newqui réserve l’emplacement mémoire de cet attribut.\nEnﬁn, la méthode estEnRetard , qui renvoie la liste des abonnés dont le dernier emprunt a été effectué il\ny a plus de 21 jours, compte le nombre d’abonnés en retard, puis crée un nouvel objet EnsembleDesAbonnes\nProgrammation Java page 18 of 20\npouvant contenir tous les abonnés en retard, puis recopie l’adresse des abonnés en retard dans l’objet resultat :\nEnsembleDesAbonnes estEnRetard() {\nint i;\nint nbEnRetard = 0;\nfor(i = 0; i < lesAbonnes.length; i++) {\nif( (lesAbonnes[i].nbJoursEmprunts > 21)\n&&(lesAbonnes[i].nbLivresEmpruntes > 0)) {\nnbEnRetard = nbEnRetard + 1;\n}\n}\nEnsembleDesAbonnes resultat = new Abonnes(nbEnRetard);\nint j = 0;\nfor(i = 0; i < lesAbonnes.length; i++) {\nif( (lesAbonnes[i].nbJoursEmprunts > 21)\n&&(lesAbonnes[i].nbLivresEmpruntes > 0)) {\nresultat.lesAbonnes[j] = this.lesAbonnes[i];\nj = j + 1;\n}\n}\nreturn resultat;\n}\nLe tableau lesAbonnes de l’objet resultat contient des références vers les abonnés du tableau lesAbonnes\nde l’objet en cours de déﬁnition.\nEnﬁn, la méthode main de la classe EnsembleDesAbonnes instancie un objet mesAbonnes comportant 4\nabonnés, et appel la méthode estEnRetard sur cet objet qui renvoie un nouvel objet abonnésEnRetard\nqui contient un tableau de références vers les abonnés en retard :\npublic static void main (String[] args) {\nEnsembleDesAbonnes mesAbonnes = new EnsembleDesAbonnes(4);\nmesAbonnes.lesAbonnes[0].renseigneUnAbonne(\"Dupond\", \"Luc\",4,0);\nmesAbonnes.lesAbonnes[1].renseigneUnAbonne(\"Martin\", \"Jeanne\",1,30);\nmesAbonnes.lesAbonnes[2].renseigneUnAbonne(\"Vaus\", \"Paul\",2,22);\nmesAbonnes.lesAbonnes[3].renseigneUnAbonne(\"Bon\", \"Jean\",0,27);\nEnsembleDesAbonnes abonnesEnRetard = mesAbonnes.estEnRetard();\n// abonnesEnRetard contient les références à Jeanne Martin et Paul Vaus\n}\n4 G LOSSAIRE\nADRESSE :Indique la localisation d’une information dans la mémoire.\nAFFECTATION :L’affectation est l’opération qui attribue une valeur à une variable. En Java cet opérateur est\n’=’. Il se lit “prend la valeur de” .\nAPPEL DE MÉTHODES :L’appel d’une méthode exécute le bloc d’instructions de la méthode. L’appel se fait en\nécrivant le nom de la méthode (en respectant la casse) suivie d’une paire de parenthèses avec éventuellement\nune liste de paramètres effectifs?séparés par une virgule. Au moment de l’exécution de l’appel, les valeurs\ndes paramètres effectifs sont affectées aux paramètres formels?, selon l’ordre dans lequel ils apparaissent. Si\nle type renvoyé par la méthode est différent de void , l’appel de la méthode doit être affecté à une variable\nProgrammation Java page 19 of 20\nde même type.\nATTRIBUT :Les attributs sont des variables associées à un objet.\nCONSOLE :La console est une interface textuelle qui permet de demander à l’ordinateur d’exécuter des pro-\ngrammes. Elle est souvent considérée à tord comme étant obsolète. Pour autant il s’agit d’une des interfaces\nles plus puissantes à utiliser puisque l’on peut directement programmer dans la console. De plus, il s’agit bien\nsouvent de l’unique façon d’accéder à des machines à distance.\nCOMPILATION :La compilation permet de transformer un code source écrit dans un langage de program-\nmation en langage machine (ou langage binaire) exécutable par l’ordinateur.\nDÉCLARATION :Avant de pouvoir utiliser une variable ou une méthode, il faut la déclarer. La déclaration\nd’une variable associe un type à un nom et réserve un emplacement mémoire dans lequel est stockée la valeur\nde la variable, si son type est primitif, ou l’adresse du début de la plage mémoire où est stocké la variable\nsi son type est non primitif. La déﬁnition d’une méthode s’appelle également déclaration. Elle consiste à\ndéﬁnir le nom de la méthode, le type de la valeur retournée, la liste de ses paramètres formels et son bloc\nd’instructions.\nDÉCRÉMENTER :L’opération de décrémentation s’applique à une variable de type entier. Elle consiste à\nretirer une valeur entière à la variable, classiquement la valeur 1 ( x = x - 1 ).\nEXÉCUTION :L’exécution est le processus par lequel une machine met œuvre les instructions d’un programme\ninformatique.\nINCRÉMENTER :L’incrémentation est l’opération qui consiste à ajouter une valeur entière ﬁxée à une variable\nde type entier. La valeur ajoutée est le plus souvent la valeur 1 ( x = x + 1 ).\nINITIALISATION :Lorsqu’on déclare une variable, un emplacement mémoire est associé à la variable. Or,\ncelui-ci contient une valeur quelconque. Il est nécessaire d’initialiser la valeur de la variable, c’est-à-dire\nde réaliser une première affectation d’une valeur à la variable, aﬁn que cette dernière contienne une valeur\nappropriée.\nINSTANCE DE CLASSE :On appelle instance d’une classe, un objet avec un comportement (méthodes) et un\nétat (attributs), tous deux déﬁnis par la classe. Il s’agit donc d’un objet constituant un exemplaire de la classe.\nINSTANCIER :Réserver l’espace mémoire nécessaire pour stocker toutes les valeurs de l’objet. De manière\nplus générale, fabriquer un exemplaire d’un élément à partir d’un modèle qui lui sert en quelque sorte de\nmoule.\nOPÉRATEUR :Un opérateur est une fonction spéciale dont l’identiﬁcateur s’écrit avec des caractères non\nautorisés pour les identiﬁcateurs ordinaires (les variables). Il s’agit souvent des équivalents aux opérateurs\nmathématiques pour la programmation informatique.\nPARAMÈTRES EFFECTIFS :Il s’agit de valeurs fournies à une méthode lors de son appel. Ces valeurs peuvent\nêtre des constantes ou des variables.\nPARAMÈTRES FORMELS :On parle aussi de paramètre muet. Il s’agit de variables utilisées dans le bloc\nd’instructions d’une méthode. Ces paramètres permettent de décrire comment les données en entrée de la\nméthode sont transformées par celle-ci.\nRÉFÉRENCE :Une référence est une valeur qui permet l’accès en lecture et /ou écriture à une donnée en\nmémoire. Une référence n’est pas la donnée elle-même mais seulement une information de localisation,\nl’adresse de la valeur dans la mémoire.\nTYPES PRIMITIFS :Les types primitifs (entier, ﬂottant, booléen et caractère) permettent de manipuler di-\nrectement les données les plus courantes et ont la particularité d’être accessibles directement en mémoire.\nTYPES NON PRIMITIFS :Les types non primitifs permettent d’associer plusieurs valeurs à une variable.\nL’emplacement mémoire associé à la variable permet de stocker l’adresse de l’emplacement mémoire où se\ntrouvent ses valeurs. La variable est ainsi liée à ses valeurs de manière indirecte.\nProgrammation Java page 20 of 20",
  "file_type": "document",
  "original_path": "data/uploads\\module_poly2013.pdf"
}