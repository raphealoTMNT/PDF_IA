{
  "filename": "module_livretJava.pdf",
  "extraction_date": "2025-09-02T01:23:56.697709",
  "statistics": {
    "word_count": 16950,
    "character_count": 106468,
    "line_count": 2134
  },
  "top_keywords": [
    [
      "classe",
      261
    ],
    [
      "java",
      137
    ],
    [
      "dans",
      122
    ],
    [
      "public",
      111
    ],
    [
      "classes",
      106
    ],
    [
      "méthode",
      98
    ],
    [
      "pour",
      97
    ],
    [
      "exemple",
      76
    ],
    [
      "objet",
      74
    ],
    [
      "string",
      68
    ]
  ],
  "extracted_data": {
    "emails": [
      "laurent.vercouter@insa-rouen.fr",
      "gauthier.picard@emse.fr"
    ],
    "urls": [
      "http://java.developpez.com/cours/",
      "http://java.sun.com/developer/onlineTraining/",
      "http://docs.oracle.com/javase/tutorial/",
      "http://www.emse.fr/",
      "http://www.javafr.com/",
      "http://www.javaworld.com",
      "http://www.javamug.org/mainpages/Java.html",
      "http://docs.oracle.com/javase/7/docs/api/",
      "http://www.oracle.com/technetwork/java/index.html"
    ],
    "dates": []
  },
  "content_preview": "Initiation à la programmation orientée-objet\navec le langage Java\nPôle Informatique -\n cours Fauriel\n Saint-Étienne Cedex \nGauthier Picard\ngauthier.picard@emse.fr\nInstitut Henri Fayol, ENSM.SE\nLaurent Vercouter\nlaurent.vercouter@insa-rouen.fr\nLITIS, INSA Rouen\n\nTable des matières\n Introduction au langage Java \n. Environnement Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Compilation . . . . . . . . . . . . . . . . . . . . . . . . . ....",
  "full_content": "Initiation à la programmation orientée-objet\navec le langage Java\nPôle Informatique -\n cours Fauriel\n Saint-Étienne Cedex \nGauthier Picard\ngauthier.picard@emse.fr\nInstitut Henri Fayol, ENSM.SE\nLaurent Vercouter\nlaurent.vercouter@insa-rouen.fr\nLITIS, INSA Rouen\n\nTable des matières\n Introduction au langage Java \n. Environnement Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Interprétation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Programmation orientée-objet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Classe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Objet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n Syntaxe du langage \n. Types de données . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Types primitifs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Tableaux et matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Chaînes de caractères . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Opérateurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Structures de contrôle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Instructions conditionnelles . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Instructions itératives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Instructions breaketcontinue . . . . . . . . . . . . . . . . . . . . . . . . . \n Éléments de programmation Java \n. Premiers pas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Classe HelloWorld . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Variables et méthodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Visibilité des champs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Variables et méthodes de classe . . . . . . . . . . . . . . . . . . . . . . . . . \n Héritage \n. Principe de l’héritage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Redéﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Polymorphisme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Classes abstraites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Classes et méthodes génériques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n Gestion des exceptions \n. Déclaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Interception et traitement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Classes d’exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Classiﬁcation des erreurs en Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \niii\nTable des matières\n Gestion des entrées/sorties simples \n. Flux d’entrée . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Lecture des entrées clavier . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Lecture à partir d’un ﬁchier . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Lecture d’objets enregistrés . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n. Flux de sortie . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Ecriture sur la sortie standard “écran” . . . . . . . . . . . . . . . . . . . . . \n.. Ecriture dans un ﬁchier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \n.. Ecriture d’objets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA Applications graphiques (package swing ) \nA. Le schéma Modèle-Vue-Contrôleur . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA. Composants graphiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA.. Composants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA.. Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA.. Exemple d’interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA. Contrôleurs d’événements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA.. Evénements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA.. Interface Listener . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nA.. Exemple de contrôleur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB Diagramme de classes UML \nB. Représentation des classes et interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Les classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Les membres de classe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Les classes abstraites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Les interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB. Les relations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. L’héritage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. La réalisation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB. Les associations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Direction des associations . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Agrégation et composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB. Correspondance UML-Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Classes et membres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Classes abstraites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Héritage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Réalisation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \nB.. Associations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \niv\nTable des matières\nLa plupart des programmes donnés en exemple dans ce cours sont téléchargeables à l’URL :\nhttp://www.emse.fr/~picard/cours/1A/java\nv\nTable des matières\nvi\nChapitre 1\nIntroduction au langage Java\nLe langage Java est un langage généraliste de programmation synthétisant les principaux lan-\ngages existants lors de sa création en  par Sun Microsystems . Il permet une programmation\norientée-objet (à l’instar de SmallTalk et, dans une moindre mesure, C++), modulaire (langage\nADA) et reprend une syntaxe très proche de celle du langage C.\nOutre son orientation objet, le langage Java a l’avantage d’être modulaire (on peut écrire des\nportions de code génériques, c-à-d utilisables par plusieurs applications), rigoureux (la plupart\ndeserreursseproduisentàlacompilationetnonàl’exécution)et portable (unmêmeprogramme\ncompilépeuts’exécutersurdiﬀérentsenvironnements).Encontre-partie,lesapplicationsJavaont\nle défaut d’être plus lentes à l’exécution que des applications programmées en C par exemple.\n1.1 Environnement Java\nJava est un langage interprété, ce qui signiﬁe qu’un programme compilé n’est pas directement\nexécutableparlesystèmed’exploitationmaisildoitêtreinterprétéparunautreprogramme,qu’on\nappelle interpréteur. La ﬁgure .illustre ce fonctionnement.\nF . – Interprétation du langage\nUn programmeur Java écrit son code source, sous la forme de classes, dans des ﬁchiers dont\nl’extension est .java. Ce code source est alors compilé par le compilateur javacen un langage\nappelé bytecode et enregistre le résultat dans un ﬁchier dont l’extension est .class . Le bytecode\n1\nChapitre 1. Introduction au langage Java\nainsi obtenu n’est pas directement utilisable. Il doit être interprété par la machine virtuelle de Java\nqui transforme alors le code compilé en code machine compréhensible par le système d’exploita-\ntion. C’est la raison pour laquelle Java est un langage portable : le bytecode reste le même quelque\nsoit l’environnement d’exécution.\nEn , Sun Microsystems est racheté par Oracle Corporation qui fournit dorénavant les\noutilsdedéveloppementJavaSE( Standard Edition )contenusdansle Java Development Kit (JDK).\nAu moment où est écrit ce livret, la dernière version stable est le JDK ..\n1.1.1 Compilation\nLa compilation s’eﬀectue par la commande javacsuivie d’un ou plusieurs nom de ﬁchiers\ncontenant le code source de classes Java. Par exemple, javac MyProg.java compile la classe My-\nProgdontlecodesourceestsituédansleﬁchier MyProg.java .Lacompilationnécessitesouventla\nprécisiondecertainsparamètrespours’eﬀectuercorrectement,notammentlorsquelecodesource\nfaitréférenceà certainesclassessituées dansd’autresrépertoires queceluidu codecompilé.Il faut\nalors ajouter l’option -classpath suivie des répertoires (séparés par un; sous Windows et : sous\nUnix) des classes référencées. Par exemple :\njavac -classpath /prog/exos1:/cours MyProg.java\ncompilera le ﬁchier MyProg.java si celui-ci fait référence à d’autres classes situées dans les ré-\npertoires /prog/exos1 et/cours . Le résultat de cette compilation est un ﬁchier nommé My-\nProg.class contenantlebytecodecorrespondantausourcecompilé.Ceﬁchierestcréépardéfaut\ndans le répertoire où la compilation s’est produite. Il est cependant fortement souhaitable de ne\npas mélanger les ﬁchiers contenant le code source et ceux contenant le bytecode. Un répertoire de\ndestination où sera créé le ﬁchier MyProg.class peut être précisé par l’option -d, par exemple :\njavac -d /prog/exos1 -classpath /cours MyProg.java\n1.1.2 Interprétation\nLe bytecode obtenu par compilation ne peut être exécuté qu’à l’aide de l’interpréteur. L’exé-\ncution s’eﬀectue par la commande javasuivie du nom de la classe à exécuter (sans l’extension\n.class ). Comme lors de la compilation, il se peut que des classes d’autres répertoires soient né-\ncessaires. Il faut alors utiliser l’option -classpath comme dans l’exemple qui suit :\njava -classpath /prog/exos1:/cours MyProg\n1.2 Programmation orientée-objet\nChaque langage de programmation appartient à une “famille” de langages déﬁnissant une ap-\nprocheouuneméthodologiegénéraledeprogrammation.Parexemple,lelangageCestunlangage\ndeprogrammation procédurale carilsupposequeleprogrammeurs’intéresseenprioritéaux trai-\ntements que son programme devra eﬀectuer. Un programmeur C commencera par identiﬁer ces\ntraitements pour écrire les fonctions qui les réalisent sur des données prises comme paramètres\nd’entrée.\nLa programmation orientée-objet (introduite par le langage SmallTalk) propose une métho-\ndologie centrée sur les données. Le programmeur Java va d’abord identiﬁer un ensemble d’ objets,\ntel que chaque objet représente un élément qui doit être utilisé ou manipulé par le programme,\nsous la forme d’ensembles de données. Ce n’est que dans un deuxième temps, que le program-\nmeur va écrire les traitements, en associant chaque traitement à un objet donné . Un objet peut\n2\n1.2. Programmation orientée-objet\nêtrevucommeuneentitéregroupantunensemblededonnéesetde méthodes (l’équivalentd’une\nfonction en C) de traitement.\n1.2.1 Classe\nUn objet est une variable (presque) comme les autres. Il faut notamment qu’il soit déclaré\navec son type. Le type d’un objet est un type complexe (par opposition aux types primitifs entier,\ncaractère, …) qu’on appelle une classe.\nUneclasseregroupeunensemblededonnées(quipeuventêtredesvariablesprimitivesoudes\nobjets) et un ensemble de méthodes de traitement de ces données et/ou de données extérieures à\nla classe. On parle d’ encapsulation pour désigner le regroupement de données dans une classe.\nPar exemple, une classe Rectangle utilisée pour instancier des objets représentant des rec-\ntangles,encapsuleentiers :lalongueuretlalargeurdurectangleainsiquelapositionenabscisse\net en ordonnée de l’origine du rectangle (par exemple, le coin en haut à gauche). On peut alors\nimaginerquelaclasse Rectangle implémenteuneméthodepermettantdedéplacerlerectanglequi\nnécessite en entrée deux entiers indiquant la distance de déplacement en abscisse et en ordonnée.\nL’accès aux positions de l’origine du rectangle se fait directement (i.e. sans passage de paramètre)\nlorsque les données sont encapsulées dans la classe où est déﬁnie la méthode. Un exemple, écrit\nen Java, de la classe Rectangle est donné ci-dessous :\nclass Rectangle {\nint longueur ;\nint largeur ;\nint origine_x ;\nint origine_y ;\nvoid deplace (int x,int y){\nthis .origine_x =this .origine_x +x;\nthis .origine_y =this .origine_y +y;\n}\nint surface (){\nreturn this .longueur *this .largeur ;\n}\n}\nPour écrire un programme avec un langage orienté-objet, le programmeur écrit uniquement\ndes classes correspondant aux objets de son système. Les traitements à eﬀectuer sont programmés\ndans les méthodes de ces classes qui peuvent faire appel à des méthodes d’autres classes. En géné-\nral, on déﬁnit une classe, dite “exécutable”, dont une méthode peut être appelée pour exécuter le\nprogramme.\nEncapsulation\nLorsdelaconceptiond’unprogrammeorienté-objet,leprogrammeurdoitidentiﬁerlesobjets\net les données appartenant à chaque objet mais aussi des droits d’accès qu’ont les autres objets sur\nces données. L’encapsulation de données dans un objet permet de cacher ou non leur existence\naux autres objets du programme. Une donnée peut être déclarée en accès :\n●public : les autres objets peuvent accéder à la valeur de cette donnée ainsi que la modiﬁer;\n3\nChapitre 1. Introduction au langage Java\n●privé: les autres objets n’ont pas le droit d’accéder directement à la valeur de cette donnée\n(ni de la modiﬁer). En revanche, ils peuvent le faire indirectement par des méthodes de\nl’objet concerné (si celles-ci existent en accès public).\nLes diﬀérents droits d’accès utilisables en Java sont détaillés dans la section ...\nMéthode constructeur\nChaqueclassedoitdéﬁniruneouplusieursméthodesparticulièresappeléesdes constructeurs .\nUnconstructeur estuneméthodeinvoquéelorsdelacréationd’unobjet.Cetteméthode,quipeut\nêtre vide, eﬀectue les opérations nécessaires à l’initialisation d’un objet. Chaque constructeur doit\navoirlemêmenomquelaclasseoùilestdéﬁnietn’aaucunevaleurderetour(c’estl’objetcrééqui\nest renvoyé). Dans l’exemple précédent de la classe rectangle, le constructeur initialise la valeur\ndes données encapsulées :\nclass Rectangle {\n...\nRectangle (int lon,int lar){\nthis .longueur =lon;\nthis .largeur =lar;\nthis .origine_x =0;\nthis .origine_y =0;\n}\n...\n}\nPlusieurs constructeurs peuvent être déﬁnis s’ils acceptent des paramètres d’entrée diﬀérents.\n1.2.2 Objet\nInstanciation\nUn objet est une instance (anglicisme signiﬁant «cas» ou «exemple») d’une classe et est réfé-\nrencé par une variable ayant un état (ou valeur). Pour créer un objet, il est nécessaire de déclarer\nune variable dont le type est la classe à instancier, puis de faire appel à un constructeur de cette\nclasse. L’exemple ci-dessous illustre la création d’un objet de classe Cercle en Java :\nCercle mon_rond ;\nmon_rond =new Cercle ();\nL’usage de parenthèses à l’initialisation du vecteur, montre qu’une méthode est appelée pour\nl’instanciation. Cette méthode est un constructeur de la classe Cercle . Si le constructeur appelé\nnécessitedesparamètresd’entrée,ceux-cidoiventêtreprécisésentrecesparenthèses(commelors\nd’un appel classique de méthode). L’instanciation d’un objet de la classe Rectangle faisant appel\nau constructeur donné en exemple ci-dessous pourra s’écrire :\nRectangle mon_rectangle =new Rectangle (15,5);\n*Remarque importante : enJava,lanotiondepointeuresttransparentepourleprogrammeur.\nIl faut néanmoins savoir que toute variable désignant un objet est un pointeur . Il s’ensuit alors\nque le passage d’objets comme paramètres d’une méthode est toujours un passage par référence.\nA l’inverse, le passage de variables primitives comme paramètres est toujours un passage par\nvaleur.\n4\n1.2. Programmation orientée-objet\nAccès auxvariable setauxméthode s\nPour accéder à une variable associée à un objet, il faut préciser l’objet qui la contient. Le sym-\nbole ’ .’ sert à séparer l’identiﬁcateur de l’objet de l’identiﬁcateur de la variable. Une copie de la\nlongueur d’un rectangle dans un entier temps’écrit :\nint temp =mon_rectangle .longueur ;\nLa même syntaxe est utilisée pour appeler une méthode d’un objet. Par exemple :\nmon_rectangle .deplace (10,-3);\nPour qu’un tel appel soit possible, il faut que trois conditions soient remplies :\n.La variable ou la méthode appelée existe!\n.Une variable désignant l’objet visé existe et soit instanciée.\n.L’objet, au sein duquel est fait cet appel, ait le droit d’accéder à la méthode ou à la variable\n(cf. section ..).\nPour référencer l’objet “courant” (celui dans lequel se situe la ligne de code), le langage Java\nfournit le mot-clé this. Celui-ci n’a pas besoin d’être instancié et s’utilise comme une variable\ndésignantl’objet courant. Le mot-clé thisest également utilisé pour faire appel à un constructeur\nde l’objet courant. Ces deux utilisations possibles de thissont illustrées dans l’exemple suivant :\nclass Carre {\nint cote ;\nint origine_x ;\nint origine_y ;\nCarre (int cote ,int x,int y){\nthis .cote =cote ;\nthis .origine_x =x;\nthis .origine_y =y;\n}\nCarre (int cote ){\nthis (cote ,0,0);\n}\n}\n5\nChapitre 1. Introduction au langage Java\n6\nChapitre 2\nSyntaxe du langage\nLe langage C a servi de base pour la syntaxe du langage Java :\n●le caractère de ﬁn d’une instruction est “ ;”\na=c+c;\n●lescommentaires(nontraitésparlecompilateur)sesituententrelessymboles“ /*”et“ */”\nou commencent par le symbole “ //” en se terminant à la ﬁn de la ligne\nint a;// ce commentaire tient sur une ligne\nint b;\nou\n/*Ce commentaire nécessite\n2 lignes*/\nint a;\n●les identiﬁcateurs de variables ou de méthodes acceptent les caractères {a..z}, {A..Z}, , _\nainsi que les caractères {..} s’ils ne sont pas le premier caractère de l’identiﬁcateur. Il faut\névidemment que l’identiﬁcateur ne soit pas un mot réservé du langage (comme intou\nfor).\nEx : mon_entier etok4all sont des identiﬁcateurs valides mais\nmon-entier et4allne sont pas valides pour des identiﬁcateurs.\n2.1 Types dedonnées\n2.1.1 Types primitifs\nLe tableau .liste l’ensemble des types primitifs de données de Java.\nEn plus de ces types primitifs, le terme voidest utilisé pour spéciﬁer le retour vide ou une\nabsence de paramètres d’une méthode. On peut remarquer que chaque type primitif possède une\nclasse qui encapsule un attribut du type primitif. Par exemple, la classe Integer encapsule un\nattribut de type intet permet ainsi d’eﬀectuer des opérations de traitement et des manipulations\nqui seraient impossibles sur une simple variable de type int.\nAl’inversedu langageC, Javaest unlangage trèsrigoureux surle typagedes données. Ilest in-\nterditd’aﬀecteràunevariablelavaleurd’unevariabled’untypediﬀérent ¹sicettesecondevariable\nn’est pas explicitement transformée. Par exemple :\n.exception faite des types associés par une relation d’héritage, cf. section \n7\nChapitre 2. Syntaxe du langage\nT . – Type primitifs de données en Java\nType Classe éq. Valeurs Portée Défaut\nboolean Boolean trueoufalse N/A false\nbyte Byte entier signé {-128..128} \nchar Character caractère {/u.. /uFFFF} /u\nshort Short entier signé {-32768..32767} 0\nint Integer entier signé {-2147483648 ..2147483647 } 0\nlong Long entier signé {-231..231−1} 0\nfloat Float réel signé {-3, 402823438..3, 402823438} 0.0\n{-1, 40239846−45..1, 40239846−45}\ndouble Double réel signé {-1, 797693134308..1, 797693134308} 0.0\n{-4, 94065645−324..4, 94065645−324}\nint a;\ndouble b=5.0;\na=b;\nest interdit et doit être écrit de la manière suivante :\nint a;\ndouble b=5.0 ;\na=(int)b;\n2.1.2 Tableaux etmatrices\nUne variable est déclarée comme un tableau dès lors que des crochets sont présents soit après\nson type, soit après son identiﬁcateur. Les deux syntaxes suivantes sont acceptées pour déclarer\nun tableau d’entiers (même si la première, non autorisée en C, est plus intuitive) :\nint[]mon_tableau ;\nint mon_tableau2 [];\nUn tableau a toujours une taille ﬁxe ²qui doit être précisée avant l’aﬀectation de valeurs à ses\nindices, de la manière suivante :\nint[]mon_tableau =new int[20];\nDe plus, la taille de ce tableau est disponible dans une variable length appartenant au tableau\net accessible par mon_tableau.length . On peut également créer des matrices ou des tableaux à\nplusieurs dimensions en multipliant les crochets (ex : int[][] ma_matrice; ). À l’instar du C,\non accède aux éléments d’un tableau en précisant un indice entre crochets ( mon_tableau[3] est\nle quatrième entier du tableau) et un tableau de taille nstocke ses éléments à des indices allant de\nOàn-1.\n.pour utiliser des ensembles à taille variable, la classe java.util.Vector est très utile\n8\n2.2. Opérateurs\n2.1.3 Chaînes decaractères\nLeschaînesdecaractèresnesontpasconsidéréesenJavacommeuntypeprimitifoucommeun\ntableau. On utilise une classe particulière, nommée String , fournie dans le package java.lang .\nLes variables de type String ont les caractéristiques suivantes :\n●leur valeur ne peut pas être modiﬁée\n●on peut utiliser l’opérateur +pour concaténer deux chaînes de caractères :\nString s1 =”hello” ;\nString s2 =”world” ;\nString s3 =s1+” ” +s2;\n//Après ces instructions s3 vaut ”hello world”\n●l’initialisation d’une chaîne de caractères s’écrit :\nString s =new String (); //pour une chaine vide\nString s2 =new String (”hello world” );\n// pour une chaîne de valeur ”hello world”\n●un ensemble de méthodes de la classe java.lang.String permettent d’eﬀectuer des opé-\nrationsoudestestssurunechaînedecaractères(voirladocumentaiondelaclasse String ).\n2.2 Opérateurs\nUne liste des opérateurs disponibles en Java est présentée par ordre de priorité décroissante\ndans le tableau ..\n2.3 Structures decontrôle\nLes structures de contrôle permettent d’exécuter un bloc d’instructions soit plusieurs fois\n(instructions itératives) soit selon la valeur d’une expression (instructions conditionnelles ou de\nchoix multiple). Dans tous ces cas, un bloc d’instruction est\n●soit une instruction unique;\n●soit une suite d’instructions commençant par une accolade ouvrante “ {” et se terminant\npar une accolade fermante “ }”.\n2.3.1 Instructions conditionnelles\nSyntaxe :\nif (<condition>) <bloc1> [else <bloc2> ]\nou\n<condition>?<instruction1>:<instruction2>\n<condition> doit renvoyer une valeur booléenne. Si celle-ci est vraie c’est <bloc1> (resp.\n<instruction1> ) qui est exécuté sinon <bloc2> (resp. <instruction2> ) est exécuté. La partie\nelse <bloc2> est facultative.\nExemple :\n9\nChapitre 2. Syntaxe du langage\nT . – Opérateurs Java\nPr. Opérateur Syntaxe Résultat Signiﬁcation\n ++ ++<ari> <ari> pré incrémentation\n<ari>++ <ari> post incrémentation\n— —<ari> <ari> pré décrémentation\n<ari>— <ari> post décrémentation\n+ +<ari> <ari> signe positif\n- -<ari> <ari> signe négatif\n! !<boo> <boo> complément logique\n(type ) (type )<val> <val> changement de type\n * <ari>*<ari> <ari> multiplication\n/ <ari>/<ari> <ari> division\n% <ari>%<ari> <ari> reste de la division\n + <ari>+<ari> <ari> addition\n- <ari>-<ari> <ari> soustraction\n+ <str>+<str> <str> concaténation\n << <ent> << <ent> <ent> décalage de bits\nà gauche\n>> <ent> >> <ent> <ent> décalage de bits\nà droite\n < <ari> < <ari> <boo> inférieur à\n<= <ari> <= <ari> <boo> inférieur ou égal à\n> <ari> > <ari> <boo> supérieur à\n>= <ari> >= <ari> <boo> supérieur ou égal à\ninstanceof <val>instanceof<cla> <boo> test de type\n == <val>==<val> <boo> égal à\n!= <val>!=<val> <boo> diﬀérent de\n & <ent>&<ent> <ent> ET bit à bit\n<boo>&<boo> <boo> ET booléen\n ˆ <ent>ˆ<ent> <ent> OU exclusif bit à bit\n<boo>ˆ<boo> <boo> OU exclusif booléen\n | <ent>|<ent> <ent> OU bit à bit\n<boo>|<boo> <boo> OU booléen\n && <boo>&&<boo> <boo> ET logique\n || <boo>||<boo> <boo> OU logique\n ?: <boo>?<ins>:<ins> <ins> si...alors...sinon\n = <var>=<val> <val> assignation\nLégende\n<ari>valeur arithmétique\n<boo>valeur booléenne\n<cla>classe<ent>valeur entière\n<ins>instruction\n<str>chaîne de caractères ( String )<val>valeur quelconque\n<var>variable\nif(a==b){\na=50;\nb=0;\n}else {\na=a-1;\n}\n2.3.2 Instructions itératives\nLes instruction itératives permettent d’exécuter plusieurs fois un bloc d’instructions, et ce,\njusqu’à ce qu’une condition donnée soit fausse. Les trois types d’instruction itératives sont les\nsuivantes :\nTantQue...Faire... L’exécution de cette instruction suit les étapes suivantes :\n.la condition (qui doit renvoyer une valeur booléenne) est évaluée. Si celle-ci est vraie on\npasse à l’étape , sinon on passe à l’étape ;\n.le bloc est exécuté;\n10\n2.3. Structures de contrôle\n.retour à l’étape ;\n.la boucle est terminée et le programme continue son exécution en interprétant les instruc-\ntion suivant le bloc.\nSyntaxe :\nwhile (<condition>) <bloc>\nExemple :\nwhile (a!=b)a++;\nFaire...TantQue... L’exécution de cette instruction suit les étapes suivantes :\n.le bloc est exécuté;\n.la condition (qui doit renvoyer une valeur booléenne) est évaluée. Si celle-ci est vraie on\nretourne à l’étape , sinon on passe à l’étape ;\n.la boucle est terminée et le programme continue son exécution en interprétant les instruc-\ntion suivant le bloc.\nSyntaxe :\ndo <bloc> while (<condition>);\nExemple :\ndoa++\nwhile (a!=b);\nPour...Faire Cette boucle est constituée de trois parties : (i) une initialisation (la déclaration de\nvariables locales à la boucle est autorisée dans cette partie); (ii) une condition d’arrêt; (iii) un\nensembled’instructionsàexécuteraprèschaqueitération(chacunedecesinstructionsestséparée\npar une virgule). L’exécution de cette instruction suit les étapes suivantes :\n.les initialisations sont eﬀectuées;\n.la condition (qui doit renvoyer une valeur booléenne) est évaluée. Si celle-ci est vraie on\npasse à l’étape , sinon on passe à l’étape ;\n.le bloc principal est exécuté;\n.les instructions à exécuter après chaque itération sont exécutées;\n.retour à l’étape ;\n.la boucle est terminée et le programme continue son exécution en interprétant les instruc-\ntions suivant le bloc principal.\nSyntaxe :\nfor (<init>;<condition>;<instr_post_itération>) <bloc>\nExemple :\nfor (int i=0,j=49;(i<25)&&(j>=25);i++, j--) {\nif(tab[i]>tab[j]){\nint tampon =tab[j];\nòQuestion : que se passe-t-il si le breaksitué après le case ’c’ est omis?\n11\nChapitre 2. Syntaxe du langage\n2.3.3 Instructions break etcontinue\nL’instruction breakestutiliséepoursortirimmédiatementd’unblocd’instructions(sanstrai-\nter les instructions restantes dans ce bloc). Dans le cas d’une boucle on peut également utiliser\nl’instruction continue avec la diﬀérence suivante :\nbreak :l’exécution se poursuit après la boucle (comme si la condition d’arrêt devenait vraie);\ncontinue :l’exécution du bloc est arrêtée mais pas celle de la boucle. Une nouvelle itération du\nbloc commence si la condition d’arrêt est toujours vraie.\nExemple :\nfor (int i=0,j=0;i<100 ;i++) {\nif(i>tab.length ){\nbreak ;\n}\nif(tab[i]==null ){\ncontinue ;\n}\ntab2 [j]=tab[i];\nj++;\n}\n12\nChapitre 3\nÉléments de programmation Java\n3.1 Premiers pas\nUn programme écrit en Java consiste en un ensemble de classes représentant les éléments ma-\nnipulés dans le programme et les traitements associés. L’exécution du programme commence par\nl’exécution d’une classe qui doit implémenter une méthode particulière “ public static void\nmain(String[] args) ”. Les classes implémentant cette méthode sont appellées classes exécu-\ntables.\n3.1.1 Classe HelloWorld\nUne classe Java HelloWorld qui aﬃche la chaîne de caractères “ Hello world ” s’écrit :\npublic class HelloWorld {\npublic static void main (String []args ){\nSystem .out.println (”Hello world” );\n}\n}\nL’exécution (après compilation) de cette classe se fait de la manière suivante :\nC:\\>java HelloWorld\nHello world\nC:\\>\n*Remarque : le tableau de chaînes de caractères argsqui est un paramètre d’entrée de la mé-\nthode maincontient des valeurs précisées à l’exécution. Si la classe avait été exécutée par la ligne\ndecommande“ java HelloWorld 4 toto _ ”,cetableaucontiendraitélémentsdontlesvaleurs\nseraient respectivement “ 4”, “toto” et “ _”.\nDanscepremierprogrammetrèssimple,uneseuleclasseestutilisée.Cependant,laconception\nd’un programme orienté-objet nécessite, pour des problèmes plus complexes, de créer plusieurs\nclasses et la classe exécutable ne sert souvent qu’à instancier les premiers objets. La classe exé-\ncutable suivante crée un objet en instanciant la classe Rectangle (cf. section ..) et aﬃche sa\nsurface :\n13\nChapitre 3. Éléments de programmation Java\npublic class RectangleMain {\npublic static void main (String []args ){\nRectangle rect =new Rectangle (5,10);\nSystem .out.println (”La surface est ” +rect .surface ());\n}\n}\n*Remarque importante : il est obligatoire d’implémenter chaque classe publique dans un\nﬁchier séparé et il est indispensable que ce ﬁchier ait le même nom que celui de la classe . Dans\nle cas précédent, deux ﬁchiers ont ainsi été créés : RectangleMain.java etRectangle.java .\n3.1.2 Packages\nUn grand nombre de classes, fournies par Java SE, implémentent des données et traitements\ngénériquesutilisablesparungrandnombred’applications.Cesclassesformentl’API( Application\nProgrammer Interface) dulangageJava.Unedocumentationenlignepourl’APIjavaestdisponible\nà l’URL :\nhttp://docs.oracle.com/javase/7/docs/api/\nToutes ces classes sont organisées en packages (ou bibliothèques) dédiés à un thème précis.\nParmi les packages les plus utilisés, on peut citer les suivants :\nPackage Description\njava.awt Classes graphiques et de gestion d’interfaces\njava.io Gestion des entrées/sorties\njava.lang Classes de base (importé par défaut)\njava.util Classes utilitaires\njavax.swing Autres classes graphiques\nPour accéder à une classe d’un package donné, il faut préalablement importer cette classe ou\nson package. Par exemple, la classe Dateappartenant au package java.util qui implémente un\nensemble de méthodes de traitement sur une date peut être importée de deux manières :\n●une seule classe du package est importée :\nimport java.util.Date ;\n●toutes les classes du package sont importées (même les classes non utilisées) :\nimport java.util.* ;\nLe programme suivant utilise cette classe pour aﬃcher la date actuelle :\nimport java.util.Date ;\npublic class DateMain {\npublic static void main (String []args ){\nDate today =new Date ();\nSystem .out.println (”Nous sommes le ” +today .toString ());\n}\n}\n14\n3.2. Variables et méthodes\nIl est possible de créer vos propres packages en précisant, avant la déclaration d’une classe, le\npackage auquel elle appartient. Pour assigner la classe précédente à un package, nommé fr.emse ,\nil faut modiﬁer le ﬁchier de cette classe comme suit :\npackage fr.emse ;\nimport java.util.Date ;\npublic class DateMain {\n...\n}\nEnﬁn, il faut que le chemin d’accès du ﬁchier DateMain.java corresponde au nom de son\npackage. Celui-ci doit donc être situé dans un répertoire fr/emse/DateMain.java accessible à\npartir des chemins d’accès déﬁnis lors de la compilation ou de l’exécution (voir section ..).\n3.2 Variables etméthodes\n3.2.1 Visibilité deschamps\nDans les exemples précédents, le mot-clé public apparaît parfois au début d’une déclaration\nde classe ou de méthode sans qu’il ait été expliqué jusqu’ici. Ce mot-clé autorise n’importe quel\nobjet à utiliser la classe ou la méthode déclarée comme publique. La portée de cette autorisation\ndépend de l’élément à laquelle elle s’applique (voir le tableau .).\nT . – Portée des autorisations\nÉlément Autorisations\nVariable Lecture et écriture\nMéthode Appel de la méthode\nClasse Instanciation d’objets de cette classe et\naccès aux variables et méthodes de classe\nLe mode public n’est, bien sûr, pas le seul type d’accès disponible en Java. Deux autres mot-\nclés peuvent être utilisés en plus du type d’accès par défaut : protected etprivate . Le tableau .\nrécapitule ces diﬀérents types d’accès (la notion de sous-classe est expliquée dans la section ).\nT . – Autorisations d’accès\npublic protected défaut private\nDans la même classe Oui Oui Oui Oui\nDans une classe du Oui Oui Oui Non\nmême package\nDans une sous-classe Oui Oui Non Non\nd’un autre package\nDans une classe quelcon- Oui Non Non Non\nque d’un autre package\n15\nChapitre 3. Éléments de programmation Java\nSi aucun mot-clé ne précise le type d’accès, celui par défaut est appliqué. En général, il est\nsouhaitable que les types d’accès soient limités et le type d’accès public , qui est utilisé systémati-\nquement par les programmeurs débutants, ne doit être utilisé que s’il est indispensable. Cette res-\ntriction permet d’éviter des erreurs lors d’accès à des méthodes ou de modiﬁcations de variables\nsans connaître totalement leur rôle.\n3.2.2 Variables etméthodes declasse\nDans certains cas, il est plus judicieux d’attacher une variable ou une méthode à une classe\nplutôt qu’aux objets instanciant cette classe. Par exemple, la classe java.lang.Integer possède\nune variable MAX_VALUE qui représente la plus grande valeur qui peut être aﬀectée à un entier.\nOr, cette variable étant commune à tous les entiers, elle n’est pas dupliquée dans tous les objets\ninstanciant la classe Integer mais elle est associée directement à la classe Integer . Une telle va-\nriable est appelée variable de classe . De la même manière, il existe des méthodes de classe qui\nsont associées directement à une classe. Pour déclarer une variable ou méthode de classe, on uti-\nlise le mot-clé static qui doit être précisé avant le type de la variable ou le type de retour de la\nméthode.\nLaclasse java.lang.Math nousfournitunbonexempledevariableetdeméthodesdeclasses.\npublic final class Math {\n...\npublic static final double PI=3.14159265358979323846 ;\n...\npublic static double toRadians (double angdeg ){\nreturn angdeg /180.0 *PI;\n}\n...\n}\nLa classe Mathfournit un ensemble d’outils (variables et méthodes) très utiles pour des pro-\ngrammes devant eﬀectuer des opération mathématiques complexes. Dans la portion de classe re-\nproduite ci-dessus, on peut notamment y trouver une approximation de la valeur de πet une mé-\nthode convertissant la mesure d’un angle d’une valeur en degrés en une valeur en radians. Dans\nle cas de cette classe, il est tout a fait inutile de créer et d’instancier un objet à partir de la classe\nMath. En eﬀet, la valeur de πou la conversion de degrés en radians ne vont pas varier suivant\nl’objet auquel elles sont rattachées. Ce sont des variables et des méthodes de classe qui peuvent\nêtre invoquées à partir de toute autre classe (car elles sont déclarées en accès public) de la manière\nsuivante :\npublic class MathMain {\npublic static void main (String []args ){\nSystem .out.println (”pi = ” +Math .PI);\nSystem .out.println (”90° = ” +Math .toRadians (90));\n}\n}\nòQuestion : Dans les sections précédentes, nous avons déjà utilisé une variable de classe et une\nméthode de classe. Pouvez-vous trouver lesquelles?\n16\n3.2. Variables et méthodes\náRéponse :\n●la méthode maindes classes exécutables est une méthode de classe car elle est appelée\ndirectement à partir d’une classe;\n●lors de l’aﬃchage d’une chaîne de caractères à l’écran par l’instruction\nSystem.out.println(…) , on fait appel à la variable outde la classe java.lang.System\nqui est un objet représentant la sortie standard (l’écran) et sur laquelle on appelle la\nméthode println permettant d’aﬃcher une chaîne de caractères.\n17\nChapitre 3. Éléments de programmation Java\n18\nChapitre 4\nHéritage\nDans certaines applications, les classes utilisées ont en commun certaines variables, méthodes\nde traitement ou même des signatures de méthode. Avec un langage de programmation orienté-\nobjet, on peut déﬁnir une classe à diﬀérent niveaux d’abstraction permettant ainsi de factoriser\ncertainsattributs communs àplusieurs classes. Une classe généraledéﬁnit alors un ensembled’at-\ntributsquisontpartagéspard’autresclasses,dontondiraqu’elles héritent decetteclassegénérale.\nPar exemple, les classes CarreetRectangle peuvent partager une méthode surface() ren-\nvoyant le résultat du calcul de la surface de la ﬁgure. Plutôt que d’écrire deux fois cette méthode,\non peut déﬁnir une relation d’héritage entre les classes CarreetRectangle . Dans ce cas, seule la\nclasse Rectangle contient le code de la méthode surface() mais celle-ci est également utilisable\nsur les objets de la classe Carresi elle hérite de Rectangle .\n4.1 Principe del’héritage\nL’idée principale de l’héritage est d’organiser les classes de manière hiérarchique. La relation\nd’héritageestunidirectionnelleet,siuneclasseBhérited’uneclasseA,ondiraqueBestunesous-\nclasse de A. Cette notion de sous-classe signiﬁe que la classe B est un cas particulier de la classe A\net donc que les objets instanciant la classe B instancient également la classe A.\nPrenons comme exemple des classes Carre,Rectangle etCercle . La ﬁgure .propose une\norganisation hiérarchique de ces classes telle que Carrehérite de Rectangle qui hérite, ainsi que\nCercle , d’une classe Forme.\nCarreForme\nRectangle Cercle\nF . – Exemple de relations d’héritage\nPourlemoment,nousconsidéreronslaclasse Formecommevide(c’est-à-diresansaucuneva-\nriableniméthode)etnousnousintéressonsplusparticulièrementauxclasses Rectangle etCarre.\n19\nChapitre 4. Héritage\nLaclasse Rectangle héritantd’uneclassevide,ellenepeutproﬁterd’aucundesesattributsetdoit\ndéﬁnir toutes ses variables et méthodes. Une relation d’héritage se déﬁnit en Java par le mot-clé\nextends utilisé comme dans l’exemple suivant :\npublic class Rectangle extends Forme {\nprivate int largeur ;\nprivate int longueur ;\npublic Rectangle (int x,int y){\nthis .largeur =x;\nthis .longueur =y;\n}\npublic int getLargeur (){\nreturn this .largeur ;\n}\npublic int getLongueur (){\nreturn this .longueur ;\n}\npublic int surface (){\nreturn this .longueur *this .largeur ;\n}\npublic void affiche (){\nSystem .out.println (”rectangle ” +longueur +”x” +largeur );\n}\n}\nEn revanche, la classe Carrepeut bénéﬁcier de la classe Rectangle et ne nécessite pas la ré-\nécriture de ces méthodes si celles-ci conviennent à la sous-classe. Toutes les méthodes et variables\ndelaclasse Rectangle nesontnéanmoinspasaccessiblesdanslaclasse Carre.Pourqu’unattribut\npuisse être utilisé dans une sous-classe, il faut que son type d’accès soit public ouprotected , ou,\nsi les deux classes sont situées dans le même package, qu’il utilise le type d’accès par défaut. Dans\ncet exemple, les variables longueur etlargeur ne sont pas accessibles dans la class Carrequi doit\npasser par les méthodes getLargeur() etgetLongueur() , déclarées comme publiques.\n4.1.1 Redéfinition\nL’héritage intégral des attributs de la classe Rectangle pose deux problèmes :\n.il faut que chaque carré ait une longueur et une largeur égales;\n.la méthode affiche écrit le mot “ rectangle ” en début de chaîne. Il serait souhaitable que\nce soit “ carré” qui s’aﬃche.\nDeplus,lesconstructeursnesontpashéritésparunesous-classe.Ilfautdoncécrireunconstruc-\nteur spéciﬁque pour Carre. Ceci nous permettra de résoudre le premier problème en écrivant un\nconstructeur qui ne prend qu’un paramètre qui sera aﬀecté à la longueur et à la largeur. Pour at-\ntribuer une valeur à ces variables (qui sont privées), le constructeur de Carredoit faire appel au\n20\n4.1. Principe de l’héritage\nconstructeurde Rectangle enutilisantlemot-clé superquifaitappelauconstructeurdelaclasse\nsupérieure comme suit :\npublic Carre (int cote ){\nsuper (cote ,cote );\n}\n*Remarques :\n●L’appel au constructeur d’une classe supérieure doit toujours se situer dans un construc-\nteur et toujours en tant que première instruction;\n●Si aucun appel à un constructeur d’une classe supérieure n’est fait, le constructeur\nfait appel implicitement à un constructeur vide de la classe supérieure (comme si la\nligne super() était présente). Si aucun constructeur vide n’est accessible dans la classe\nsupérieure, une erreur se produit lors de la compilation.\nLe second problème peut être résolu par une redéﬁnition de méthode. On dit qu’une méthode\nd’une sous-classe redéﬁnit une méthode de sa classe supérieure, si elles ont la même signature\nmais que le traitement eﬀectué est ré-écrit dans la sous-classe. Voici le code de la classe Carreoù\nsont résolus les deux problèmes soulevés :\npublic class Carre extends Rectangle {\npublic Carre (int cote ){\nsuper (cote ,cote );\n}\npublic void affiche (){\nSystem .out.println (”carré ” +this .getLongueur ());\n}\n}\nLors de la redéﬁnition d’une méthode, il est encore possible d’accéder à la méthode redéﬁnie\ndanslaclassesupérieure.Cetaccèsutiliseégalementlemot-clé supercommepréﬁxeàlaméthode.\nDans notre cas, il faudrait écrire super.affiche() pour eﬀectuer le traitement de la méthode\naffiche() deRectangle .\nEnﬁn, il est possible d’interdire la redéﬁnition d’une méthode ou d’une variable en introdui-\nsant le mot-clé finalau début d’une signature de méthode ou d’une déclaration de variable. Il\nest aussi possible d’interdire l’héritage d’une classe en utilisant finalau début de la déclaration\nd’une classe (avant le mot-clé class).\n4.1.2 Polymorphisme\nLe polymorphisme est la faculté attribuée à un objet d’être une instance de plusieurs classes.\nIl a une seule classe “réelle” qui est celle dont le constructeur a été appelé en premier (c’est-à-dire\nla classe ﬁgurant après le new) mais il peut aussi être déclaré avec une classe supérieure à sa classe\nréelle. Cette propriété est très utile pour la création d’ensembles regroupant des objets de classes\ndiﬀérentes comme dans l’exemple suivant :\n21\nChapitre 4. Héritage\nForme []tableau =new Forme [4];\ntableau [0]=new Rectangle (10,20);\ntableau [1]=new Cercle (15);\ntableau [2]=new Rectangle (5,30);\ntableau [3]=new Carre (10);\nL’opérateur instanceof peut être utilisé pour tester l’appartenance à une classe comme suit :\nfor (int i=0;i<tableau .length ;i++) {\nif(tableau [i]instanceof Forme )\nSystem .out.println (”element ” +i+” est une forme” );\nif(tableau [i]instanceof Cercle )\nSystem .out.println (”element ” +i+” est un cercle” );\nif(tableau [i]instanceof Rectangle )\nSystem .out.println (”element ” +i+” est un rectangle” );\nif(tableau [i]instanceof Carre )\nSystem .out.println (”element ” +i+” est un carré” );\n}\nL’exécution de ce code sur le tableau précédent aﬃche le texte suivant :\nelement[0] est une forme\nelement[0] est un rectangle\nelement[1] est une forme\nelement[1] est un cercle\nelement[2] est une forme\nelement[2] est un rectangle\nelement[3] est une forme\nelement[3] est un rectangle\nelement[3] est un carré\nL’ensemble des classes Java, y compris celles écrites en dehors de l’API, forme une hiérarchie\navec une racine unique. Cette racine est la classe Object dont hérite toute autre classe. En eﬀet, si\nvous ne précisez pas explicitement une relation d’héritage lors de l’écriture d’une classe, celle-ci\nhérite par défaut de la classe Object . Grâce à cette propriété, des classes génériques ¹de création\net de gestion d’un ensemble, plus élaborées que les tableaux, regroupent des objets appartenant à\nla classe Object (donc de n’importe quelle classe).\nUne des propriétés induites par le polymorphisme est que l’interpréteur Java est capable de\ntrouver le traitement à eﬀectuer lors de l’appel d’une méthode sur un objet. Ainsi, pour plusieurs\nobjetsdéclaréssouslamêmeclasse(maisn’ayantpaslamêmeclasseréelle),letraitementassociéà\nuneméthodedonnépeutêtrediﬀérent.Sicetteméthodeestredéﬁnieparlaclasseréelled’unobjet\n(ou par une classe située entre la classe réelle et la classe de déclaration), le traitement eﬀectué est\ncelui déﬁni dans la classe la plus spéciﬁque de l’objet et qui redéﬁnie la méthode.\nDansnotreexemple,laméthode affiche() estredéﬁniedanstouteslessous-classesde Forme\net les traitements eﬀectués sont :\nfor (int i=0;i<tableau .length ;i++) {\ntableau [i].affiche ();\n}\n.voir par exemple les classes java.util.Vector ,java.util.Hashtable , …\n22\n4.2. Interfaces\nRésultat :\nrectangle 10x20\ncercle 15\nrectangle 5x30\ncarré 10\nDans l’état actuel de nos classes, ce code ne pourra cependant pas être compilé. En eﬀet, la\nfonction affiche() est appelée sur des objets dont la classe déclarée est Formemais celle-ci ne\ncontient aucune fonction appelée affiche() (elle est seulement déﬁnie dans ses sous-classes).\nPour compiler ce programme, il faut transformer la classe Formeen une interface ou une classe\nabstraite tel que cela est fait dans les sections suivantes.\n4.2 Interfaces\nUne interface est un type, au même titre qu’une classe, mais abstrait et qui donc ne peut être\ninstancié (par appel à newplus constructeur). Une interface décrit un ensemble de signatures de\nméthodes, sans implémentation, qui doivent être implémentées dans toutes les classes qui im-\nplémentent l’interface. L’utilité du concept d’interface réside dans le regroupement de plusieurs\nclasses,telquechacuneimplémenteunensemblecommundeméthodes,sousunmêmetype.Une\ninterface possède les caractéristiques suivantes :\n●elle contient des signatures de méthodes;\n●elle ne peut pas contenir de variables;\n●une interface peut hériter d’une autre interface (avec le mot-clé extends );\n●une classe (abstraite ou non) peut implémenter plusieurs interfaces. La liste des interfaces\nimplémentées doit alors ﬁgurer après le mot-clé implements placé dans la déclaration de\nclasse, en séparant chaque interface par une virgule.\nDans notre exemple, Formepeut être une interface décrivant les méthodes qui doivent être\nimplémentées par les classes Rectangle etCercle , ainsi que par la classe Carre(même si celle-ci\npeutproﬁterdesonhéritagede Rectangle ).L’interface Formes’écritalorsdelamanièresuivante :\npublic interface Forme {\npublic int surface ();\npublic void affiche ();\n}\nPour obliger les classes Rectangle ,Cercle etCarreà implémenter les méthodes surface()\netaffiche() , il faut modiﬁer l’héritage de ce qui était la classe Formeen une implémentation de\nl’interface déﬁnie ci-dessus :\npublic class Rectangle implements Forme {\n...\n}\net\npublic class Cercle implements Forme {\n...\n}\n23\nChapitre 4. Héritage\nCettestructuredeclassesnouspermetdésormaisdepouvoircompilerl’exempledonnédansla\nsection ..traitantdupolymorphisme.Endéclarantuntableauconstituéd’objetsimplémentant\nl’interface Forme,onpeutappelerlaméthode affiche() quiexisteetestimplémentéeparchaque\nobjet.\nSi une classe implémente une interface mais que le programmeur n’a pas écrit l’implémenta-\ntion de toutes les méthodes de l’interface, une erreur de compilation se produira sauf si la classe\nest une classe abstraite.\n4.3 Classes abstraites\nLe concept de classe abstraite se situe entre celui de classe et celui d’interface. C’est une classe\nqu’on ne peut pas directement instancier car certaines de ses méthodes ne sont pas implémen-\ntées. Une classe abstraite peut donc contenir des variables, des méthodes implémentées et des\nsignatures de méthode à implémenter. Une classe abstraite peut implémenter (partiellement ou\ntotalement) des interfaces et peut hériter d’une classe ou d’une classe abstraite.\nLe mot-clé abstract est utilisé devant le mot-clé classpour déclarer une classe abstraite,\nainsi que pour la déclaration de signatures de méthodes à implémenter.\nImaginons que l’on souhaite attribuer deux variables, origine_x etorigine_y , à tout objet\nreprésentant une forme. Comme une interface ne peut contenir de variables, il faut transformer\nFormeen classe abstraite comme suit :\npublic abstract class Forme {\nprivate int origine_x ;\nprivate int origine_y ;\npublic Forme (){\nthis .origine_x =0;\nthis .origine_y =0;\n}\npublic int getOrigineX (){\nreturn this .origine_x ;\n}\npublic int getOrigineY (){\nreturn this .origine_y ;\n}\npublic void setOrigineX (int x){\nthis .origine_x =x;\n}\npublic void setOrigineY (int y){\nthis .origine_y =y;\n}\npublic abstract int surface ();\npublic abstract void affiche ();\n}\n24\n4.4. Classes et méthodes génériques\nDe plus, il faut rétablir l’héritage des classes Rectangle etCercle vers Forme :\npublic class Rectangle extends Forme {\n...\n}\net\npublic class Cercle extends Forme {\n...\n}\nLorsqu’une classe hérite d’une classe abstraite, elle doit :\n●soit implémenter les méthodes abstraites de sa super-classe en les dotant d’un corps;\n●soit être elle-même abstraite si au moins une des méthodes abstraites de sa super-classe\nreste abstraite.\n4.4 Classes etméthodes génériques\nIl est parfois utile de déﬁnir des classes paramétrées par un type de données (ou une classe).\nPar exemple, dans le package java.util , de nombreuses classes sont génériques et notamment\nlesclassesreprésentantdesensembles( Vector ,ArrayList ,etc.).Cesclassessontgénériquesdans\nlesensoùellesprennentenparamètreuntype(classeouinterface)quelconque E.Eestenquelque\nsorte une variable qui peut prendre comme valeur un type de donné. Ceci se note comme suit, en\nprenant l’exempe de java.util.ArrayList :\npackage java .util ;\npublic class ArrayList <E>\nextends AbstractList <E>\nimplements List <E>,...\n{\n...\npublic Eset(int index ,E element ){\n...\n}\npublic boolean add(E e){\n...\n}\n...\n}\nNous pouvons remarquer que le type passé en paramètre est noté entre chevrons (ex : <E>), et\nqu’il peut ensuite être réutilisé dans le corps de la classe, par des méthodes (ex : la méthode set\nrenvoie un élément de classe E).\nIl est possible de déﬁnir des contraintes sur le type passé en paramètre, comme par exemple\nune contrainte de type extends ²:\n.Ici, on utilise T extends E pour signaler que le type Test un sous type de E, que Esoit une classe ou une\ninterface (on n’utilise pas implements ).\n25\nChapitre 4. Héritage\npublic class SortedList <Textends Comparable <T>>{\n...\n}\nCeci signiﬁe que la classe SortedList (liste ordonnée que nous voulons déﬁnir) est paramé-\ntrée par le type Tqui doit être un type dérivé (par héritage ou interfaçage) de Comparable<T> .\nEn bref, nous déﬁnissons une liste ordonnée d’éléments comparables entre eux (pour pouvoir\nles trier), grâce à la méthode int compareTo(T o) de l’interface Comparable ³qui permet de\ncomparer un Comparable à un élément de type T.\n.Voir java.lang.Comparable pour plus d’information sur cette interface.\n26\nChapitre 5\nGestion des exceptions\nLors de l’écriture d’un programme, la prise en compte d’erreurs prend une place très impor-\ntante si l’on souhaite écrire un programme robuste. Par exemple, la simple ouverture d’un ﬁchier\npeut provoquer beaucoup d’erreurs telles que l’inexistence du ﬁchier, un mauvais format, une in-\nterdiction d’accès, une erreur de connexion au périphérique, … Pour que notre programme soit\nrobuste, il faut que toutes les erreurs possibles soient détectées et traitées.\nCertains langages de programmation, dont le langage Java, proposent un mécanisme de prise\nen compte des erreurs, fondé sur la notion d’ exception . Une exception est un objet qui peut être\némis par une méthode si un événement d’ordre “exceptionnel” (les erreurs rentrent dans cette\ncatégorie) se produit. La méthode en question ne renvoie alors pas de valeur de retour, mais émet\nune exception expliquant la cause de cette émission. La propagation d’une émission se déroule\nselon les étapes suivantes :\n.Une exception est générée à l’intérieur d’une méthode;\n.Si la méthode prévoit un traitement de cette exception, on va au point , sinon au point ;\n.L’exception est renvoyée à la méthode ayant appelé la méthode courante, on retourne au\npoint ;\n.L’exception est traitée et le programme reprend son cours après le traitement de l’excep-\ntion.\nLa gestion d’erreurs par propagation d’exception présente deux atouts majeurs :\n●Une facilité de programmation et de lisibilité : il est possible de regrouper la gestion\nd’erreurs à un même niveau. Cela évite des redondances dans l’écriture de traitements\nd’erreurs et encombre peu le reste du code avec ces traitements.\n●Une gestion des erreurs propre et explicite :certainslangagesdeprogrammationutilisent\nla valeur de retour des méthodes pour signaler une erreur à la méthode appelante. Etant\ndonné que ce n’est pas le rôle de la valeur de retour de décrire une erreur, il est souvent\nimpossible de connaître les causes réelles de l’erreur. La dissociation de la valeur de retour\net de l’exception permet à cette dernière de décrire précisément la ligne de code ayant\nprovoqué l’erreur et la nature de cette erreur.\n5.1 Déclaration\nIl est nécessaire de déclarer, pour chaque méthode, les classes d’exception qu’elle est suscep-\ntible d’émettre. Cette déclaration se fait à la ﬁn de la signature d’une méthode par le mot-clé\nthrows à la suite duquel les classes d’exceptions (séparées par une virgule s’il en existe plusieurs)\nqui peuvent être générées sont précisées. La méthode parseInt de la classe Integer est un bon\nexemple :\n27\nChapitre 5. Gestion des exceptions\npublic static int parseInt (String s )throws NumberFormatException {\n...\n}\nCette méthode convertit une chaîne de caractères, qui doit contenir uniquement des chiﬀres,\nen un entier. Une erreur peut se produire si cette chaîne de caractères ne contient pas que des\nchiﬀres. Dans ce cas une exception de la classe NumberFormatException est émise.\nUne exception peut être émise dans une méthode de deux manières : (i) par une autre mé-\nthode appelée dans le corps de la première méthode; (ii) par la création d’un objet instanciant la\nclasse Exception (oulaclasse Throwable )etlalevéeexplicitedel’exceptionenutilisantlemot-clé\nthrow.\nL’exemple ci-dessous illustre ce second cas :\npublic class ExempleException {\n/*\n* Cette méthode renvoie le nom du mois\n* correspondant au chiffre donné en paramètre.\n* Si celui-ci n’est pas valide une exception de classe\n* IndexOutOfBoundsException est levée.\n*/\npublic static String month (int mois )\nthrows IndexOutOfBoundsException {\nif((mois <1)||(mois >12)){\nthrow new IndexOutOfBoundsException (\n”le numero du mois qui est ”\n+mois\n+” doit être compris entre 1 et 12” );\n}\nif(mois ==1)\nreturn ”Janvier” ;\nelse if(mois ==2)\nreturn ”Février” ;\n...\nelse if(mois ==11)\nreturn ”Novembre” ;\nelse\nreturn ”Décembre” ;\n}\n}\nLa signiﬁcation des exceptions de la classe IndexOutOfBoundsException est qu’un index\ndonnédépasselesbornesminimumetmaximumqu’ildevraitrespecter.Siuneméthodedemande\nla chaîne de caractères correspondant à des mois inexistants (inférieur à  ou supérieur à ) une\nexception signalera cette erreur. On peut remarquer dans cet exemple que la détection et la for-\nmulation de l’erreur sont codées dans la méthode mais pas son traitement.\n28\n5.2. Interception et traitement\n5.2 Interception ettraitement\nAvantdecoderletraitementdecertainesexceptions,ilfautpréciserl’endroitoùellesvontêtre\ninterceptées. Si une méthode Aappelle une méthode Bqui appelle une méthode Cqui appelle une\nméthode D, et que cette méthode Dlève une exception, celle-ci est d’abord transmise à Cqui peut\nl’intercepter ou la transmettre à B, qui peut aussi l’intercepter ou la transmettre à A.\nL’interception d’exceptions se fait par une sorte de “mise sur écoute” d’une portion de code.\nPour cela on utilise le mot-clé trysuivi du bloc à surveiller. Si aucune exception ne se produit\ndans le bloc correspondant, le programme se déroule normalement comme si l’instruction try\nétait absente. Par contre, si une exception est levée, le traitement de l’exception est exécuté puis\nl’exécution du programme reprend son cours après le bloc testé.\nIl est également nécessaire de préciser quelles classes d’exception doivent être interceptées\ndans le bloc testé. L’interception d’une classe d’exception s’écrit grâce au mot-clé catchsuivi de\nla classe concerné, d’un nom de variable correspondant à l’objet exception, puis du traitement.\nSi une exception est levée sans qu’aucune interception ne soit prévue pour sa classe, celle-ci est\npropagée à la méthode précédente.\nDans l’exemple ci-dessous, le programme demande à l’utilisateur de saisir le numero d’un\nmois et aﬃche à l’écran le nom de ce mois. Les exceptions qui peuvent être levées par ce pro-\ngramme sont traitées.\npublic class ExempleTraitementException {\npublic static void main (String []args ){\nSystem .out.print (”Entrez le numero d’un mois : ” );\ntry {\nBufferedReader input =new BufferedReader (\nnew InputStreamReader (System .in));\nString choix =input .readLine ();\nint numero =Integer .parseInt (choix );\nSystem .out.println (ExempleException .month (numero ));\n}catch (IndexOutOfBoundsException e ){\nSystem .err.println (”Numero incorrect : ”\n+e.getMessage ());\n}catch (NumberFormatException e ){\nSystem .err.println (”Entrée incorrecte : ”\n+e.getMessage ());\n}catch (IOException e ){\nSystem .err.println (”Erreur d’accès : ”\n+e.getMessage ());\n}\n}\n}\nTrois classes d’exception sont ici traitées :\n●IndexOutOfBoundsException (levé par la méthode month) se produit si le numero entré\npar l’utilisateur est inférieur à  ou supérieur à ;\n●NumberFormatException (levé par la méthode parseInt ) qui se produit si le texte entré\npar l’utilisateur n’est pas convertible en entier;\n●IOException (levé par la méthode readLine ) qui se produit si il y a eu une erreur d’accès\nau périphérique d’entrée.\n29\nChapitre 5. Gestion des exceptions\nDans chacun de ces cas, le traitement consiste à aﬃcher le message d’erreur associé à l’exception.\n5.3 Classes d’exception\nUne classe est considérée comme une classe d’exception dès lors qu’elle hérite de la classe\nThrowable . Un grand nombre de classes d’exception sont proposées dans l’API pour couvrir les\ncatégories d’erreurs les plus fréquentes. Les relations d’héritage entre ces classes permettent de\nlever ou d’intercepter des exceptions décrivant une erreur à diﬀérents niveaux de précision. Les\nclasses d’exception les plus fréquemment utilisées sont récapitulées dans le tableau ..\nT . – Classes d’exception fréquentes\nClasse Description\nAWTException Les exceptions de cette classe peuvent se\nproduire lors d’opérations de type\ngraphique.\nClassCastException Signale une erreur lors de la conversion\nd’un objet en une classe incompatible\navec sa vraie classe.\nFileNotFoundException Signale une tentative d’ouverture d’un\nﬁchier inexistant.\nIndexOutOfBoundsException Se produit lorsque l’on essaie d’accéder\nà un élément inexistant dans un\nensemble.\nIOException Les exceptions de cette classe peuvent se\nproduire lors d’opérations d’entrées/\nsorties.\nNullPointerException Se produit lorsqu’un pointeur null\nest reçu par une méthode n’acceptant\npas cette valeur, ou lorsque l’on\nappelle une méthode ou une variable\nà partir d’un pointeur null.\n*Remarque : Il n’est pas indispensable d’intercepter les exceptions héritant de la\nclasse RuntimeException (dans le tableau ci-dessus, les classes qui en héritent sont\nClassCastException ,IndexOutOfBoundsException etNullPointerException ). Celles-ci\npeuvent être propagées jusqu’à la machine virtuelle et n’apparaître que pendant l’exécution. Ces\nexceptions sont appelées exception non vériﬁées ouunchecked exceptions .\nSi aucune des classes d’exception ne correspond à un type d’erreur que vous souhaitez ex-\nprimer, vous pouvez également écrire vos propres classes d’exception. Pour cela, il suﬃt de faire\nhériter votre classe de la classe java.lang.Exception .\n5.4 Classification deserreurs enJava\nOn peut ﬁnalement distinguer quatre types de situations d’erreurs en Java :\n30\n5.4. Classification des erreurs en Java\nErreurs de compilation. Avant même de pouvoir exécuter le programme, notre code source gé-\nnèredeserreurparlecompilateur.Ilfautalorsréviseretcorrigerlecodepourneplusavoir\nd’erreurs.\nErreurs d’exécution. Alors que notre programme est en cours d’exécution, la JVM étant mal\nconﬁgurée ou corrompue, le programme s’arrête ou se gèle. A priori, c’est une erreur non\npas due à notre programme, mais à la conﬁguration ou l’état de l’environnement d’exécu-\ntion de notre programme.\nException non vériﬁée. Alorsquenotreprogrammeestencoursd’exécution,unetracedelapile\ndesexceptionsestaﬃchée,pointantversunepartiedenotrecodesansgestiond’exception.\nVisiblement, nous avons utilisé du code qui est capable de lever un exception non vériﬁée\n(comme NullPointerException ). Il faut modiﬁer le programme pour que cette situation\nne survienne pas.\nException vériﬁée. Alors que notre programme est en cours d’exécution, une trace de la pile des\nexceptions est aﬃchée, pointant vers une partie de notre code avec gestion d’exception.\nVisiblement, nous avons produit du code qui est capable de lever un exception vériﬁée\n(comme FileNotFoundException ) mais les données passées à notre programme ne va-\nlide pas ces exceptions (par exemple, lorsque l’on essaie d’ouvrir un ﬁchier qui n’existe\npas). Il faut alors revoir les données passées en paramètre du programme. Notre code a\nbien détecté les problèmes qu’il fallait détecter. Le chapitre suivant sur les entrées/sorties\nprésentent de nombreux exemples relatifs à ce cas.\n31\nChapitre 5. Gestion des exceptions\n32\nChapitre 6\nGestion des entrées/sorties simples\nLe package java.io propose un ensemble de classes permettant de gérer la plupart des en-\ntrées/sorties d’un programme. Cette gestion consiste à créer un objet ﬂuxdans lequel transitent\nles données à envoyer ou à recevoir. Un ﬂux connecte un objet Java à un autre élément. Deux cas\nsont illustrés dans ce chapitre : les interactions avec un utilisateur (entrée clavier et sortie écran)\net les accès en lecture ou écriture à un ﬁchier.\n6.1 Flux d’entrée\nUn ﬂux d’entrée est une instance d’une sous-classe de InputStream . Chaque classe de ﬂux\nd’entrée a son propre mode d’échange de données qui spéciﬁe un format particulier de données\nou un accès particulier. Les classes les plus couramment utilisées sont :\n●ByteArrayInputStream permet de lire le ﬂux d’entrée sous la forme d’octets ( byte);\n●DataInputStream permet de lire le ﬂux d’entrée sous la forme de types de données primi-\ntifs de Java. Il existe des méthodes pour récupérer un entier, un réel, un caractère,…\n●FileInputStream est utilisé pour lire le contenu d’un ﬁchier. Les objets de cette classe sont\nsouvent encapsulés dans un autre objet de classe InputStream qui déﬁnit le format des\ndonnées à lire.\n●ObjectInputStream permet de lire des objets (c-à-d des instances de classes Java) à par-\ntir du ﬂux d’entrée, si ces objets implémentent les interfaces java.io.Serializable ou\njava.io.Externalizable .\n●Reader n’est pas une sous-classe de InputStream mais représente un ﬂux d’entrée pour\nchaînesdecaractères.Plusieurssous-classesde Reader permettentlacréationdeﬂuxpour\nchaînes de caractères.\n●Scanner n’est pas une sous-classe de InputStream , mais un Iterator qui permet de lire\nun ﬂux (ﬁchier ou chaîne de caractères par exemple) “mot” par “mot” en déﬁnissant le\ndélimiteur entre les mots (espace par défaut).\nLa lecture de données à partir d’un ﬂux d’entrée suit le déroulement suivant :\n.Ouverture du ﬂux : Elle se produit à la création d’un objet de la classe InputStream .\nLors de l’appel au constructeur, on doit préciser quel élement externe est relié au ﬂux (par\nexemple un nom de ﬁchier ou un autre ﬂux).\n.Lecture de données : Des données provenant du ﬂux sont lues au moyen de la méthode\nread() ) ou d’une méthode équivalente. La méthode précise à employer dépend du type\nde ﬂux ouvert.\n.Fermeture du ﬂux : Quand le ﬂux n’est plus nécessaire, il doit être fermé par la méthode\nclose() .\n33\nChapitre 6. Gestion des entrées/sorties simples\n6.1.1 Lecture desentrées clavier\nLes données provenant de l’utilisation du clavier sont transmises dans un ﬂux d’entrée créé\nautomatiquement pour toute application Java. On accède à ce ﬂux par la variable statique de la\nclasse java.lang.System qui s’appelle in. Ce ﬂux est alors utilisé comme paramètre d’entrée du\nconstructeur d’un autre ﬂux d’entrée. Pour cet autre ﬂux, on utilise généralement une sous-classe\ndeReader pour récupérer les entrées de l’utilisateur sous la forme d’une chaîne de caractères. La\nclasse Clavier en donne un exemple :\nimport java.io.* ;\npublic class Clavier {\npublic static void main (String []args ){\ntry {\nBufferedReader flux =new BufferedReader (\nnew InputStreamReader (System .in));\nSystem .out.print (”Entrez votre prenom : ” );\nString prenom =flux .readLine ();\nSystem .out.println (”Bonjour ” +prenom );\nflux .close ();\n}catch (IOException ioe ){\nSystem .err.println (ioe);\n}\n}\n}\n6.1.2 Lecture àpartir d’un fichier\nUnﬁchierestreprésentéparunobjetdelaclasse java.io.File .Leconstructeurdecetteclasse\nprend en paramètre d’entrée le chemin d’accès du ﬁchier. Le ﬂux d’entrée est alors créé à l’aide\nde la classe FileInputStream sur lequel on peut lire caractère par caractère grâce à la méthode\nread() . L’exemple suivant présente une méthode pour aﬃcher le contenu d’un ﬁchier :\n34\n6.1. Flux d’entrée\nimport java.io.* ;\npublic class LectureFichier {\npublic static void main (String []args ){\ntry {\nFile fichier =new File (”monFichier.txt” );\nFileInputStream flux =new FileInputStream (fichier );\nint c;\nwhile ((c=flux .read ()) >-1){\nSystem .out.write (c);\n}\nflux .close ();\n}catch (FileNotFoundException e ){\ne.printStackTrace ();\n}catch (IOException e ){\ne.printStackTrace ();\n}\n}\n}\nIlarrivesouventd’enregistrerdesdonnéesdansdesﬁchierstextes.Ilpeutalorsêtreutiled’uti-\nliser un BufferedReader ou un Scanner pour eﬀectuer la lecture. Dans les exemples suivants, on\nconsidère une matrice 10×10enregistrée dans un ﬁchier texte matrice.txt ligne par ligne, avec\nles colonnes séparées par des espaces :\nimport java.io.* ;\npublic class LectureMatrice {\npublic static void main (String []args ){\ntry {\nFileReader fileReader =new FileReader (”matrice.txt” );\nBufferedReader reader =new BufferedReader (fileReader );\nwhile (reader .ready ()) {\nString []line =reader .readLine ().split (” ”);\nfor (String s :line ){\nSystem .out.print (s);\n}\nSystem .out.println ();\n}\nreader .close ();\nfileReader .close ();\n}catch (FileNotFoundException e ){\ne.printStackTrace ();\n}catch (IOException e ){\ne.printStackTrace ();\n}\n}\n}\n35\nChapitre 6. Gestion des entrées/sorties simples\nOn peut eﬀectuer un traitement similaire avec un Scanner :\nimport java.io.* ;\nimport java.util.Scanner ;\npublic class LectureMatriceScanner {\npublic static void main (String []args ){\ntry {\nScanner fileScanner =new Scanner (new File (”matrice.txt” ));\nwhile (fileScanner .hasNextLine ()) {\nScanner lineScanner =new Scanner (fileScanner .nextLine ());\nwhile (lineScanner .hasNext ())\nSystem .out.print (lineScanner .next ());\nSystem .out.println ();\n}\n}catch (FileNotFoundException e ){\ne.printStackTrace ();\n}\n}\n}\n6.1.3 Lecture d’objets enregistrés\nIl est parfois utile d’enregistrer l’état d’objet (de n’importe quelle classe implémentant les in-\nterfaces java.io.Serializable oujava.io.Externalizable ) pour des exécutions futures. Le\nﬂux d’entrée est encore créé à l’aide de la classe FileInputStream et est ensuite encapsulé dans\nunautreﬂuxspéciﬁantleformatdesdonnéesàlire.L’exemplesuivantillustrelalectured’unobjet\nde la classe Datedans un ﬁchier nommé monFichier.dat :\nimport java.io.* ;\nimport java.util.Date ;\npublic class LectureDate {\npublic static void main (String []args ){\ntry {\nFile fichier =new File (”monFichier.dat” );\nObjectInputStream flux =new ObjectInputStream (\nnew FileInputStream (fichier ));\nDate laDate =(Date )flux .readObject ();\nSystem .out.println (laDate );\nflux .close ();\n}catch (IOException ioe ){\nSystem .err.println (ioe);\n}catch (ClassNotFoundException cnfe ){\nSystem .err.println (cnfe );\n}\n}\n}\nL’objet qui est lu dans le ﬁchier doit être une instance de la classe java.util.Date .\n36\n6.2. Flux de sortie\n6.2 Flux desortie\nUn ﬂux de sortie est une instance d’une sous-classe de OutputStream . Comme pour les ﬂux\nd’entrée, chaque classe de ﬂux de sortie a son propre mode d’écriture de données. Les classes les\nplus couramment utilisées sont :\n●ByteArrayOutputStream permet d’écrire des octets vers le ﬂux de sortie;\n●DataOutputStream permet d’écrire des types de données primitifs de Java vers le ﬂux de\nsortie.\n●FileOutputStream est utilisé pour écrire dans un ﬁchier. Les objets de cette classe sont\nsouvent encapsulés dans un autre objet de classe OutputStream qui déﬁnit le format des\ndonnées à écrire.\n●ObjectOutputStream permet d’écrire des objets (c-à-d des instances de classes Java) vers\nleﬂuxdesortie,sicesobjetsimplémententlesinterfaces Serializable ouExternalizable .\n●Writer n’est pas une sous-classe de OutputStream mais représente un ﬂux de sortie pour\nchaînesdecaractères.Plusieurssous-classesde Writer permettentlacréationdeﬂuxpour\nchaînes de caractères.\nL’écriture de données vers un ﬂux de sortie suit le même déroulement que la lecture d’un ﬂux\nd’entrée :\n.Ouverture du ﬂux : Elleseproduitlorsdelacréationd’unobjetdelaclasse OutputStream .\n.Ecriture de données : Des données sont écrites vers le ﬂux au moyen de la méthode\nwrite() ou d’une méthode équivalente. La méthode précise à employer dépend du type\nde ﬂux ouvert.\n.Fermeture du ﬂux : Quand le ﬂux n’est plus nécessaire, il doit être fermé par la méthode\nclose() .\n6.2.1 Ecriture surlasortie standard “écran”\nCommepourlesentréesduclavier,l’écritureversl’écranfaitappelàlavariablestatique outde\nlaclasse System .Onappellegénéralementlaméthode System.out.print ouSystem.out.println\ncomme cela a été fait dans de nombreux exemples de ce livret.\n6.2.2 Ecriture dans unfichier\nL’écrituredansunﬁchiersefaitparunﬂuxdelaclasse FileOutputStream quiprendenentrée\nunﬁchier(instancedelaclasse File).Ceﬂuxdesortiepermetd’écriredescaractèresdansleﬁchier\ngrâce à la méthode write() . L’exemple suivant présente une méthode pour écrire un texte dans\nun ﬁchier :\n37\nChapitre 6. Gestion des entrées/sorties simples\nimport java.io.* ;\npublic class EcritureFichier {\npublic static void main (String []args ){\ntry {\nFile fichier =new File (”monFichier.txt” );\nFileOutputStream flux =new FileOutputStream (fichier );\nString texte =”Hello World!” ;\nfor (int i=0;i<texte .length (); i++) {\nflux .write (texte .charAt (i));\n}\nflux .close ();\n}catch (FileNotFoundException e ){\ne.printStackTrace ();\n}catch (IOException e ){\ne.printStackTrace ();\n}\n}\n}\nOn peut également utiliser un Writer comme un FileWriter pour écrire des chaînes de\ncaractères dans un ﬁchier assez simplement. Dans l’exemple suivant, on écrit une série de 10\nlignes de 10entiers aléatoires séparés par des espaces dans un ﬁchier pouvant être lu par la classe\nLectureMatrice :\nimport java.io.* ;\nimport java.util.Random ;\npublic class EcritureMatrice {\npublic static void main (String []args ){\ntry {\nFileWriter writer =new FileWriter (”random.txt” );\nRandom generator =new Random (System .currentTimeMillis ());\nfor (int i=0;i<9;i++) {\nfor (int j=0;j<9;j++)\nwriter .write (generator .nextInt ()+” ”);\nwriter .write (”\\n” );\n}\nwriter .close ();\n}catch (FileNotFoundException e ){\ne.printStackTrace ();\n}catch (IOException e ){\ne.printStackTrace ();\n}\n}\n}\n38\n6.2. Flux de sortie\n6.2.3 Ecriture d’objets\nLe ﬂux de sortie peut également être encapsulé dans un ﬂux de type ObjectOutputStream ,\ncomme le montre l’exemple suivant pour écrire la date courante dans un ﬁchier :\nimport java.io.* ;\nimport java.util.Date ;\npublic class EcritureDate {\npublic static void main (String []args ){\ntry {\nFile fichier =new File (”monFichier.dat” );\nObjectOutputStream flux =new ObjectOutputStream (\nnew FileOutputStream (fichier ));\nflux .writeObject (new Date ());\nflux .close ();\n}catch (IOException ioe ){\nSystem .err.println (ioe);\n}\n}\n}\nCe ﬁchier peut ensuite être lu par la classe LectureDate .\n*Remarque importante : Nous avons présenté dans ce chapitre plusieurs exemples d’entrée/-\nsortieutilisantdiﬀérentsmodesdelecture/écriture(avecousansﬂux).Nousconseillonstoutefois\nd’utiliseren priorité unScanner pourlalecturedansunﬁchier,etun FileWriter pourl’écriture\ndans un ﬁchier.\n39\nChapitre 6. Gestion des entrées/sorties simples\n40\nAnnexes\n41\n\nAnnexe A\nApplications graphiques (package swing )\nAnnexe\nLors des premières versions du langage Java, le seul package fourni par défaut par Java SE\npermettant de construire des interfaces graphiques était le package java.awt . Depuis la version\n. du JDK, il est très fortement recommandé d’utiliser les classes du package javax.swing pour\nécrire des interfaces graphiques. En eﬀet, le package swing apporte deux avantages conceptuels\npar rapport au package awt :\n●Lescomposantsswingsontdits“légers”( lightweight )contrairementauxcomposants“lourds”\n(heavyweight ) d’awt. L’apparence graphique d’un composant dit lourd dépend du système\nd’exploitationcarellefaitappelàuncomposantcorrespondantdanslesystèmed’exploita-\ntion.Avecuncomposantléger,sonapparence( look-and-feel )estﬁxéeetpeutêtremodiﬁée\ndans le code Java et il est donc possible de donner à une fenêtre une apparence à la Win-\ndows tout en utilisant Linux.\n●Il applique complètement le schéma Modèle-Vue-Contrôleur (cf. section A.).\nLa plupart des classes de composants du package swing héritent de classes du package awt en\nredéﬁnissantcertainesméthodespourassurerlesdeuxavantagesprécédemmentcités.Cependant,\nle package awt n’est pas entièrement obsolète et certaines de ces classes sont encore utilisées pour\nla gestion d’événements (cf. section A.) ou la disposition des composants (classes implémentant\nl’interface LayoutManager ).\nA.1 Leschéma Modèle-Vue-Contrôleur\nLe schéma Modèle-Vue-Contrôleur (MVC) est un mode de conception d’applications gra-\nphiques préconisant la distinction des données, de leur apparence graphique et des traitements\nqui peuvent être eﬀectués. Un composant graphique est décomposé en trois parties :\n●lemodèle contenant ses données et son état courant;\n●lavuequi correspond à son apparence graphique;\n●lecontrôleur associant des traitements à des événements pouvant se produire au sein du\ncomposant.\nLaﬁgure A.donneunexempled’uneinterfacegraphiquesimplecontenantunbouton“ Quitter”.\nla décomposition MVC de ce bouton (instance de la classe JButton ) est constituée : (i) du\nmodèle contenant la chaîne de caractères “ Quitter ”; (ii) de la vue constituée d’un rectangle gris\nà bord noir, d’une taille donnée, à une position donnée et au sein duquel est écrite la chaîne de\ncaractères du modèle; (iii) du contrôleur implémentant le traitement à eﬀectuer lors d’un click\nsur le bouton, c’est-à-dire l’appel à l’instruction de fermeture de la fenêtre.\nTous les composants graphiques du package swing ont un modèle, une vue et peuvent avoir\nplusieurs contrôleurs. Pour faciliter la programmation, certaines classes (tel que JButton ) encap-\nsulent le modèle et la vue dans une seule classe disposant de méthodes d’accès et de modiﬁcations\n43\nAnnexe A. Applications graphiques (package swing )\nF A. – Exemple de JButton\ndes données ou de l’apparence. Dans ces cas-là, un modèle par défaut est utilisé.\nA.2 Composants graphiques\nDans un programme Java, une classe de composant graphique est une classe qui hérite de\njava.awt.Component . Il est indispensable d’hériter de cette classe car elle implémente de nom-\nbreuses méthodes nécessaires à l’aﬃchage du composant, en renvoyant la dimension du compo-\nsant, sa police de caractères, sa couleur de fond, etc.\nLa seconde classe essentielle pour l’écriture d’interfaces graphiques est la classe Container .\nUn container est un composant (qui hérite donc de Component ) mais avec la particularité de pou-\nvoir contenir d’autres composants. Ainsi, une interface graphique est un objet d’une classe de\ntype java.awt.Container (par exemple une fenêtre ou une boîte de dialogue) regroupant des\nsimples composants et d’autres containers qui, eux aussi, contiennent d’autres simples compo-\nsants et containers, et ainsi de suite.\nA.2.1 Composants\nNous ne présentons pas ici toutes les classes de composants du package swing pour nous in-\ntéresser plutôt à la vue et au modèle de chaque composant. L’utilisation de certains composants\nest illustrée dans la section A...\nVue\nL’apparence graphique d’un composant est le résultat de l’implémentation de la méthode\npaint() de la classe Component . Quasiment toutes les classes héritant de Component redéﬁnissent\ncette méthode aﬁn de déﬁnir l’aﬃchage du composant. Si vous écrivez une classe héritant d’une\nclasse de composant existante, il est donc fortement déconseillé de redéﬁnir la méthode paint\npour la plupart des composants existants car vous empêcheriez son aﬃchage normal.\nSi vous souhaitez déﬁnir l’aﬃchage d’un composant personnalisé (par exemple pour aﬃcher\nune image ou des formes géométriques), vous devrez faire hériter votre classe de composant de la\nclasse java.awt.Canvas qui représente un composant vide. Dans ce cas-là, il est souhaitable de\nredéﬁnir la méthode paint() qui est vide dans la classe Canvas .\nModèle\nIl existe pour chaque classe de composant, une seconde classe qui gère le modèle de ce com-\nposant (par exemple, ButtonModel représente un modèle de bouton). En général un modèle par\ndéfautestcréédansleconstructeurducomposant.L’accèsàcemodèleesttrèssouventmasquécar\nilexistedesméthodes,tellesque setText() pourchangerletexted’unboutonou setSelected()\npour changer l’état d’une case à cocher, de la classe de composant qui peuvent être directement\nappelées pour changer les données du modèle. Cependant, pour des composants plus complexes\n44\nA.2. Composants graphiques\ntels que des tables ( JTable ) ou des arborescences ( JTree), il est parfois indispensable de créer un\nmodèle personnalisé.\nA.2.2 Containers\nEnpremierlieu,ilconvientderappelerqu’uncontainerestuncomposant,et,parconséquent,\nque tout ce qui a été présenté précédemment est aussi vrai pour les containers. En plus des carac-\ntéristiques d’un composant simple, un container contient un ensemble de composants ainsi que\ndes contraintes sur leur disposition. L’ajout d’un composant à un container se fait par une mé-\nthode add(). Il existe plusieurs méthodes add()acceptant des paramètres d’entrée diﬀérents. La\nméthode à utiliser dépend du type de disposition choisi.\nDisposition descomposants\nL’objet qui gère la disposition des composants est une instance d’une classe qui doit implé-\nmenter l’interface java.awt.LayoutManager . Cet objet doit être ajouté au container, soit lors de\nl’appel à son constructeur, soit par la méthode setLayout() . Un seul LayoutManager est auto-\nrisé par container. Quelques classes utilisées pour la disposition des composants sont présentées\nci-dessous.\nBorderLayout .Le container est découpé en cinq cases : une case par côté (gauche, droite, haut\net bas) et une au centre. L’ajout d’un composant se fait en précisant la case à utiliser grâce à des\nvariables de classe de BorderLayout :\nMyContainer .add(MyComponent ,BorderLayout .NORTH );\nMyContainer .add(MyComponent2 ,BorderLayout .CENTER );\nLa taille de chaque case dépend : (i) de la largeur maximale entre la case du nord, du sud et\nl’addition des largeurs des cases du centre, de l’est et de l’ouest; (ii) de la hauteur maximale entre\nla case à l’est, à l’ouest et l’addition des hauteurs des cases du centre, du nord et du sud. La case\ndu centre est étirée pour remplir tout l’espace restant.\nBorderLayout.NORTH\nBorderLayout.CENTER\nBorderLayout.SOUTHBorderLayout.WEST BorderLayout.EAST\nF A. – Découpage du BorderLayout\n45\nAnnexe A. Applications graphiques (package swing )\nComp1 ... Comp2 Comp3\nF A. – Découpage du FlowLayout\nComp6 Comp5 Comp8\nComp10 Comp9 Comp12Comp7\nComp11Comp2 Comp1 Comp4 Comp3\nF A. – Découpage d’un GridLayout x\nFlowLayout .Les composants sont ajoutés les uns à la suite des autres et de la gauche vers la\ndroite. Dès qu’une ligne est remplie de composants (c’est-à-dire dès que la largeur du container\nest atteinte, les composants restants sont ajoutés sur une ligne en dessous. Il n’y a pas d’autres\ncontraintes de disposition :\nMyContainer .add(MyComponent );\nGridLayout .Lecontainerestdécoupéenunegrillecomposéedencasesdetailleégale.Leconstruc-\nteur du GridLayout requiert en paramètres d’entrée le nombre de lignes et le nombre de colonnes\nde la grille. Les composants sont ajoutés les uns à la suite des autres en remplissant d’abord la\npremière ligne, puis la seconde, etc. Il n’y a pas d’autres contraintes de disposition :\nMyContainer .add(MyComponent );\nContainers classiques\nLa classe de container la plus simple est javax.swing.JPanel . Un panel est un composant\ninitialement vide auquel on va ajouter des composants suivant la disposition choisie. La dispo-\nsition peut être spéciﬁée lors de l’appel au constructeur du panel (par ex, JPanel myPanel =\nnew JPanel(new BorderLayout()); ) ou par un appel explicite à la méthode setLayout , par\nexemple :\nmyPanel .setLayout (new GridLayout (4,5));\nLes composants peuvent ensuite être ajoutés avec la méthode add()appropriée.\nUne interface graphique consiste donc en une hiérarchie de composants telle que certains\ncomposants sont des containers spéciﬁant la disposition d’autres composants. La racine de cette\n46\nA.2. Composants graphiques\nhiérarchie est également un container qui peut s’aﬃcher librement (c-à-d. sans que sa disposi-\ntion soit précisée dans un container). Parmi ces containers de haut niveau, on trouve la classe\njavax.swing.JFrame qui représente une fenêtre et javax.swing.JDialog qui représente une\nboîte de dialogue. La création d’une fenêtre suit généralement les étapes suivantes :\n.Création d’une instance de JFrame (ou d’une sous-classe).\n.Ajout des composants au panel de la fenêtre. Ce panel est accessible par la méthode\ngetContentPane() . On peut également attribuer à la fenêtre un nouveau panel par la mé-\nthode setContentPane() .\n.Calcul de la taille de la fenêtre à l’aide de la méthode pack() . Ce calcul est automatique et\nprend en compte la dimension préferrée de chaque composant ainsi que leur disposition.\n.Aﬃchage de la fenêtre par la méthode setVisible() .\nPar exemple, la ﬁgure A.(p.) est une instance d’une sous-classe de JFrame :\nimport java.awt.* ;\nimport javax.swing.* ;\npublic class ExBouton extends JFrame {\npublic ExBouton (){\nsuper ();\nJLabel label =new JLabel (”Exemple de bouton” );\nJPanel panel =new JPanel (new BorderLayout ());\npanel .add(label ,BorderLayout .NORTH );\nJButton b =new JButton (” Quitter ” );\npanel .add(b,BorderLayout .SOUTH );\nthis .setContentPane (panel );\nthis .pack ();\n}\npublic static void main (String []args ){\nExBouton bouton =new ExBouton ();\nbouton .setVisible (true );\n}\n}\nA.2.3 Exemple d’interface\nLe meilleur moyen d’apprendre à écrire des interfaces graphiques est de s’inspirer d’exem-\nples d’interfaces existantes. La ﬁgure A.est un exemple de fenêtre produit avec le code suivant la\nﬁgure.\n47\nAnnexe A. Applications graphiques (package swing )\nF A. – Exemple d’interface graphique\n48\nA.2. Composants graphiquesimport java.awt.* ;\nimport java.util.Vector ;\nimport javax.swing.* ;\nimport javax.swing.border.EmptyBorder ;\npublic class ExInterface extends JFrame {\n/**\n* Les variables pointant chaque composant sont declarees\n* en variables d’instance et en type protected. Elles\n* auraient tres bien pu etre des variables locales au\n* constructeur mais, pour des raisons pedagogiques,\n* la gestion des evenements n’est presentee que plus\n* tard (section events) dans une classe heritant\n* de ExInterface. Les variables sont de type protected\n* afin de pouvoir y accéder dans cette sous-classe.\n*/\nprotected JRadioButton button1 ,button2 ,button3 ;\nprotected JComboBox couleur ;\nprotected JTextField text ;\nprotected JButton ajout ;\nprotected JList textList ;\nprotected Vector <String >listData ;\nprotected Dessin dessin ;\npublic ExInterface (){\nsuper (”Un exemple de fenetre” );\n//le programme doit se terminer quand la fenetre est fermee\nthis .setDefaultCloseOperation (JFrame .EXIT_ON_CLOSE );\n// creation du panel gauche\nJPanel gauche =new JPanel (new GridLayout (6,1,0,5));\n// creation des cases a cocher\nJLabel label =new JLabel (”Forme:” );\nbutton1 =new JRadioButton (”Carre” ,true );\nbutton2 =new JRadioButton (”Cercle” ,false );\nbutton3 =new JRadioButton (”Triangle” ,false );\nJLabel label2 =new JLabel (”Couleur:” );\ncouleur =new JComboBox ();\ncouleur .addItem (”Bleu” );\ncouleur .addItem (”Rouge” );\ncouleur .addItem (”Vert” );\n// le groupe de bouton permet d’interdire la selection\n// de plusieurs cases en meme tempsButtonGroup group =new ButtonGroup ();\ngroup .add(button1 );\ngroup .add(button2 );\ngroup .add(button3 );\n// remplissage du panel gauche\ngauche .add(label );\ngauche .add(button1 );\ngauche .add(button2 );\ngauche .add(button3 );\ngauche .add(label2 );\ngauche .add(couleur );\n// creation du panel bas\nJPanel bas =new JPanel (new BorderLayout (0,10));\n// creation et remplissage du panel d’ajout de texte\nJPanel textPanel =new JPanel (new GridLayout (3,1,0,5));\nlabel =new JLabel (”Ajouter un texte possible:” );\ntextPanel .add(label );\ntext =new JTextField (16);\ntextPanel .add(text );\najout =new JButton (”Ajouter” );\ntextPanel .add(ajout );\n// creation du modele de la liste\nlistData =new Vector <String >();\nlistData .addElement (”Hello World” );\nlistData .addElement (”Une belle figure” );\nlistData .addElement (”Champions du monde !” );\nlistData .addElement (”A ciao, bonsoir...” );\nlistData .addElement (”Changez la couleur” );\nlistData .addElement (”J’adore Java” );\nlistData .addElement (”Allez les verts !” );\nlistData .addElement (”Ca marche” );\nlistData .addElement (”blablabla” );\n// creation de la liste\ntextList =new JList (listData );\ntextList .setSelectionMode (ListSelectionModel .SINGLE_SELECTION );\n// l’inclusion de la liste dans un JScrollPane permet\n// de la faire defiler par des ascenceurs\nJScrollPane scrollPane =new JScrollPane (textList );\nscrollPane .setPreferredSize (new Dimension (200,100));\n// remplissage du panel bas\n49\nAnnexe A. Applications graphiques (package swing )bas.add(scrollPane ,BorderLayout .NORTH );\nbas.add(textPanel ,BorderLayout .SOUTH );\n// remplissage du panel principal\nJPanel mainPanel =(JPanel )this .getContentPane ();\nmainPanel .setLayout (new BorderLayout (10,10));\nmainPanel .add(gauche ,BorderLayout .WEST );\ndessin =new Dessin ();\nmainPanel .add(dessin ,BorderLayout .CENTER );\nmainPanel .add(bas,BorderLayout .SOUTH );\n// une bordure permet d’aerer l’affichage\nmainPanel .setBorder (new EmptyBorder (10,10,10,10));\n// calcul de la dimension de la fenetre\nthis .pack ();\n}\npublic static void main (String []args ){\nExInterface myInterface =new ExInterface ();\nmyInterface .setVisible (true );\n}\n}\n// Cette classe herite de canvas pour redéfinir la\n// methode paint. La vue est codee dans cette classe\nclass Dessin extends Canvas {\nString figure ;\nColor couleur ;\nString text ;\n// le constructeur de la classe\npublic Dessin (){\nfigure =”Carre” ;\ncouleur =Color .blue ;\ntext =”Hello World” ;\nthis .setBackground (Color .white );\n}\npublic void paint (Graphics g ){\n// un rectangle noir encadre le composant\ng.setColor (Color .black );\ng.drawRect (0,0,this .getWidth ()-1,this .getHeight ()-1);// le texte est affiche\ng.drawString (text ,10,15);\n// la couleur est choisie\ng.setColor (couleur );\n// la figure est affichee\nif(figure .equals (”Carre” )){\ng.drawRect (50,30,100,100);\n}else if(figure .equals (”Cercle” )){\ng.drawOval (50,30,100,100);\n}else {\ng.drawLine (50,130,100,30);\ng.drawLine (100,30,150,130);\ng.drawLine (50,130,150,130);\n}\n}\n// ces methodes permettent de changer le texte,\n// la couleur ou la figure a afficher\npublic void setText (String txt ){\ntext =txt;\n}\npublic void setCouleur (String coul ){\nif(coul .equals (”Bleu” )){\ncouleur =Color .blue ;\n}else if(coul .equals (”Rouge” )){\ncouleur =Color .red;\n}else {\ncouleur =Color .green ;\n}\n}\npublic void setFigure (String fig ){\nfigure =fig;\n}\n// La redéfinition de cette methode permet de specifier\n// la taille preferree du composant\npublic Dimension getPreferredSize (){\nreturn new Dimension (200,200);\n}\n}\n50\nA.3. Contrôleurs d’événements\nA.3 Contrôleurs d’événements\nLerôledescontrôleursestd’interceptercertainsévénementsetd’eﬀectueruntraitementasso-\nciéautypedel’événement.Unévénementpeutêtreproduitparunclicksurunbouton,lasélection\nd’un élément d’une liste, un déplacement de souris, la pression d’une touche du clavier, etc.\nA.3.1 Evénements\nUn événement graphique est représenté dans le langage Java comme un objet dont la classe\nhérite de java.awt.AWTEvent . Parmi les sous-classes de AWTEvent , on peut citer les plus couram-\nment utilisées :\n●ActionEvent : Se produit lorsqu’une action est eﬀectuée sur un composant. Ex : click sur\nun bouton.\n●ItemEvent :Seproduitlorsqu’unesélectionaétéeﬀectuéesuruncomposant.Ex :cochage\nd’une case.\n●KeyEvent : Se produit lorsque un événement provient du clavier. Ex : pression d’une\ntouche.\n●MouseEvent : Se produit lorsque un événement provient de la souris. Ex : déplacement de\nla souris.\n●WindowEvent : Se produit lorsqu’une action est eﬀectuée sur une fenêtre. Ex : click sur\nl’icone de fermeture d’une fenêtre.\nDes méthodes sont attachées à chacune de ces classes pour avoir accès à plus de détails sur\nl’événement. On peut, par exemple, récupérer le composant source de l’événement, la position de\nla souris lors du click, etc.\nA.3.2 Interface Listener\nLe contrôleur qui intercepte un certain type d’événement doit implémenter une des interfaces\nhéritant de java.util.EventListener . L’interface à implémenter dépend du type d’événement\nà intercepter. La table A.présente les interfaces correspondant aux événements décrits ci-dessus.\nCertaines de ces interfaces demandent qu’un grand nombre de méthodes soient implémen-\ntées (par ex, WindowListener ). Des classes, appelées adapter , implémentant ces interfaces sont\nproposées dans l’API, pour lesquelles toutes les méthodes ont des implémentations vides. Cette\nfacilité de programmation permet de n’implémenter que la méthode souhaitée. Par exemple, on\nutilisera la classe WindowAdapter pour implémenter un traitement à eﬀectuer à la fermeture d’un\nfenêtre (méthode windowClosing() ) sans avoir à écrire des méthodes vides pour tous les autres\ncas où aucun traitement n’est requis.\nAprès la création d’un objet contrôleur, il est nécessaire de le rattacher à un ou plusieurs com-\nposants. Le contrôleur intercepte uniquement les événements des composants auquel il est ratta-\nché.Cetteopérationsefaitparl’appelàuneméthodeducomposantdelaforme add...Listener .\nPar exemple, le rattachement d’un contrôleur myActionListener à un bouton s’écrit :\nmyButton .addActionListener (myActionListener );\nA.3.3 Exemple decontrôleur\nDans l’exemple donné plus loin, des traitements ont été associés aux diﬀérents composants\nde l’interface présentée en section A... Les contrôleurs ont été volontairement créés de manière\ndiﬀérente pour illustrer plusieurs cas :\n51\nAnnexe A. Applications graphiques (package swing )\nT A. – Quelques interfaces pour contrôleur\nContrôleur Evénement Méthodes à implémenter\nActionListener ActionEvent -actionPerformed(ActionEvent)\nItemListener ItemEvent -itemStateChanged(ItemEvent)\nKeyListener KeyEvent -keyPressed(KeyEvent)\n-keyReleased(KeyEvent)\n-keyTyped(KeyEvent)\nMouseListener MouseEvent -mouseClicked(MouseEvent)\n-mouseEntered(MouseEvent)\n-mouseExited(MouseEvent)\n-mousePressed(MouseEvent)\n-mouseReleased(MouseEvent)\nWindowListener WindowEvent -windowActivated(WindowEvent)\n-windowClosed(WindowEvent)\n-windowClosing(WindowEvent)\n-windowDeactivated(WindowEvent)\n-windowDeiconified(WindowEvent)\n-windowIconified(WindowEvent)\n-windowOpened(WindowEvent)\n●lecontrôleur de la fenêtre est un objet instancié à partir d’une classe WindowControler\nqui hérite de la classe WindowAdapter . Le seul traitement qui est précisé est de quitter le\nprogramme quand l’utilisateur clique sur le bouton de fermeture.\n●lecontrôleur des boutons de choix estutilisésurplusieurscomposants.Iltraitelesévéne-\nmentsprovenantdesboutons JRadioButton etJComboBox .Cecontrôleurestuneinstance\ndeChoiceControler qui implémente l’interface ItemListener . Le traitement eﬀectué est\nune mise à jour du dessin.\n●lecontrôleur de la liste est en fait le même objet que celui représentant la fenêtre. C’est la\nclasse ExControleur qui implémente l’interface ListSelectionListener et met à jour le\ndessin à chaque fois que la sélection de la liste change.\n●lecontrôleur de la zone de texte est aussi implémenté par l’objet fenêtre. Si la touche\n“entrée” est pressée dans la zone de texte, la liste est mise à jour.\n●lecontrôleur du bouton a une forme un peu spéciale mais fréquemment utilisée. Il est\npossible,enJava,deredéﬁniruneméthoded’uneclassependantuneinstanciation.Lorsde\nl’instanciation du contrôleur ( new ActionListener() ), la méthode actionPerformed()\nest redéﬁnie directement avant le point virgule de ﬁn d’instruction. C’est le seul cas où\nl’instanciation d’une interface est permise si toutes ses méthodes sont implémentées.\n52\nA.3. Contrôleurs d’événementsimport java.awt.event.* ;\nimport javax.swing.* ;\nimport javax.swing.event.* ;\npublic class ExControleur extends ExInterface\nimplements ListSelectionListener ,ActionListener {\npublic ExControleur (){\n// appel au constructeur de ExInterface pour creer la\n// fenetre et ses composants\nsuper ();\n// ajout d’un contrôleur à la fenêtre\nthis .addWindowListener (new WindowControler ());\n// Un contrôleur unique est créé pour les boutons\n// de choix\nChoiceControler controleur =new ChoiceControler (dessin );\nbutton1 .addItemListener (controleur );\nbutton2 .addItemListener (controleur );\nbutton3 .addItemListener (controleur );\ncouleur .addItemListener (controleur );\n// le role de contrôleur pour la liste et le champ de\n// texte est assure par l’objet courant ExControleur\ntextList .addListSelectionListener (this );\ntext .addActionListener (this );\n// Le controleur du bouton est ecrit directement dans\n// la classe\najout .addActionListener (new ActionListener (){\npublic void actionPerformed (ActionEvent e ){\nString str =text .getText ();\nif(str.length ()>0){\nlistData .addElement (text .getText ());\ntext .setText (””);\ntextList .setListData (listData );\n}\n}\n});\n}\n// Cette methode est appelee si la selection de la liste\n// change\npublic void valueChanged (ListSelectionEvent e ){\nString selected =(String )textList .getSelectedValue ();// Le texte affiche est mis a jour en fonction de la\n// nouvelle selection\nif(selected !=null ){\ndessin .setText (selected );\n}else {\ndessin .setText (””);\n}\ndessin .repaint ();\n}\n// Cette methode est appelee si la touche entree est\n// pressee dans le champ de texte\npublic void actionPerformed (ActionEvent e ){\nString str =text .getText ();\n// Le texte du champ est ajoute à la liste des textes\nif(str.length ()>0){\nlistData .addElement (text .getText ());\ntext .setText (””);\ntextList .setListData (listData );\n}\n}\n// Le main doit etre redefinie pour creer un objet de la\n// classe ExControleur et non ExInterface\npublic static void main (String []args ){\nExControleur myControleur =new ExControleur ();\nmyControleur .setVisible (true );\n}\n}\n// Une classe de controleur de fenetre\nclass WindowControler extends WindowAdapter {\npublic void windowClosing (WindowEvent e ){\nSystem .exit (0);\n}\n}\n// Une classe pour le controle des boutons de choix.\n// Cette classe est utilisee pour les JRadioButton et}\n// le JComboBox\nclass ChoiceControler implements ItemListener {\nDessin dessin ;\n// Il est necessaire que le dessin soit passe en parametre\n// pour sa mise a jour apres un evenement.\n53\nAnnexe A. Applications graphiques (package swing )public ChoiceControler (Dessin d ){\ndessin =d;\n}\n// Cette méthode est appelee si la selection d’un bouton\n// change\npublic void itemStateChanged (ItemEvent e ){\n// On teste que l’evenement est bien une selection\nif(e.getStateChange ()==ItemEvent .SELECTED ){\n// traitement à effectuer si l’evenement s’est\n// produit sur un JRadioButton\nif(e.getSource ()instanceof JRadioButton ){\ndessin .setFigure (((JRadioButton )e.getItem ()). getText ());\n}// traitement a effectuer si l’evenement s’est\n// produit sur un JComboBox\nelse if(e.getSource ()instanceof JComboBox ){\ndessin .setCouleur ((String )e.getItem ());\n}else {\nSystem .err.println (”Erreur - composant non valide” );\n}\ndessin .repaint ();\n}\n}\n}\n54\nAnnexe B\nDiagramme de classes UML\nUML ( Uniﬁed Modeling Language ) a été créé en  pour être le langage standard de modé-\nlisation orienté-objet. UML contient diﬀérents diagrammes utilisés pour décrire de nombreux\naspects du logiciel. Dans le cadre de ce cours, nous utiliserons uniquement le diagramme de\nclasses ¹.\nLe diagramme de classes représente la structure statique du logiciel. Il décrit l’ensemble des\nclassesquisontutiliséesainsiqueleursassociations. IlestinspirédesdiagrammesEntité-Relation\nutilisésenmodélisationdebasesdedonnées,enyajoutantlesaspectsopérationnels(lesméthodes)\net quelques subtilités sémantiques (la composition, par exemple).\nB.1 Représentation desclasses etinterfaces\nB.1.1 Lesclasses\nEn UML, une classe est au minimum décrite par un nom. Graphiquement, elle est représentée\npar un rectangle, éventuellement divisé en  parties : son nom, ses attributs et ses opérations. On\nappelle membres de la classe ses attributs et méthodes (ou opérations).\nNom de classeNom de classeOpérationOpérationAttributAttributNom de classe\nF B. – Représentations UML possible d’une classe, avec ou sans les membres\nB.1.2 Lesmembres declasse\nChaque attribut est décrit au moins par un nom(unique dans une même classe) et par un type\nde données .\nUne opération, ou méthode, est décrite au moins par un nom, par un ensemble d’ arguments\nnécessaires à son invocation et par un type de retour . Chaque argument est décrit par un nom\net un type de données.\n.le langage UML pourra être étudié en profondeur lors du cours Analyse et Conception de Systèmes Informa-\ntiques de l’axe Ingénierie des Systèmes Informatiques\n55\nAnnexe B. Diagramme de classes UML\nUn niveau de visibilité est également attribué à chaque membre. La visibilité d’un membre\nd’une classe déﬁnit quelles autres classes y ont accès (en terme de lecture/écriture). UML utilise \nniveaux de visibilité :\n●public (noté par +), le membre est visible par toutes les classes\n●privé(noté par -), le membre n’est visible par aucune classe sauf celle qui le contient\n●protégé (notépar),lemembreestvisiblepartouteslessous-classesdecellequilecontient\n(cette visibilité est expliquée ultérieurement)\n+ calculerDureePret() : int+ getAge() : int+ surnom : String- nom : String- prenom : String# dateNaissance : DatePersonne\nF B. – Exemple de classe Personne avec attributs et opérations\nLa ﬁgure B.est un exemple d’une classe Personne avec toutes les possibilités de visibilité.\nB.1.3 Lesclasses abstraites\nEn UML, le mot-clé {abstrait} (ou{abstract} ) est accolé aux classes et méthodes abs-\ntraites. Une autre manière souvent usitée de représenter ces méthodes ou classes est d’écrire leur\nnomenitalique.Les attributs et méthodes de classe sontsoulignés.Laclasse Personne décritedans\nla ﬁgure ci-dessous montre un exemple d’attribut et de méthode de classe.\nPersonnePersonne{abstract}\nF B. – Deux représentations possibles pour une classe abstraite Personne\n+ calculerDureePret() : int+ setAgeMajorite(a : int)+ getAge() : int+ surnom : String- nom : String- prenom : String# dateNaissance : Date- ageMajorite : int = 18Personne\nF B. – Exemple d’un attribut et d’une méthode de classe pour la classe Personne\nB.1.4 Lesinterfaces\nEn UML, une interface est décrite par le mot-clé «interface» dans le bloc d’entête, comme\nprésenté dans la ﬁgure B..\n56\nB.2. Les relations\n<<interface>>Interface\nF B. – Exemple d’interface\nB.2 Lesrelations\nEn conception orientée objet, les relations englobent notamment les relations d’héritage et de\nréalisation d’interface.\nB.2.1 L’héritage\nEn UML, l’héritage se représente par une ﬂèche à la pointe creuse. La ﬁgure B.décrit deux\nclasses Super-classe etSous-classe . La classe Sous-classe héritede la classe Super-classe .\nSuper-classeSous-classe\nF B. – Exemple d’héritage\nB.2.2 Laréalisation\nLa réalisation d’une interface par une classe se représente par une ﬂèche pointillée à pointe\ncreuse, comme illustré dans la ﬁgure B..\n<<interface>>InterfaceClasse\nF B. – Exemple de réalisation de l’interface Interface par la classe Classe\nB.3 Lesassociations\nCertaines relations entre classes d’un même diagramme sont représentées en UML sous la\nforme d’ associations . Le plus souvent une association ne relie que deux classes. Une associa-\ntion peut être identiﬁée par un nom et chacune de ses extrémités déﬁnit le nombre d’instances\n57\nAnnexe B. Diagramme de classes UML\ndes classes reliées qui sont impliquées dans cette association. On appelle multiplicité ce nombre\nd’instances qui peut prendre les valeurs suivantes :\nMultiplicité Interprétation\n un et un seul\n.. zéro ou un\nN exactement N\nM..N de M à N\n* zéro ou plus\n..* zéro ou plus\n..* un ou plus\nResponsableCollaborateur*1managechefsubordonné\nF B. – Exemple d’association manage\nL’exemple de la ﬁgure B.décrit une association manage entre la classe Responsable et la\nclasse Collaborateur . Un responsable gère plusieurs collaborateurs, ses subordonnés . Un col-\nlaborateur est géré par un seul responsable, son chef. Les éléments subordonné etchefsont des\nrôlesd’association.\nB.3.1 Direction desassociations\nLes associations peuvent être dirigées , ce qui contraint la visibilité et la navigation dans le mo-\ndèle. La direction se représente par une ﬂèche classique. Par défaut, s’il n’y a pas de ﬂèche, l’asso-\nciation est bidirectionnelle (comme s’il y avait une ﬂèche à chaque extrémité de l’association).\n*1AB*1AB*1AB\nF B. – Exemples d’associations dirigées\nLa ﬁgure B.présente des exemples de directions, dont voici les interprétations. La première\nligne signiﬁe que Aconnaît tous les Bauxquels elle est associée, et réciproquement, un Bconnaît le\nAauquel il est associé. La deuxième ligne signiﬁe que seul le Aconnaît les Bauxquels il est associé,\nmais pas l’inverse. Finalement, dans la troisième ligne, un Bconnaît le Aauquel il est associé, mais\npas l’inverse. En fait, ceci va impliquer la présence ou non d’un attribut ade type Adans la classe\nBoubde type Bdans la classe Aen fonction de la direction. Par exemple, pour la deuxième ligne,\nApossède une liste d’objet de type Bmais Bne possède pas d’attribut de type A.\n58\nB.4. Correspondance UML-Java\nB.3.2 Agrégation etcomposition\nDeux sous-types d’associations permettent de préciser un sens particulier à ces relations :\nl’agrégation et la composition. Elles peuvent également être dirigées.\n*1AB*1AB*1AB*1AB\nF B. – Exemples de compositions et d’agrégations.\nL’agrégation est une association avec relation de subordination, souvent nommée possède\nreprésentée par un trait reliant les deux classes et dont l’origine se distingue de l’autre extrémité\n(la classe subordonnée) par un losange creux . Une des classes ”regroupe” d’autres classes. On peut\ndire que l’objet Autilise ou possède une instance de la classe B.\nLacomposition est une association liant le cycle de vie des deux classes concernées. Une as-\nsociation de composition s’interprète comme une classe est composée de un ou plusieurs élément\nde l’autre classe. Elle est représentée par un trait reliant les deux classes et dont l’origine se dis-\ntingue de l’autre extrémité (la classe composant) par un losange plein . On peut dire que l’objet A\nest composé instance de la classe B, et donc si l’objet de type Aest détruit, les objets de type Bqui\nle composent sont également détruit. Ce sera également souvent les objets de type Aqui créeront\nles objets de type B.\nB.4 Correspondance UML-Java\nJava permet de programmer tout modèle sous forme de diagramme de classe UML tel que\nprésentéci-dessus.VoiciquelquesexemplesdecorrespondanceentrelemodèleUMLetlecodage\nJava.\nB.4.1 Classes etmembres\n+ calculerDureePret() : int+ getAge() : int+ surnom : String- nom : String- prenom : String# dateNaissance : DatePersonne\npublic class Personne {\npublic String surnom ;\nprivate String prenom ;\nprivate String nom ;\nprotected Date dateNaissance ;\npublic int calculerDureePret (){...}\npublic int getAge (){...}\n}\nB.4.2 Classes abstraites\n59\nAnnexe B. Diagramme de classes UML\n+ calculerDureePret() : int+ setAgeMajorite(a : int)+ getAge() : int+ surnom : String- nom : String- prenom : String# dateNaissance : Date- ageMajorite : int = 18Personne\npublic abstract class Personne {\npublic String surnom ;\nprivate String prenom ;\nprivate String nom ;\nprotected Date dateNaissance ;\nprivate static int ageMajorite =18;\npublic int calculerDureePret (){...}\npublic static void setAgeMajorite (int a){...}\npublic int getAge (){...}\n}\nB.4.3 Interfaces\n+ afﬁcher()<<interface>>IAfﬁchable\ninterface IAffichable {\nvoid afficher ();\n}\nB.4.4 Héritage\n- nom : StringPersonne- iD : intAdherent\npublic class Adherent extends Personne {\nprivate int iD;\n}\nB.4.5 Réalisation\n+ afﬁcher()<<interface>>IAfﬁchable+ imprimer()<<interface>>IImprimable\n+ afﬁcher()+ imprimer()- nom : String- ﬁchier : FileImage\npublic class Image implements IAffichable ,IImprimable {\nprivate String nom ;\nprivate File fichier ;\npublic void afficher (){...}\npublic void imprimer (){...}\n}\nB.4.6 Associations\nA1B1\npublic class A1{\nprivate B1 b1 ;\n...\n}\n60\nB.4. Correspondance UML-Java\nA2B2*\npublic class A2{\nprivate ArrayList <B2>b2s;\n...\n}\nHommeFemme0..10..1mariepouse\npublic class Homme {\nprivate Femme epouse ;\n...\n}\npublic class Femme {\nprivate Homme mari ;\n...\n}\nPersonne1chef0..*subordonne\npublic class Personne {\nprivate ArrayList <Personne >subordonnes ;\nprivate Personne chef ;\n...\n}\n61\nAnnexe B. Diagramme de classes UML\n62\nRéférences\n●Livres :\n—Programmer en Java, e Edition , Claude Delannoy, Eyrolles, \n—e Java Tutorial : A Short Course on the Basics, th Edition , Collectif, Prentice Hall,\n\n—Eﬀective Java, nd Edition , Joshua Bloch, Prentice Hall, \n—Java in a nutshell, th edition , David Flanagan, O’Reilly, \n●Sites web :\n—Le site oﬃciel Java, http://www.oracle.com/technetwork/java/index.html\n—Le tutorial Java, http://docs.oracle.com/javase/tutorial/\n—l’API du JDK ., http://docs.oracle.com/javase/7/docs/api/\n—Un site (français) de développeurs, http://www.javafr.com/\n—Le site JavaWorld, http://www.javaworld.com\n●Quelques autres liens :\n—des liens en rapport avec Java, http://www.javamug.org/mainpages/Java.html\n—Tutoriaux jGuru, http://java.sun.com/developer/onlineTraining/\n—plein d’autres cours, http://java.developpez.com/cours/\n63",
  "file_type": "document",
  "original_path": "data/uploads\\module_livretJava.pdf"
}