{
  "filename": "module_LangageSQL.pdf",
  "extraction_date": "2025-09-28T12:48:50.817565",
  "statistics": {
    "word_count": 2833,
    "character_count": 19972,
    "line_count": 656
  },
  "top_keywords": [
    [
      "table",
      50
    ],
    [
      "select",
      37
    ],
    [
      "nomstation",
      35
    ],
    [
      "station",
      33
    ],
    [
      "from",
      31
    ],
    [
      "requête",
      31
    ],
    [
      "where",
      25
    ],
    [
      "prix",
      21
    ],
    [
      "exemple",
      21
    ],
    [
      "dans",
      20
    ]
  ],
  "extracted_data": {
    "emails": [],
    "urls": [],
    "dates": [
      "12/12/02",
      "14/08/00",
      "01/07/98"
    ]
  },
  "content_preview": "Le langage \nSQL \nBD pivot  \nTout au long de cette partie, nous allons utiliser la BD suivante:  \n \nStation (nomStation , capacité, lieu, région, tarif)  \nActivité (#nomStation, libellé , prix)  \nClient ( id, nom, prénom, ville, région, solde)  \nSéjour (#idClient, #station, début , nbPlaces)  \n \nidClient  station  début  nbPlaces  \n10 Passac  01/07/98  2 \n30 Santalba  14/08/00  4 \n20 Venusa  12/12/02  3 \n30 Pasac  311203  6 \nid nom  prénom  ville région  solde  \n10 Fogg  Phileas  Londres  Europe ...",
  "full_content": "Le langage \nSQL \nBD pivot  \nTout au long de cette partie, nous allons utiliser la BD suivante:  \n \nStation (nomStation , capacité, lieu, région, tarif)  \nActivité (#nomStation, libellé , prix)  \nClient ( id, nom, prénom, ville, région, solde)  \nSéjour (#idClient, #station, début , nbPlaces)  \n \nidClient  station  début  nbPlaces  \n10 Passac  01/07/98  2 \n30 Santalba  14/08/00  4 \n20 Venusa  12/12/02  3 \n30 Pasac  311203  6 \nid nom  prénom  ville région  solde  \n10 Fogg  Phileas  Londres  Europe  12465  \n20 Pascal  Blaise  Paris  Europe  6763  \n30 Kerouac  Jack  New York  Amérique  9812  Client  Séjour  NomStation  capacité  lieu région  tarif \nVenusa  350 Guadeloupe  Antilles  1200  \nSantalba  150 Martinique  Antilles  2000  \nPassac  400 Alpes  Europe  1000  Station  \nNomStation  libellé  prix \nVenusa  Voile  150 \nVenusa  Plong ée 120 \nPassac  Ski 200 \nPassac  Piscine  20 \nSantalba  Kayac  50 Activité  \nIntroduction à SQL  \nLangage déclaratif qui permet de faire des opérations \n(consultation, modification,etc) sur une BD sans se soucier de la \nreprésentation interne (physique) des datas, de leur localisation \net des chemins d’accès  \n \nSQL ne permet pas de faire de la programmation et doit donc être \nassocié avec un langage comme le C ou JAVA pour réaliser des \ntraitements complexes accédant à une BD  \n \nNous allons étudier la variante du langage SQL pour Oracle  \nSQL \nSQL se subdivise en 5 sous - langages:  \n \nLangage d’interrogation de la base : permet de \nconsulter les datas de la BD  \n \nLangage de Manipulation des Datas (LMD): \najout, modification et suppression de la BD  \n \nLangage de Définition des Datas (LDD) : \ncréation, modification et suppression des \nstructures des  différents objets de la BD  \n \nLangage de Contrôle des Transactions  \n \nLangage de Contrôle de Datas (LCD) : gestion \ndes protections d’accès   \n \n\nLDD – Création de table  \nSQL>    CREATE TABLE  nomTable (  \n            attribut1  Type1  [NOT NULL | NULL ], \n …., \n attributN   TypeN   [DEFAULT  value ] ) ; \n \n[ ]: Tous les paramètres qui sont entre crochets sont facultatifs  \nLes types autorisés:  \n\nCréation de table - Contraintes \nd’intégrité…  \nPour assurer le maintien de la cohérence des données de la base, \nnous devons définir des contraintes d’intégrité  \n \nLes contraintes d’intégrité sont:  \n Primary key  \n Foreing key  \n Unique  \n Check  \n NOTNULL  \n \nLes mots clés de la contrainte Foreing key  \nForeign key :  défini la colonne qui sera considérée comme FK  \nREFERENCES:  permet d’identifier la table et la colonne dans la table maître  \nON DELETE CASCADE:  supprime les enregistrements de la table esclave \nassociés à l’enregistrement de la table maître supprimé  \nON DELETE SET  NULL  : remet à null les valeurs de la FK  \nCréation de table - Contraintes d’intégrité  \nLes contraintes sont définies  \n Lors de la création de la table (CREATE TABLE) au niveau \n colonne ou au niveau table  \n \n Ou lors d’une modification de la structure du  table (ALTER \n TABLE)  \n \nContraintes d’intégrité définies au niveau \ncolonne …  \nSQL>    CREATE TABLE  nomTable  ( \n            attribut1  Type1  PRIMARY KEY , \n attribut2  Type2  [NOT NULL  | NULL ], \n attribut3  Type3  CHECK(condition) , \n attribut4  Type4  UNIQUE , \n …., \n attributN   TypeN   FOREIGN KEY REFERENCES \n nomTable2(attribut21)  ON DELETE CASCADE ) ; \n \nExemple1 : Station ( nomStation , capacité, lieu, région, tarif)  \n \nSQL>    CREATE TABLE  Station (  \n             nomStation  varchar (15) PRIMARY KEY , \n  capacité  number (4), \n  lieu varchar2(20)  NOT NULL , \n  région  varchar2(30)  CHECK( région  in (‘Antilles ’,’Europe ’)), \n  tarif real DEFAULT  0) ; \nContraintes d’intégrité définies au niveau \ncolonne  \nExemple2 : Activité ( #nomStation, libellé , prix)  \n \nSQL>    CREATE TABLE  Activité (  \n             nomStation  varchar2(15)   PRIMARY KEY , \n  libellé  varchar2(15)  PRIMARY KEY , \n  prix number(4)  NOT NULL  \n ) ; \n \nCet ordre SQL est -il correct?  \n \nCet ordre n’est pas correct car on ne peut pas définir 2 clés primaires sur la \nmême table  \n \nComme notre clé est considérée comme une clé composée alors on doit \ndéfinir la contrainte au niveau table  \n \n \nContraintes d’intégrité définies au niveau \ntable  \nSQL>    CREATE TABLE  nomTable (  \n            attribut1  Type1,  \n attribut2  Type2  [NOT NULL  | NULL ], \n …., \n attributN   TypeN ,  \n CONSTRAINT  nom_contrainte  PRIMARY KEY( attribut1 ), \n    CONSTRAINT  nom_contrainte  CHECK(condition),  \n  CONSTRAINT  NomContrainte  FOREIGN KEY ( attributN ) \n REFERENCES nomTable2(attribut21)  ON DELETE  CASCADE ) ; \n \nSolution de l’exemple2 : Activité ( #nomStation, libellé , prix)  \n \nSQL>   CREATE TABLE  Activité (  \n             nomStation  varchar2(15),  \n  libellé  varchar2(15),  \n  prix number(4)  NOT NULL,  \n CONSTRAINT  activité_PK  PRIMARY KEY( nomStation,libellé ), \n    CONSTRAINT  activité_FK  FOREIGN KEY ( nomStation ) REFERENCES \n Station(nomStation)  ON DELETE CASCADE ) ; \nContraintes d’intégrité définies après la \ncréation de la table  \nAjout de contrainte  \n \nSQL>    ALTER TABLE  Activité  \n            ADD CONSTRAINT  activité_FK  FOREIGN KEY  (nomStation ) \n REFERENCES  Station(nomStation)  ; \n \nSuppression de contrainte   \n \nSQL>    ALTER TABLE  table  \n            DROP PRIMARY KEY | UNIQUE(column) | CONSTRAINT  \n nom_contrainte  [CASCADE] ; \n \n \nSQL>    ALTER TABLE  Activité  \n            DROP CONSTRAINT  activité_FK  ; \n \n\nALTER TABLE  \nOutre la possibilité d’ajouter ou de supprimer les contraintes, l’ordre \nALTER TABLE permet:  \n Ajouter une nouvelle colonne  \n Modifier une colonne existante  \n Définir une valeur par défaut pour une colonne  \n Supprimer des colonnes  \n \n \n\nSuppression de table  \nSuppression d’une table  \n les données et la structure sont supprimées  \n la transaction en cours sera validée (commit implicite)  \n les indexes sont supprimés  \n l’ordre ne peut pas être annulé  \n \nSyntaxe  \n SQL>    DROP  TABLE  nom_table ;  \n \nChangement de nom d’une table  \n pour pouvoir renommer l’objet, on doit être son propriétaire  \n \nSyntaxe  \n SQL>    RENAME  ancien_nom_table  TO nouveau_nom_table ; \n \nTRUNCATE TABLE  \nL’ordre TRUNCATE permet de  \n supprimer les données d’une table  \n  libérer l’espace associé  \n l’ordre ne peut pas être annulé  \n  \nSyntaxe  \n SQL>    TRUNCATE  TABLE  nom_table ;  \n \n \nRésumé  \n\nLDD – Pourquoi on utilise les vues?  \nLe concept de vue permet d’avoir une vision logique des datas \ncontenues dans une ou plusieurs tables  \n \nVue ou table virtuelle n’a pas d’existence propre; aucune donnée ne \nlui est associée  \n \nC’est juste la description de cette vue qui est stockée  \n \nOn utilise les vues pour une des raisons suivantes:  \nLimiter l’accès aux datas  \nRemplace le codage de requêtes complexes  \n \nDeux types de vues: simples et complexes  \n \n\nLDD – Exemple de création des \nvues  \nVue constituant une restriction de la table Client aux clients qui \nhabitent Paris  \n \n SQL>  CREATE OR REPLACE VIEW Client_vue  \n     AS SELECT *  \n             FROM Client  \n        WHERE ville=‘Paris’;  \n \nSyntaxe de Suppression d’une vue  \n SQL>   DROP VIEW nom_vue ;   \n  \nSyntaxe de changement de nom d’une vue  \n SQL>   RENAME ancien_nom_vue TO nouveau_nom_vue;  \n \nLDD – Les utilisateurs  \nTout accès à la base s’effectue par la notion d’utilisateur (compte \nORACLE)  \n \nAvant de pouvoir créer les objets (table, vue, index, etc…), nous \ndevons créer pour chaque utilisateur un compte dans lequel il va \ngérer ces différents objets  \n \nChaque USER est défini par:  \n Un nom utilisateur, Un mot de passe,  Un ensemble de \n privilèges, Un profil  \n \n \nLDD – Syntaxe de création d’un user  \nSQL>    CREATE USER  nom_user  \n            IDENTIFIED {BY  password  | EXTERNALLY}  \n            [DEFAULT TABLESPACE  nomTablespaceD ] \n  [TEMPORARY TABLESPACE  nomTablespaceT ] \n  [ QUOTA { entier [K|M] | UNLIMITED} ON  nomTablespace ] \n [ PASSWORD EXPIRE  ] \n  [ ACCOUNT {LOCK | UNLOCK}  ] \n  [ PROFILE { nomProfil  | DEFAULT}  ] ; \n \nUNLIMITED: permet de spécifier que les objets d’un user peuvent utiliser \nautant d’espace qu’il y en a dans le tablespace  \n \nPASSWORD EXPIRE: oblige l’user à réinitialiser le password lorsqu’il se \nconnecte à la BD par l’intermédiaire de SQL*PLUS (valable juste lors de \nl’authentification par le Serveur Oracle)  \n \nACCOUNT {LOCK | UNLOCK}: verrouiller/déverrouiller explicitement le \ncompte user  \n \nLDD – Exemple de création d’un \nuser  \nCréer un compte Oracle dans le nom d’utilisateur est TSI3 et son \npassword est TSI3PASS  \n \nSQL>    CREATE USER TSI3  \n            IDENTIFIED BY TSI3PASS  ; \n \nCréer un compte Oracle dans le nom d’utilisateur est TSI3, son \npassword est TSI3PASS et qui sera bloqué  \n \nSQL>    CREATE USER TSI3  \n            IDENTIFIED BY TSI3PASS  \n ACCOUNT LOCK ; \n \nAccès aux datas - SELECT  \nUn ordre SELECT permet d’extraire des informations d’une BD  \n \nL’utilisation d’un ordre SELECT offre les possibilités suivantes :  \nSélection :  SQL permet de choisir dans une  table, les lignes que l’on \nsouhaite ramener au moyen d’une requête. Divers critères de sélection sont \ndisponibles à cet effet  \n \nProjection :   SQL permet de choisir dans une table, les colonnes que l’on \nsouhaite ramener au moyen d’une requête. Vous pouvez déterminer autant de \ncolonnes que vous le souhaitez  \n \nJointure :  SQL permet de joindre des données stockées dans différentes \ntables, en créant un lien par le biais d’une colonne commune à chacune des \ntables  \n \n\nBasic SELECT  \nPour restreindre les lignes, on utilise la clause Where  \n \n \n \n \n \n \nExemple 2 :  \n on souhaite extraire de la base les libellés des activités offerts par la \nstation Santalba et dont le prix est compris entre 50$ et 120$  \n \nRequête 2 :  \n SQL>   SELECT nomStation,libelle  \n  FROM Activite  \n  WHERE nomStation = ’Santalba’  \n  AND (prix > 50 AND prix < 120);  \n  \n SQL>   SELECT nomStation,libelle  \n  FROM Activite  \n  WHERE nomStation = ’Santalba’  \n  AND prix BETWEEN  50 AND 120;   \n \nBasic SELECT  \nExemple 31 :  \n Quels sont les stations dont on ne connaît pas leurs \n emplacements  \n \nRequête 31 : \n SQL>    SELECT nomStation  \n  FROM Station  \n  WHERE region  IS NULL;   \nExemple 32 :  \n Quels sont les stations dont on connaît leurs \n emplacements  \n \nRequête 32 : \n SQL>    SELECT nomStation  \n  FROM Station  \n  WHERE region  IS NOT NULL;  \n \nBasic SELECT  \nRemarques :  \n \n Les opérateurs de comparaison sont ceux du Pascal : <, \n >, =, <=, >=, !=  \n \n Il faut être attentif aux différences entre chaînes de \n longueur fixe et chaînes de longueur variable. Les  \n premières sont complétées par des blancs (’ ’) et pas les \n secondes  \n  \n Si SQL ne distingue pas majuscules et minuscules pour \n les mot -clés, il n’en va pas de même pour les valeurs. \n Donc ’SANTALBA’ est différent de ’Santalba’  \n \nBasic SELECT  \nLes patterns matching (les recherches par motif) :  \nSQL fournit des options pour les recherches par motif à l’aide \nde la clause LIKE  \n \nLe caractère ’_’ désigne n’importe quel caractère, et le ’%’ \nn’importe quelle chaîne de caractères  \n \n \nExemple 4 :   \n Chercher toutes les stations dont le nom termine par un ’a’  \n \nRequête 4 :  \n SQL>    SELECT nomStation  \n  FROM Station  \n  WHERE nomStation   LIKE   ’%a’; \n \nTri des données  \n \n\nJointure – Requêtes sur plusieurs \ntables  \nEn extrayant des données provenant de plusieurs tables, nous devons \nles joindre. Plusieurs types de jointures sont définis selon la nature de \nla condition:  \n une équi jointure ou jointure :  permet de réaliser une liaison \n logique entre 2 tables (l’égalité entre la CP d’une table et la CE \n de l’autre)  \n une inéquijointure ou thêtajointure :  est une jointure dont \n l’expression du pivot utilise des opérateurs autre que \n l’égalité(<,>,!=,>=,<=, BETWEEN)  \n  \nEqui jointure  \nExemple 7:  Donner le nom des clients avec le nom des stations où ils ont séjourné  \n \nRequête 7: SQL>  SELECT nom, station  \n FROM   Client,  Sejour  \n WHERE id = idClient  ; \n \nExemple 8:  Ambiguïté sur la provenance de l’attribut  \n Afficher le nom d'une station, son tarif  hebdomadaire, ses activités et \nleurs prix.  \nRequête 8a: SQL>  SELECT nomStation, tarif, libelle, prix  \n  FROM  Station,Activite  \n  WHERE Station.nomStation = Activite.nomStation ;  \nRequête 8b:  Définition de synonyme  \n SQL>  SELECT nomStation, tarif, libelle, prix  \n FROM  Station S, Activite A \n WHERE S.nomStation = A.nomStation ; \n \nSI on exrait des informations provenant de n tables, nous devons \navoir au moins (n -1) conditions de jointures  \nRequêtes sur plusieurs tables…  \nOn construit  deux  requêtes  dont  les résultats  ont même  arité  \n(même  nombre  de colonnes  et mêmes  types  d'attributs),  et on \nles relie par un des mots -clef UNION,  INTERSECT  ou EXCEPT  \n \nExemple 11:  \n Donnez tous les noms de région dans la base.  \nRequête 11:  \n SQL>   SELECT  region FROM   Station  \n UNION  \n SELECT  region FROM   Client  ; \nExemple 12:  \n Donnez les régions où l'on trouve à la fois des clients et des \n stations.  \nRequêtes sur plusieurs tables  \nRequête 12:  \n SQL>   SELECT  region FROM   Station  \n INTERSECT  \n SELECT  region FROM   Client  ; \nExemple 13:  \nQuelles  sont  les régions  où l'on trouve  des stations  mais  pas \ndes clients  ? \nRequête 13:  \n   \n SQL>   SELECT  region FROM   Station  \n EXCEPT  \n SELECT  region FROM   Client  ; \nRequêtes imbriquées  \nSQL offre  la possibilité  d'exprimer  des conditions  sur des relations  \n \nCes relations  sont  construites  par une requête  SELECT  ... FROM  ... \nWHERE  que l'on appelle  sous -requête  ou requête  imbriquée . \n \nExemple 14:  \n  on veut les noms des stations où ont séjourné des clients \n parisiens.  \nRequête 14a: \n SQL>   SELECT  station  FROM   Sejour, Client  \n WHERE  id=idClient AND  ville = 'Paris'  ;  \nRequête 14b:  \n SQL>   SELECT  station FROM  Sejour  \n  WHERE  idClient  IN (SELECT  id  \n                                       FROM  Client                                \n               WHERE  ville = 'Paris') ;   \nOn peut  remplacer  le IN par un simple  '=' si on est sûr que la \nsous -requête  ramène  un et un seul tuple .  \nRequêtes imbriquées – Formes de \nconditions  \n Exemple  15: \n  Quelle station pratique le tarif le plus élevé ?  \nRequête 15:  \n SQL>   SELECT  nomS tation  \n  FROM   Station  \n WHERE  tarif >= ALL (SELECT  tarif FROM  Station)  ;  \n \nExemple 16:  \n  Dans quelle station pratique -t-on une activité au même prix \n qu’à Santalba ?  \nRequête 16:  \n SQL>   SELECT  nomS tation, libelle  \n  FROM   Activite  \n WHERE  prix IN ( SELECT  prix  \n               FROM  Activite  \n               WHERE nomStation = ’Santalba’ ) ;  \nAgrégation  \nLes fonctionnalités  d'agrégation  de SQL permettent  : \n d'exprimer  des conditions  sur des groupes  de \n tuples,  \n \n  et de constituer  le résultat  par agrégation  de \n valeurs  au sein de chaque  groupe .  \n \nLa syntaxe  SQL fournit  donc  : \n Le moyen  de partitionner  une relation  en groupes  selon  \n certains  critères . \n \n Le moyen  d'exprimer  des conditions  sur ces groupes . \n             Des fonctions  d'agrégation . \n \nFonctions d’Agrégation…  \nCes fonctions  s'appliquent  à une colonne,  en général  \nde type numérique  \n         COUNT  qui compte  le nombre  de valeurs  non nulles  \n           MAX  et MIN \n          AVG  qui calcule  la moyenne  des valeurs  de la colonne  \n         SUM  qui effectue  le cumul  \n VARIANCE  calcule  la variance  \n STDDEV  calcule  l’écart  type \n \nRemarques  importantes : \nPour  le type DATE  et chaîne  de caractère,  on peut  utiliser  \nseulement  les fonctions  COUNT,  MIN et MAX  \n \nToutes  les fonctions,  excepté  COUNT,  ignorent  les valeurs  NULL  \n \nFonctions d’Agrégation…  \nRequête  17: \n SQL>   SELECT  COUNT (nomStation), AVG(tarif), MIN(tarif), MAX (tarif)  \n  FROM  Station  ; \n \nRemarque  importante : \nImpossible  d’utiliser  simultanément  dans  la clause  SELECT  des fonctions  d'agrégation  et \ndes noms  d'attributs  (sauf  dans  le cas d'un GROUP  BY) \n \nLa requête  suivante  est incorrecte . \n SQL>   SELECT  nomStation,  AVG(tarif)  \n  FROM  Station  ; \n \nDans la requête 17, on appliquait la fonction d'agrégation à l'ensemble du résultat d'une \nrequête. Une fonctionnalité complémentaire consiste à partitionner ce résultat en groupes, \net à appliquer la ou les fonction(s) à chaque groupe  \n \n Exemple 18:  \n  afficher les régions avec le nombre de stations.  \n \nRequête 18:  \n  SQL>   SELECT  COUNT (nomStation), région  \n  FROM  Station  \n  GROUP BY  region;  \nFonctions d’Agrégation  \nOn peut  faire  porter  des conditions  sur les groupes  avec  la \nclause  HAVING  \n \nLa clause  WHERE  ne peut  exprimer  des conditions  que sur les \ntuples  pris un à un \n  \n Exemple  19: \n  on souhaite consulter le nombre de places réservées, par \nclient, pour les clients ayant réservés plus de 10 places  \n \nRequête 19:  \n  SQL>   SELECT  nom, SUM  (nbPlaces)  \n  FROM  Client, Sejour  \n  WHERE  id = idClient  \n  GROUP BY  nom  \n  HAVING SUM (nbPlaces) >= 10;  \nRésumé  \n\nLMD - Insert  \nSyntaxe:  \n SQL>   INSERT INTO   Table  (A1,.........,An) \n VALUES   (V1,......... ,Vn); \nTable  est le nom  d'une  table  \n \n A1,.........,An sont les noms des attributs dans  lesquels on \n souhaite placer une valeur. Les autres  attributs seront \n donc a NULL (ou a la  valeur par  defaut). Tous les \n attributs spécifiés NOT NULL (et  sans valeur par défaut) \n doivent donc figurer dans  une clause INSERT.  \n \n V1,.........,Vn sont les valeurs des attributs  \nExemple 20:  \n SQL>   INSERT INTO   Client  (id, nom, prenom)  \n VALUES   (40,’MORIARTY’,’Dean’ ),  \n                               (41,’MARTY’,’Jean’ ); \nDonc, à l’issue de cette insertion, les attributs ville et region \nseront à NULL  \n \nLMD - Insert  \nOn peut aussi insérer dans une table le résultat d’une \nrequête.  \n \nLe nombre d’attributs et le type de ces derniers issus de la \nrequête doivent être cohérents avec ceux de la table dont on \nva insérer les valeurs.  \n \nSyntaxe:  \n SQL>   INSERT INTO   R (A1,.........,An) \n SELECT ...; \n \nExemple 21:   \n on a créé une table Sites (lieu,région) et on souhaite \n y copier les couples (lieu, région) déjà existant dans \n la table Station.  \n \nRequête 21:  \n SQL>   INSERT INTO  Sites (lieu, region)  \n  SELECT  lieu, region FROM  Station;  \n \nLMD - Update, Delete  \nSyntaxe:  \n SQL>   DELETE FROM   table  \n  [WHERE condition ]; \nExemple 22:  \n Supprimer tous les clients dont le nom commence par ’M’.  \n \nRequête 22:  \n SQL>   DELETE FROM  Client  \n  WHERE nom LIKE  'M%‘;  \n \nSyntaxe:  \n SQL>   UPDATE  Table  \n         SET A1=v1, …, An=vn  \n         [WHERE condition ]; \nExemple 23:  \n Augmenter le prix des activités de la station Passac de 10%.  \n \nRequête 23:  \n SQL>   UPDATE Activité  \n  SET prix=prix*1.1  \n  WHERE nomStation=‘Passac’;  \nLMD - remarques  \nToutes les mises -a-jour (insert, update, delete) ne \ndeviennent définitives qu‘à l'issue d'une validation par \ncommit.  \nEntre -temps elles peuvent être annulées par rollback .  \nExemple 24:   \n SQL>   UPDATE Activité  \n  SET prix=prix*1.1  \n  WHERE nomStation=‘Passac’;  \n SQL>     COMMIT;  \n SQL>   DELETE FROM  Client  \n  WHERE nom LIKE  'M%‘;  \n SQL>     ROLLBACK;  \n SQL>   INSERT INTO   Client  (id, nom, prenom)  \n VALUES   (40,’MORIARTY’,’Dean’ ); \n SQL>     COMMIT;  \nExercices  \nDonnez l’expression SQL des requêtes suivantes:  \n \n Nom des stations ayant strictement plus de 200 places  \n \n Noms des clients dont le nom commence par ’P’ ou dont le solde \nest  supérieur à 10000  \n \n Quelles sont les régions dont l’intitulé comprend (au moins) deux \nmots ?  \n \n Nom des stations qui proposent de la plongée  \n \n Nom des clients qui sont allés à Santalba  \n \n Donnez les couples de clients qui habitent dans la même région. \nAttention :  un couple doit apparaître une seule fois  \n \n Nom des régions qu’a visité Mr Pascal  \n \n Nom des stations visitées par des européens  \n \n Qui n’est pas allé dans la station Farniente ?  \n \n Quelles stations ne proposent pas de la plongée ?",
  "file_type": "document",
  "original_path": "data/uploads\\module_LangageSQL.pdf"
}