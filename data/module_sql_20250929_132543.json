{
  "filename": "module_sql.pdf",
  "extraction_date": "2025-09-29T13:25:43.219840",
  "statistics": {
    "word_count": 17205,
    "character_count": 114997,
    "line_count": 2927
  },
  "top_keywords": [
    [
      "select",
      235
    ],
    [
      "from",
      202
    ],
    [
      "salaire",
      144
    ],
    [
      "table",
      136
    ],
    [
      "where",
      120
    ],
    [
      "dans",
      115
    ],
    [
      "nodept",
      114
    ],
    [
      "exercice",
      105
    ],
    [
      "solution",
      105
    ],
    [
      "titre",
      101
    ]
  ],
  "extracted_data": {
    "emails": [],
    "urls": [
      "http://www.grappa.univ-lille3.fr/polys/frime",
      "http://traduc.postgresqlfr.org/pgsql-fr/history.html",
      "http://www.grappa.univ-lille3.fr/polys/sql/exemples/creer_emp.sql",
      "http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M90-34.pdf",
      "http://www.grappa.univ-lille3.fr/polys/sql/exemples/remplir_dept.sql",
      "http://www.matterform.com/",
      "http://blogs.developpeur.org/neodante/archive/2005/01/22/4058.aspx",
      "http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M87-13.pdf",
      "http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M87-06.pdf",
      "http://meteora.ucsd.edu/s2k/s2k_home.html",
      "http://traduc.postgresqlfr.org/pgsql-fr/biblio.html",
      "http://fr.wikipedia.org/",
      "http://www.grappa.univ-lille3.fr/polys/sql/sql.html",
      "http://www.postgresql.org/docs/8.0/static/release.htmll",
      "http://www.in",
      "http://hcesbronlavau.developpez.com/Transactions/",
      "http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M90-36.pdf",
      "http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M89-82.pdf",
      "http://www.ibm.com/",
      "http://sqlpro.developpez.com/cours/sqlaz/techniques/",
      "http://www.grappa.univ-lille3.fr/polys/sql/book1.htm",
      "http://www.grappa.univ-lille3.fr/polys/sql/exemples/remplir_emp.sql",
      "http://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M85-95.pdf",
      "http://www.grappa.univ-lille3.fr/polys/sql/sql.pdf",
      "http://www.postgresql.org/about/press",
      "http://www.grappa.univ-lille3.fr/polys/sql/index.html",
      "http://traduc.postgresqlfr.org/pgsql-fr/preface.html",
      "http://fr.wikipedia.org/wiki/PostgreSQL",
      "http://www.informix.com/",
      "http://www.grappa.univ-lille3.fr/polys/sql/exemples/creer_dept.sql",
      "http://www.postgresqlfr.org/"
    ],
    "dates": [
      "05/05/2000",
      "12/11/2000",
      "11/01/2000",
      "07/24/2000",
      "01/22/4058",
      "03/26/2000",
      "01/10/2001",
      "12/31/2000",
      "02/19/2001",
      "5/10/2005",
      "08/13/2000",
      "07/04/2000",
      "06/14/2000",
      "04/15/2000",
      "09/22/2000",
      "11/21/2000",
      "03/11/2001",
      "03/01/2001",
      "05/25/2000",
      "03/21/2001",
      "02/09/2001",
      "01/20/2001",
      "10/12/2000",
      "09/02/2000"
    ]
  },
  "content_preview": "SQL\nDominique Gonzalez\nUniversité Lille3-Charles de Gaulle\n\nSQL\npar Dominique Gonzalez\nPublié 5/10/2005\nCopyright © 2005 D.Gonzalez\nCe document est soumis à la licence GNU FDL. Permission vous est donnée de distribuer, modiﬁer des copies de ces pages tant que\ncette note apparaît clairement.\n\nTable des matières\nI. Cours et exercices........................................................................................................................................................1\n1. Pourquoi e...",
  "full_content": "SQL\nDominique Gonzalez\nUniversité Lille3-Charles de Gaulle\n\nSQL\npar Dominique Gonzalez\nPublié 5/10/2005\nCopyright © 2005 D.Gonzalez\nCe document est soumis à la licence GNU FDL. Permission vous est donnée de distribuer, modiﬁer des copies de ces pages tant que\ncette note apparaît clairement.\n\nTable des matières\nI. Cours et exercices........................................................................................................................................................1\n1. Pourquoi et comment ?.....................................................................................................................................1\n1.1. Pourquoi ce document ? ......................................................................................................................1\n1.2. Comment a-t-il été construit ?.............................................................................................................1\n1.3. Où trouver ce document ? ...................................................................................................................1\n1.4. QBullets................................................................................................................................................1\n2. Qu’est-ce que SQL ? ...........................................................................................................................................3\n2.1. Avant-propos.........................................................................................................................................3\n2.2. Intérêt de SQL.........................................................................................................................................3\n2.3. SQL dans l’architecture en couches des SGBD..................................................................................3\n2.4. SQL : Principes d’une Base de Données Relationnelle.....................................................................4\n2.5. Architecture client-serveur et communication par SQL...................................................................5\n2.6. Structure générale du langage SQL.....................................................................................................6\n2.7. SQL : un langage algébrique ................................................................................................................7\n3. Présentation de PostgreSQL............................................................................................................................9\n3.1. Déﬁnition de PostgreSQL ...................................................................................................................9\n3.2. Bref historique de PostgreSQL ...........................................................................................................9\n3.3. PostgreSQL 8.0 est là !......................................................................................................................11\n3.4. Fonctionnalités supplémentaires dans PostgreSQL 8.0 ..............................................................12\n3.5. D’autres informations ........................................................................................................................12\n4. Une base jouet pour découvrir SQL ...............................................................................................................15\n4.1. Les tables..............................................................................................................................................15\n4.2. Quelques requêtes ..............................................................................................................................15\n5. La base EXEMPLE...............................................................................................................................................17\n5.1. La base EXEMPLE..................................................................................................................................17\n5.2. La table EMP..........................................................................................................................................17\n5.3. La table DEPT........................................................................................................................................18\n6. La commande SELECT, syntaxe de base.......................................................................................................21\n6.1. SELECT ..................................................................................................................................................21\n6.2. Suppression des doublons.................................................................................................................21\n6.3. Restriction ............................................................................................................................................22\n6.4. Restriction en comparant les colonnes entre elles..........................................................................22\n6.5. Négation, recherche approchée ........................................................................................................22\n6.6. Valeurs non renseignées.....................................................................................................................22\n6.7. Expressions arithmétiques.................................................................................................................23\n6.8. Éviter les valeurs NULL .......................................................................................................................23\n6.9. Arrondis ...............................................................................................................................................23\n6.10. Concaténation....................................................................................................................................24\n6.11. Opérateur conditionnel....................................................................................................................24\n6.12. Chaînes de caractères .......................................................................................................................24\n6.13. Opérations ensemblistes..................................................................................................................25\n7. Les jointures et les sous-requêtes ..................................................................................................................27\n7.1. Jointures ...............................................................................................................................................27\n7.2. Auto-jointures......................................................................................................................................27\n7.3. Sous-requêtes.......................................................................................................................................27\n7.4. LEFT JOIN, RIGHT JOIN ....................................................................................................................28\n8. Créer votre propre base ..................................................................................................................................31\n8.1. Créer la base ........................................................................................................................................31\n8.2. Créer les tables ....................................................................................................................................31\n8.3. Remplir les tables................................................................................................................................31\n8.4. Téléchargement...................................................................................................................................32\n9. Modiﬁcation de base, transactions, tables et vues......................................................................................35\n9.1. Transactions .........................................................................................................................................35\n9.2. Modiﬁer le contenu ............................................................................................................................36\n9.3. Vues.......................................................................................................................................................40\n10. Les droits.........................................................................................................................................................41\n11. Les groupes.....................................................................................................................................................43\n11.1. Utilisation de fonctions de groupe.................................................................................................43\n11.2. Les groupes........................................................................................................................................43\n11.3. La clause HAVING...............................................................................................................................43\n11.4. Exercices.............................................................................................................................................44\n12. Les dates .........................................................................................................................................................45\niii\n\n12.1. Généralités .........................................................................................................................................45\n12.2. Afﬁchage d’une date ........................................................................................................................45\n12.3. Calculs sur les dates .........................................................................................................................46\n13. Exercices récapitulatifs .................................................................................................................................49\nII. Solutions des exercices ..........................................................................................................................................51\n14. Réponses aux premiers exercices sur la base jouet ...................................................................................51\n15. Réponses aux premiers exercices sur la commande SELECT...................................................................53\n16. Réponses aux exercices sur les jointures et les sous-requêtes.................................................................59\n17. Réponses aux exercices sur modiﬁcation de base, etc..............................................................................63\n18. Réponses aux exercices sur les droits .........................................................................................................67\n19. Réponses aux exercices sur les groupes.....................................................................................................69\n20. Réponses aux exercices sur les dates..........................................................................................................71\n21. Réponses aux exercices récapitulatifs.........................................................................................................73\nIndex...............................................................................................................................................................................75\niv\n\nChapitre 1. Pourquoi et comment ?\n1.1. Pourquoi ce document ?\nCes pages ont pour origine un cours destiné aux étudiants de 2ème année de l’IUP IIES de l’université de\nLille III-Charles de Gaulle, à Villeneuve d’Ascq, pour les années universitaires 2002-2003 et 2003-2004.\nElles ont ensuite été un peu remaniées et augmentées à l’occasion d’un cours destiné aux étudiants de 3ème\nannée de la licence MIASHS.\nCes pages ne sont pas destinées à être un cours autonome : elles ne sont qu’un support de cours, et beaucoup\nde choses, qui sont transmises à l’oral pendant les cours, ne sont pas écrites.\nL’environnement technique du cours est constitué de machines sous linux, les bases de données étant hé-\nbergées sur un serveur PostgreSQL, lui aussi sous linux. L’installation de ces logiciels ne sera pas abordée\net ne fait pas partie du contenu du cours.\nOn n’abordera pas non plus la partie analyse (Merise, etc.) qui est pourtant foncdamentale dans le proces-\nsus de création d’une base données. Cette partie sera vue ailleurs. L’objectif de ce cours est seulement la\ndécouverte de SQL.\n1.2. Comment a-t-il été construit ?\nCe polycopié a été rédigé au format DocBook :\n• Le texte source a été écrit au format XML avec emacs, en respectant la DTD de DocBook.\n• Le code source a été compilé au format PDF avec openjade et au format HTML avec xsltproc.\n• La version que vous avez devant les yeux a été compilée le 5/10/2005 .\n1.3. Où trouver ce document ?\nCe document est disponible sous plusieurs formats sur le web:\n• Un seul document HTML : http://www.grappa.univ-lille3.fr/polys/sql/sql.html (Lourd à charger, mais\nfacile à sauvegarder ou à imprimer)\n• Plusieurs pages HTML : http://www.grappa.univ-lille3.fr/polys/sql/index.html (Plus faciles à consul-\nter)\n• Une version HTML sans feuilles de style : http://www.grappa.univ-lille3.fr/polys/sql/book1.htm (Quelle\nidée ? Mais si vous y tenez...)\n• PDF : http://www.grappa.univ-lille3.fr/polys/sql/sql.pdf\n1.4. QBullets\nLes petites images animées qui illustrent les liens de la version web de ce document proviennent de QBullets\n1\n1.\nhttp://www.matterform.com/\n1\n\nChapitre 1. Pourquoi et comment ?\n2\n\nChapitre 2. Qu’est-ce que SQL ?\n2.1. Avant-propos\nCe premier chapitre est extrait d’un polycopié réalisé par Rémi Gilleron et Marc Tommasi dans le cadre de\nleur cours sur l’ architecture client-serveur.\nJe me suis contenté d’en modiﬁer la mise en page.\nVous pouvez consulter l’original sur internet1.\nCe polycopié était lui-même fortement inspiré de l’excellent ouvrage « SQL 2 », de Christian Marée et Guy\nLedant, chez Armand Colin.\n2.2. Intérêt de SQL\nTous les systèmes de gestion de données utilisent SQL pour l’accès aux données ou pour communiquer avec\nun serveur de données. SQL (Standard Query Language) est né à la suite des travaux mathématiques de\nCodd, travaux qui ont fondé les bases de données relationnelles. SQL, déﬁni d’abord chez IBM, a subi trois\ntentatives de normalisation en 86, 89 et 92 (SQL 2 ou SQL 92). Nous présentons trois raisons fondamentales\nqui justiﬁent l’utilisation de SQL.\n• D’une part, la structuration et la manipulation des données sont devenues très complexes. Pour une ap-\nplication de taille moyenne, la base de données contient fréquemment plus de trente tables fortement\ninterconnectées. Il est donc hors de question de manipuler les données de façon algorithmique tradition-\nnelle. Une requête SQL dans un langage logique simple remplace donc bien avantageusement plusieurs\ndizaines de lignes d’un langage de programmation tel C ou Cobol.\n• D’autre part, l’architecture client-serveur est omniprésente. Tandis que la station client exécute le code\nde l’application en gérant, en particulier, l’interface graphique, le serveur optimise la manipulation et le\ncontrôle des données. De plus, les applications doivent être portables et gérer des données virtuelles, c’est-\nà-dire émanant de n’importe quel serveur. Développer une application dans un environnement hétérogène\nn’est possible que parce que la communication entre l’applicatif client et le serveur est réalisée par des\nprimitives SQL normalisées.\n• Enﬁn, les applications à développer (même sur un PC) sont devenues de plus en plus complexes. Le proﬁl\ndu programmeur a fortement changé. Il doit maintenant traiter des données de plus en plus volumineuses,\nintégrer les techniques de manipulation des interfaces, maîtriser la logique événementielle et la program-\nmation orientée objet, tout celà dans un contexte d’architecture client-serveur où se cotoient les systèmes\nd’exploitation et les protocoles de réseaux hétérogènes. L’accès et la manipulation des données ne sont que\nl’un des aspects de la conception et de la réalisation de programmes. On cherche donc à acquérir un envi-\nronnement de développement performant qui prend en charge un grand nombre de tâches annexes. Des\noutils de développement sont apparus pour permettre au développeur de se concentrer sur l’application\nproprement dite : générateurs d’écrans, de rapports, de requêtes, d’aide à la conception de programme,\nde connection à des bases de données distantes via des réseaux. Dans tous ces outils, la simplicité et la\nstandardisation de SQL font que SQL est utilisé chaque fois qu’une déﬁnition, une manipulation, ou un\ncontrôle de données est nécessaire.\nSQL est donc un élément central entre les divers composants d’un\nenvironnement de développement dans une architecture client-serveur.\n2.3. SQL dans l’architecture en couches des SGBD\nDans la phase d’analyse de systèmes d’information, on considère différents niveaux d’abstraction du système\nd’information : le niveau conceptuel, le niveau logique ou organisationnel et enﬁn, le niveau physique ou\nopérationnel.\nNous allons considérer ici différents niveaux de perception d’une base de données relationnelle. Un SGBD est\nfréquemment décrit par une structure en couches correspondant à des perceptions différentes des données,\nassociées à des tâches différentes pour différents acteurs.\n1.\nhttp://www.grappa.univ-lille3.fr/polys/frime\n3\n\nChapitre 2. Qu’est-ce que SQL ?\nPour plus de simplicité, nous distinguerons trois types d’acteurs : les administrateurs de la base de donnée,\nles développeurs et les utilisateurs. Au niveau externe, proche de l’utilisateur, la perception est totalement in-\ndépendante du matériel et des techniques mises en oeuvre, tandis qu’au niveau le plus intérieur, se trouvent\nles détails de l’organisation sur disque et en mémoire.\nLe schéma logique est l’ensemble de toutes les données pertinentes, toutes applications confondues. Il est\nrendu conforme à un modèle de représentation des données, et est totalement indépendant de la technolo-\ngie utilisée. Nous choisissons le modèle relationnel. Ce niveau a un inconvénient : toutes les données sont\naccessibles à tout le monde. Cet ensemble vaste de données est trop touffu. Il est préférable de montrer à\nl’utilisateur (et au programmeur) une vue plus simple des données.\nOn constitue ainsi des schémas externes. Par exemple, le gestionnaire du stock n’est concerné que par les\ndonnées décrivant les articles en stock. S’il ne manipule que des bordereaux d’entrée, des bordereaux de\nsortie, et des ﬁches d’état du stock, ceux-ci constituent son schéma de perception externe.\nLe schéma interne fournit une perception plus technique des données.\nEnﬁn le schéma physique est dépendant du matériel et du logiciel de base.\nNiveau externe\nAu niveau externe, les utilisateurs et développeurs d’application ont une perception limitée de la base de\ndonnées. On parle de vue. Une vue peut être considérée comme une restriction du schéma logique à un type\nd’utilisateur. Ce niveau concerne les utilisateurs et les développeurs.\nNiveau logique\nTraduction dans le modèle relationnel du schéma conceptuel. On précise à ce niveau les tables, les relations\nentre tables, les contraintes d’intégrité, les vues et les droits par groupe d’utilisateurs. Ce niveau concerne\nl’administrateur et les développeurs.\nNiveau interne\nOn déﬁnit les index et tous les éléments informatiques susceptibles d’optimiser les ressources et les accès aux\ndonnées. Ce niveau concerne l’administrateur.\nNiveau physique\nOn y précise tout ce qui dépend du matériel et du système d’exploitation. Ce niveau concerne l’administrateur.\nCette découpe en niveaux présente les avantages suivants :\n• Les applications développées sont indépendantes du niveau interne. Tout changement de stratégie d’accès,\nou d’organisation des données entraîne une modiﬁcation au niveau interne, mais le schéma logique reste\ninchangé. Par exemple, une requête SQL précise le QUOI sans se préoccuper du COMMENT.\n• La distinction externe/logique assure (en partie) l’indépendance entre les applications et le niveau logique.\nPar exemple on peut enrichir le schéma logique sans modiﬁer les applications existantes pour toutes les\nvues non concernées par les modiﬁcations apportées au schéma logique.\n• La distinction logique/interne permet de modiﬁer les optimisations d’accès aux données. Par exemple, si\nune application a des performances insufﬁsantes, il est possible d’optimiser les accès (en introduisant de\nnouveaux index, par exemple) et d’augmenter les performances sans modiﬁer l’application.\n• La distinction interne/physique permet une meilleure portabilité car seule la partie physique est dépen-\ndante du matériel et du système d’exploitation.\n2.4. SQL : Principes d’une Base de Données Relationnelle\nLe terme relationnel provient de la déﬁnition mathématique d’algèbre relationnelle (Codd 70). Une relation\nest un ensemble de tuples (tuple est la généralisation de couple à un nombre quelconque d’éléments. Les\ncouples, les triplets, les quadrupets, etc sont des tuples) de données, on peut alors déﬁnir des opérations\nalgébriques sur les relations (voir la section Section 2.7). Nous\nparlerons dans la suite de table, et non pas\nde relation. Une table est un ensemble de tuples de données distincts deux à deux. Une table est constituée\nd’une clef primaire et de plusieurs attributs (ou colonnes) qui dépendent de cette clef. La clef primaire d’une\ntable est un attribut ou un groupe d’attributs de la table qui détermine tous les autres de façon unique. Une\n4\n\nChapitre 2. Qu’est-ce que SQL ?\ntable possède toujours une et une seule clef primaire. Par contre, une table peut présenter plusieurs clefs\ncandidates qui pourraient jouer ce rôle. Le domaine d’un attribut est l’ensemble des valeurs que peut prendre\ncet attribut. Le domaine est constitué d’un type, d’une longueur et de contraintes qui réduisent l’ensemble\ndes valeurs permises. Une clef étrangère dans une table est une clef primaire ou candidate dans une autre\ntable. Les contraintes d’intégrité font partie du schéma logique. Parmi celles-ci, on distingue :\n•\nles contraintes de domaine qui restreignent l’ensemble des valeurs que peut prendre un attribut dans une\ntable,\n• les contraintes d’intégrité d’entité qui précisent qu’une table doit toujours avoir une clef primaire et\n• les contraintes d’intégrité référentielle qui précisent les conditions dans lesquelles peuvent être ajoutés ou\nsupprimés des enregistrements lorsqu’il existe des associations entre tables par l’intermédiaire de clefs\nétrangères.\nExemple 2-1. Contraintes d’intégrité\nCLIENTS (cltnum, cltnom, cltpnom, cltloc, cltca, clttype)\nCOMMANDES (cmdnum, cmdclt, cmddate, cmdvnd)\nLIGCOMMANDES (ldccmd, ldcart, ldcqte)\nARTICLES (artnum, artnom, artpv, artcoul)\nLes identiﬁants sont en gras, les clefs étrangères en italiques. Une contrainte d’intégrité référentielle est,\npar exemple, l’obligation de la présence d’un client pour une comande. C’est-à-dire encore qu’à un en-\nregistrement dans la table COMMANDES doit correspondre un enregistrement de la table CLIENTS tel que\nCOMMANDES.cmdclt=CLIENTS.cltnum.\n2.5. Architecture client-serveur et communication par SQL\nNous allons d’abord voir les différents types d’application possibles pour la gestion de données distantes en\ncommençant par les trois formes les plus simples.\nMonoposte\nLa base de données se trouve sur un poste et n’est pas accessible en réseau. Il faut, dans ce cas, penser à la no-\ntion de sécurité si plusieurs utilisateurs peuvent interroger la base (suppression accidentelle d’enregistrements).\nMultiposte, basée sur des terminaux liés à un site central\nC’est l’informatique multiposte traditionnelle. La gestion des données est centralisée. Les applications ont été\nécrites par le service informatique et seules ces applications peuvent interroger le serveur.\nMultiposte, basée sur un serveur de ﬁchiers\nC’est la première forme (la plus simple) d’architecture client-serveur. Si l’applicatif sur un PC souhaite vi-\nsualiser la liste des clients habitant Paris, tous les enregistrements du ﬁchier CLIENT transitent sur le réseau,\nentre le serveur et le client, la sélection (des clients habitant Paris) est faite sur le PC. Le traﬁc sur le réseau\nest énorme et les performances se dégradent lorsque le nombre de clients augmente. Les serveurs de ﬁchiers\nrestent très utilisés comme serveurs d’images, de documents, d’archives.\nDe nouveaux besoins sont apparus :\n• diminuer le traﬁc sur le réseau pour augmenter le nombre de postes sans nuire au fonctionnement,\n• traiter des volumes de données de plus en plus grand,\n• accéder de façon transparente à des données situées sur des serveurs différents,\n• accéder aux données de façon ensembliste, même si les données sont distantes, aﬁn de diminuer le travail\ndu programmeur,\n• adopter des interfaces graphiques de type Windows pour les applicatifs clients.\n5\n\nChapitre 2. Qu’est-ce que SQL ?\n2.5.1. Bases de données en client-serveur\nDans une architecture client-serveur, un applicatif est constitué de trois parties : l’interface utilisateur, la\nlogique des traitements et la gestion des données. Le client n’exécute que l’interface utilisateur et la logique\ndes traitements, laissant au serveur de bases de données la gestion complète des manipulations de données.\n•\nLe serveur de bases de données fournit des services aux processus clients. Les tâches qu’il doit prendre\nen compte sont : la gestion d’une mémoire cache, l’exécution de requêtes exprimées en SQL, exécuter des\nrequêtes mémorisées, la gestion des transactions, la sécurité des données.\n• Le client doit ouvrir une connection pour pouvoir proﬁter des services du serveur. Il peut ouvrir plusieurs\nconnections simultanées sur plusieurs serveurs. Le client peut soumettre plusieurs requêtes simultané-\nment au serveur et traiter les résultats de façon asynchrone.\n• Communication entre le client et le serveur. Puisque l’application doit pouvoir se connecter à divers ser-\nveurs de façon transparente, le langage de communication SQL doit être compatible avec la syntaxe SQL\nde chaque serveur pressenti. Or, malgré les normes, les dialectes SQL sont nombreux et parfois source\nd’incompatibilité. La seule façon de permettre une communication plus large est d’adopter un langage\nSQL standardisé de communication. Une couche fonctionnelle du client traduit les requêtes du dialecte\nSQL client en SQL normalisé. La requête transformée est envoyée au serveur. Celui-ci traduit la requête\ndans le dialecte SQL-serveur et l’exécute. Le résultat de la requête suit le chemin inverse. Le langage de\ncommunication normalisé le plus fréquent est l’ODBC (Open DataBase Connectivity) de Microsoft. Signa-\nlons également IDAPI (Integrated Database Application Programming Interface) de Borland. De plus, ces\nprogrammes permettent d’interroger des bases de données autres que relationnelles.\n2.5.2. Les serveurs de transactions\nUne transaction correspond à une procédure SQL, i.e. un groupe d’instructions SQL. Il y a un seul échange\nrequête/réponse pour la transaction. Le succès ou l’échec concerne l’ensemble des instructions SQL. Ces\nserveurs sont essentiellement utilisés pour l’informatique de production (ou opérationnelle) pour laquelle la\nrapidité des temps de réponse est importante sinon essentielle.\n2.6. Structure générale du langage SQL\nLes instructions essentielles SQL se répartissent en trois familles fonctionnellement distinctes et trois formes\nd’utilisation :\nSelon la norme SQL 92, le SQL interactif permet d’exécuter une requête et d’en obtenir immédiatement une\nréponse. Le SQL intégré ( ou module SQL) permet d’utiliser SQL dans un langage de troisième génération\n(C, Cobol, ...), les instructions permettant essentiellement de gérer les curseurs. Le SQL dynamique est une\nextension du SQL intégré qui permet d’exécuter des requêtes SQL non connues au moment de la compilation.\nHors norme, SQL est utilisable sous la forme de librairies de fonctions API (exemple : ODBC). Nous nous\nlimitons au SQL interactif.\nDans le SQL interactif, le LDD (Langage de Déﬁnition de données) permet la description de la structure de\nla base (tables, vues, index, attributs, ...). Le dictionnaire contient à tout moment le descriptif complet de la\nstructure de données. Le LMD (Langage de Manipulation de Données) permet la manipulation des tables et\ndes vues. Le LCD (Langage de Contrôle des Données) contient les primitives de gestion des transactions et\ndes privilèges d’accès aux données. Le tableau ci-dessous vous donne les principales primitives SQL et leur\nclassiﬁcation. Nous nous intéresserons essentiellement au LMD et à la commande SELECT. Nous étudierons\négalement quelques problèmes concernant les privilèges d’accès et les transactions.\nTableau 2-1. SQL interactif\nLDD\nLMD\nLCD\nCREATE\nSELECT\nGRANT\nDROP\nINSERT\nREVOKE\nALTER\nDELETE\nCONNECT\n6\n\nChapitre 2. Qu’est-ce que SQL ?\nLDD\nLMD\nLCD\nUPDATE\nCOMMIT\nROLLBACK\nSET\n2.7. SQL : un langage algébrique\nPour bien comprendre le langage SQL, nous allons brièvement exposer les principes sur lesquels repose ce\nlangage (algèbre relationnelle).\nUne table (relation) est un ensemble de tuples. On peut donc appliquer à une table les opérateurs algébriques\nusuels. Le résultat d’une opération ou requête est une nouvelle table qui est exploitable à son tour dans une\nnouvelle opération. Tous les opérateurs peuvent être dérivés de cinq primitives de base : la PROJECTION, la\nSÉLECTION, l’UNION, la DIFFÉRENCE et le PRODUIT. L’opérateur de JOINTURE qui peut être déduit\ndes cinq primitives de base est cependant fondamental. (algèbre relationnelle).\nLa PROJECTION\npermet de ne conserver que les attributs intéressants d’une table (sélection verticale). De plus, la projection\nélimine les répétitions de tuples résultant de cette sélection.\nExemple 2-2. Projection\nCLIENTS2 = PROJECT CLIENTS OVER (cltnom, cltloc)\nLa SÉLECTION\npermet de ne conserver que les tuples qui respectent une condition déﬁnie sur les valeurs des attributs (sélec-\ntion horizontale).\nExemple 2-3. Sélection\nBONSCLIENTS = SELECT CLIENTS WHERE cltca>10000\nL’UNION\nréalise l’union de plusieurs tables.\nExemple 2-4. Union\nCLIENTS3 = SELECT CLIENTS WHERE cltloc = ’PARIS’\nUNION\nSELECT BONSCLIENTS WHERE cltloc=’BRUXELLES’}\nLa DIFFÉRENCE\nconsiste à prendre les tuples appartenant à une table mais pas à une autre.\nExemple 2-5. Différence\nCLIENTS4 = SELECT CLIENTS WHERE cltloc = ’BRUXELLES’ EXCEPT BONSCLIENTS\nLe PRODUIT\nréalise la juxtaposition de tous les tuples de la première table avec chaque tuple de la seconde. Celà signiﬁe\nque, si les deux tables ont respectivement $M$ et $N$ tuples, la table résultante aura M×N tuples. Cette\nopération présente peu d’intérêt mais combinée avec une sélection, on obtient une opération fondamentale :\nla JOINTURE.\n7\n\nChapitre 2. Qu’est-ce que SQL ?\nLa JOINTURE\nN’est possible que sur deux tables possédant un attribut de domaine commun. Elle consiste à juxtaposer les\ntuples dont la valeur d’un attribut est égal dans les deux tables. C’est une primitive dérivée car elle peut être\ndéﬁnie à l’aide des primitives précédentes (exercice laissé au lecteur).\nExemple 2-6. Jointure\nCMDCLIENTS = COMMANDES JOIN CLIENTS ON cmdclt=cltnum}\nLes primitives peuvent être combinées pour constituer des requêtes plus élaborées. La séquence d’opérateurs\npermettant de réaliser une requête élaborée devient assez vite complexe. Le langage SQL permet (heureuse-\nment) d’exprimer globalement une requête sans faire apparaître les tables et les primitives intermédiaires.\nCe sera le moteur SQL qui sera chargé d’optimiser la requête.\nExemple 2-7. Requête\nUne requête SQL qui permet de dresser la liste des noms des clients qui ont acheté des articles de moins de\n200F est :\nSELECT DISTINCT cltnom\nFROM clients, commandes, ligcommandes, articles\nWHERE cltnum=cmdclt\nAND artnum=lcdart\nAND cmdnum=ldccmd\nAND artpv < 200\nUne combinaison de primitives permettant d’exécuter cette requête est :\nTEMP1 = SELECT ARTICLES WHERE artpv < 200\nTEMP2 = PROJECT TEMP1 OVER (artnum)\nTEMP3 = PROJECT CLIENTS OVER (cltnum,cltnom)\nTEMP4 = PROJECT COMMANDES OVER (cmdnum, cmdclt)\nTEMP5 = PROJECT LIGCOMMANDES OVER (ldccmd,ldcart)\nTEMP6 = TEMP2 JOIN TEMP5 ON artnum=ldcart\nTEMP7 = PROJECT TEMP6 OVER (ldccmd)\nTEMP8 = TEMP3 JOIN TEMP4 ON cltnum=cmdclt\nTEMP9 = PROJECT TEMP8 OVER (cltnom, cmdnum)\nTEMP10 = TEMP7 JOIN TEMP9 ON ldccmd=cmdnum\nRESULTAT = PROJECT TEMP10 OVER (cltnom)}\nUne telle séquence n’est, en général, pas unique. La séquence fournie est une des plus efﬁcaces (le lecteur\npeut s’exercer à en trouver d’autres).\n8\n\nChapitre 3. Présentation de PostgreSQL\n3.1. Déﬁnition de PostgreSQL\nCe texte provient de la documentation PostgreSQL 7.4.81.\nPostgreSQL est un système de gestion de bases de données relationnelles objet (ORDBMS) basé sur POSTGRES,\nVersion 4.2, développé à l’université de Californie au département des sciences informatiques de Berkeley.\nPOSTGRES a lancé de nombreux concepts rendus ensuite disponibles dans plusieurs systèmes de bases de\ndonnées commerciales.\nPostgreSQL est un descendant open-source du code original de Berkeley. Il supporte SQL92 et SQL99 tout en\noffrant de nombreuses fonctionnalités modernes :\n• requêtes complexes ;\n• clés étrangères ;\n• déclencheurs (triggers) ;\n• vues ;\n• intégrité des transactions ;\n• contrôle des accès concurrents (MVCC ou multiversion concurrency control).\nDe plus, PostgreSQL peut être étendu de plusieurs façons par l’utilisateur, par exemple en ajoutant de nou-\nveaux\n• types de données ;\n• fonctions ;\n• opérateurs ;\n• fonctions d’agrégat ;\n• méthodes d’indexage ;\n• langages de procédure.\nEt grâce à sa licence libérale, PostgreSQL peut être utilisé, modiﬁé et distribué par tout le monde gratuite-\nment quelque soit le but visé, qu’il soit privé, commercial ou académique.\n3.2. Bref historique de PostgreSQL\nCe texte provient de la documentation PostgreSQL 7.4.82.\nLe système de bases de données relationnel objet PostgreSQL est issu de POSTGRES, programme écrit à\nl’université de Californie à Berkeley. Avec plus d’une dizaine d’années de développement, PostgreSQL est\nla plus avancée des bases de données libres.\n3.2.1. Le projet POSTGRES de Berkeley\nLe projet POSTGRES, mené par le professeur Michael Stonebraker, était sponsorisé par l’agence des projets\navancés de la Défense (DARPA, acronyme de Advanced Research Projects Agency), le bureau des recherches\nde l’armée (ARO, acronyme de Army Research Ofﬁce), le NSF (acronyme de National Science Foundation)\nainsi que ESL, Inc. L’implémentation de POSTGRES a commencé en 1986. Les concepts initiaux du système\nont été présenté dans The design of POSTGRES3 et la déﬁnition du modèle de données initial est apparu dans\nThe POSTGRES data model4. Le concept du système de règles à ce moment était décrit dans The design of\n1.\nhttp://traduc.postgresqlfr.org/pgsql-fr/preface.html#INTRO-WHATIS\n2.\nhttp://traduc.postgresqlfr.org/pgsql-fr/history.html\n3.\nhttp://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M85-95.pdf\n4.\nhttp://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M87-13.pdf\n9\n\nChapitre 3. Présentation de PostgreSQL\nthe POSTGRES rules system5. L’architecture du gestionnaire de stockage était détaillée dans The design of the\nPOSTGRES storage system6.\nPostgres a connu plusieurs versions majeures depuis. La première « démo » devint opérationnelle en 1987\net fut présenté en 1988 à la conférence ACM-SIGMOD. La version 1, décrite dans The implementation of\nPOSTGRES7, fut livrée à quelques utilisateurs externes en juin 1989. En réponse à une critique du premier mé-\ncanisme de règles (A commentary on the POSTGRES rules system8), celui-ci fut réécrit (On Rules, Procedures,\nCaching and Views in Database Systems9) dans la version 2, présentée en juin 1990. La version 3 apparut en\n1991. Elle ajoutait le support de plusieurs gestionnaires de stockage, un exécuteur de requêtes amélioré et\nun gestionnaire de règles réécrit. La plupart des versions suivantes jusqu’à Postgres95 (voir Section 3.2.2)\nportèrent sur la portabilité et la ﬁabilité.\nPOSTGRES fut utilisé pour réaliser différentes applications de recherche et de production. Par exemple : un\nsystème d’analyse de données ﬁnancières, un programme de suivi des performances d’un moteur à ré-\naction, une base de données de suivi d’astéroïdes, une base de données médicale et plusieurs systèmes\nd’informations géographiques. POSTGRES a aussi été utilisé comme outil de formation dans plusieurs uni-\nversités. Enﬁn, Illustra Information Technologies (devenu Informix10, maintenant détenu par IBM11) a repris\nle code et l’a commercialisé. Fin 1992, POSTGRES devint le gestionnaire de données principal du projet de\ncalcul scientiﬁque Sequoia 200012 ﬁn 1992.\nLa taille de la communauté d’utilisateurs doubla pratiquement durant l’année 1993. Il devint de plus en plus\névident que la maintenance du code et le support nécessitaient de plus en plus de temps et d’énergie, qui\nauraient dûs être employés à des recherches sur les bases de données. Aﬁn de réduire le poids du support,\nle projet POSTGRES de Berkeley se termina ofﬁciellement avec la version 4.2.\n3.2.2. Postgres95\nEn 1994, Andrew Yu et Jolly Chen ajoutèrent un interpréteur de langage SQL à POSTGRES. Sous un nouveau\nnom, Postgres95 fut par la suite publié sur le Web, aﬁn de devenir un descendant libre (open-source) du code\nsource initial de POSTGRES, version Berkeley.\nLe code de Postgres95 était complètement compatible avec le C ANSI et 25% moins gros. De nombreux\nchangements internes amélioraient les performances et la maintenabilité. Les versions 1.0.x de Postgres95\nétaient 30 à 50% plus rapides que POSTGRES, version 4.2, pour le test Wisconsin Benchmark. Mises à part les\ncorrections de bogues, les principales améliorations étaient :\n• Le langage PostQUEL était remplacé par SQL (exécuté côté serveur). Les requêtes imbriquées ne furent pas\nsupportées avant PostgreSQL (voir plus loin) mais elles pouvaient être imitées dans Postgres95 avec des\nfonctions SQL déﬁnies par l’utilisateur. Les agrégats furent reprogrammés, l’utilisation de la clause GROUP\nBY ajouté.\n• En plus du moniteur de programme, un nouveau programme (psql) permettait d’exécuter des requêtes\nSQL interactives, en utilisant GNU Readline.\n• Une nouvelle bibliothèque cliente, libpgtcl, supportait les programmes écrits en Tcl. Un shell exemple,\npgtclsh, fournissait de nouvelles commandes Tcl pour interfacer les applications Tcl avec le serveur\nPostgres95.\n• L’interface pour les gros objets était révisée. Les objets de grande taille Inversion étaient le seul méca-\nnisme pour stocker de tels objets, le système de ﬁchiers Inversion étant supprimé.\n• Le système de règles de niveau instance était supprimé. Les règles étaient toujours disponibles en tant que\nrègles de réécriture.\n• Un bref tutoriel présentant les possibilités SQL ainsi que celles spéciﬁques à Postgres95 était distribué\navec le code source.\n• La version GNU de make (au lieu de la version BSD) était utilisée pour la construction. Par ailleurs,\nPostgres95 pouvait être compilé avec GCC sans correctif (l’alignement des nombres doubles était corri-\ngé).\n5.\nhttp://traduc.postgresqlfr.org/pgsql-fr/biblio.html#STON87A\n6.\nhttp://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M87-06.pdf\n7.\nhttp://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M90-34.pdf\n8.\nhttp://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M89-82.pdf\n9.\nhttp://s2k-ftp.cs.berkeley.edu:8000/postgres/papers/ERL-M90-36.pdf\n10. http://www.informix.com/\n11. http://www.ibm.com/\n12. http://meteora.ucsd.edu/s2k/s2k_home.html\n10\n\nChapitre 3. Présentation de PostgreSQL\n3.2.3. PostgreSQL\nEn 1996, il devint évident que le nom « Postgres95 » vieillissait mal. Nous avons choisi un nouveau nom,\nPostgreSQL, pour mettre en avant la relation entre le POSTGRES original et les capacités SQL des versions\nplus récentes. En même temps, nous avons positionné le numéro de version à 6.0, pour reprendre la numé-\nrotation originale du projet POSTGRES de Berkeley.\nDurant le développement de Postgres95, un effort particulier avait été fourni pour identiﬁer et comprendre\nles problèmes existants dans le code. Avec PostgreSQL, la priorité put être mise sur l’augmentation des\ncaractéristiques et des possibilités, même si le travail a continué dans tous les domaines.\n3.3. PostgreSQL 8.0 est là !\nCe texte est l’article de presse annonçant la sortie de PostgreSQL 8.0.\nNewYork : le 19 Janvier 2005 - Le groupe de Développement Global de PostgreSQL vient de produire la\nversion 8.0 du système de gestion de bases de données PostgreSQL, confortant sa place de système de\nbases de données open source le plus sophistiqué du monde. Cette version, en proposant des fonctionnalités\nqui n’étaient jusqu’alors présentes que dans les systèmes de bases de données propriétaires les plus coû-\nteux, devrait largement favoriser l’adoption de PostgreSQL par les utilisateurs et les éditeurs de solutions\ninformatiques.\nEn plus des améliorations signiﬁcatives sur l’extensibilité, les fonctionnalités et la performance, PostgreSQL\n8.0 fait la preuve de l’efﬁcacité sans égal du développement open source. Plus d’une douzaine de com-\npagnies, incluant Red Hat, Fujitsu, Aﬁlias, Software Research Associates Inc., 2nd Quadrant et Command\nPrompt Inc., ainsi que des centaines de développeurs individuels ont contribué à l’ajout des fonctionnalités\nmajeures de la 8.0, dans des proportions qui dépassent toutes les versions précédentes.\nM. Takyuki Nakazawa, Directeur du groupe base de données open source s’exprime en ces termes : « Nous\nsommes persuadés que ces fonctionnalités professionnelles attireront beaucoup de nouveaux utilisateurs\nvers PostgreSQL. » . « Fujitsu est ﬁer du soutien apporté aux contributions de PostgreSQL et de son travail\navec la communauté PostgreSQL. Nous souhaitons aider PostgreSQL à devenir le SGBD dominant. »\nLes nouvelles fonctionnalités comprennent :\n• Support natif de Windows : PostgreSQL fonctionne maintenant de manière native avec les systèmes Win-\ndows et ne nécessite aucune couche d’émulation. Ceci améliore de façon considérable les performances du\nlogiciel par rapport à la version précédente et constitue une alternative très séduisante aux logiciels de base\nde données propriétaires pour les fournisseurs indépendants de logiciels, les utilisateurs professionnels et\nles développeurs individuels sous Windows.\n• Points de retournement : Cette fonction standard de SQL permet des retours sur des points spéciﬁques\nd’une transaction sur la base de données sans que l’ensemble de l’opération soit annulée. Ceci est un\navantage pour les développeurs d’applications métiers qui ont besoin de pouvoir effectuer des transac-\ntions complexes utilisant des reprises sur erreur.\n• Récupération par rapport à un point dans le temps : Cette fonctionnalité permet la restauration com-\npléte des données à partir d’une sauvegarde automatique et continue des transactions effectuées. Ceci est\nune alternative longtemps attendue aux sauvegardes horaires ou journalières pour les services utilisant\nPostgreSQL pour des données critiques.\n• Espaces de tables : Cruciaux pour les administrateurs de systèmes de data warehouse de multiples-gigaoctets,\nles espaces de tables permettent le placement des grandes tables et index sur leurs propres disques ou\ngrappes, aﬁn d’améliorer les performances.\n• Améliorations de la gestion de la mémoire et des entrées sorties : L’utilisation des disques et de la mémoire\na été optimisée au travers de l’emploi de l’algorithme de Cache à Remplacement Adaptatif, d’un nouveau\nsystème d’écriture en tâche de fond et d’une nouvelle fonctionnalité permettant d’effectuer des vacuum\ndifférés. Ceci résulte en une charge plus prévisible ainsi qu’une performance plus cohérente lors des pics\nde charge.\n11\n\nChapitre 3. Présentation de PostgreSQL\nJavier Soltero, architecte en chef chez Hyperic LLC, a dit « PostgreSQL 8.0 nous apporte un haut niveau de\nsimultanéité d’accès et le débit nécessaire pour notre produit de surveillance HQ. PostgreSQL 8.0 disposant\ndu support natif de Windows, nous pouvons maintenant inclure PostgreSQL dans nos produits et bénéﬁcier\nde l’extensibilité et de la performance d’ores et déjà prouvées de PostgreSQL. Sa licence nous permet de\nl’inclure dans notre distribution sans souci de redevances commerciales. »\nEn plus de toutes les fonctionnalités incluses dans cette version, PostgreSQL a été étendu par le dévelop-\npement accéléré de composants additifs et optionnels tout au long de l’année passée. L’outil de réplication\nSlony-I et l’utilitaire de pooling/brokering de connection pgPool sont d’ores et déjà utilisés pour des en-\nsemble de serveurs haute disponibilité. Plusieurs langages de procédures stockées ont été ajoutés ou large-\nment étendus comme PL/Java, PL/PHP et PL/Perl. Les sources de données Npgsql et PGsqlClient .NET\nont été améliorées aﬁn de fournir un support aux nouveaux utilisateurs de Windows.\nPour obtenir la liste complète et la description de toutes les nouvelles fonctionnalités de la 8.0, référez-vous\nà notre dossier de presse13.\nÀ propos de PostgreSQL : PostgreSQL est le fruit du travail collectif de centaines de développeurs, s’appuyant\nsur un développement entamé il y a presque vingt ans à l’Université de Californie à Berkeley. Avec son sup-\nport de longue date des fonctionnalités nécessaires dans l’entreprise telles que les transactions, les procé-\ndures et fonctions stockées, les triggers, les sous-requêtes, PostgreSQL est utilisé dans les branches métiers\nou les agences gouvernementales les plus exigentes. PostgreSQL est distribué sous licence BSD, permettant\nl’utilisation et la distribution sans rétribution pour les utilisations commerciales et non commerciales.\n3.4. Fonctionnalités supplémentaires dans PostgreSQL 8.0\nCe texte provient de Neodante’s blog14.\nEn plus des fonctionnalités majeures décrites ci-dessus, d’autres fonctionnalités trés intéressantes pour les\nutilisateurs de PostgreSQL ont été soit ajoutées soit améliorées.\n• Fonctions : les fonctions PostgreSQL disposent maintenant de la possibilité de placer une variable à\nl’intérieur d’une chaîne, permettant ainsi de limiter les erreurs dues à l’imbrication des apostrophes. Par\nailleurs, grâce aux nouveaux points de sauvegarde (Savepoints), les fonctions PL/pgSQL sont capables\nd’une gestion limitée des exceptions grâce à l’utilisation de la clause EXCEPTION.\n• Conception de base de données : l’administrateur de la base de données peut maintenant changer le type\nd’une colonne existante en utilisant ALTER TABLE. La déclaration de colonnes utilisant des types de don-\nnées composites peut aussi être utilisée, comme il est prévu dans le standard SQL. Enﬁn, tous les objets de\nla base supportent CHANGE OWNER.\n• Import/Export de données : La commande COPY permet maintenant l’utilisation du format de ﬁchier texte\ntrès répandu CSV (valeurs séparées par des virgules). Ceci rend les imports et les exports vers d’autres\nlogiciels plus faciles à réaliser.\n• Amélioration de l’optimiseur de requêtes : le planiﬁcateur et l’exécuteur de requêtes utiliseront mainte-\nnant les index pour des types de données compatibles, réduisant grandement le recours aux transtypages\nde valeurs constantes. Cette version inclut également des améliorations dans l’utilisation des index, une\noptimisation des clauses OR, un échantillonnage amélioré pour ANALYZE, un TRUNCATE plus rapide, une\nmeilleure génération des plans de requêtes préparées, plus un grand nombre d’améliorations mineures,\ntrop nombreuses pour être citées.\n• Journalisation : les administrateurs peuvent désormais conﬁgurer la rotation des ﬁchiers de journalisation\nde PostgreSQL au travers du ﬁchier postgresql.conf. Le ﬁchier de journalisation de PostgreSQL est en-\ncore plus conﬁgurable que précédemment, grâce à l’inclusion de préﬁxes de lignes dont le format aura été\ndéﬁni par l’administrateur, le traçage de types de requêtes SQL particuliers et le traçage des déconnexions.\n• Sauvegarde : l’utilitaire de sauvegarde portable, pg_dump, a été en grande partie réécrit. Cette version\najoute de nouvelles possibilités comme les heures de début et de ﬁn, ainsi que l’élimination des problèmes\nrésiduels concernant la portabilité et la dépendance entre les ﬁchiers de sauvegardes.\nBien sûr, d’autres changements et améliorations sont inclus dans cette version. Référez-vous à la page Notes\nde version15 pour une liste complète.\n13. http://www.postgresql.org/about/press\n14. http://blogs.developpeur.org/neodante/archive/2005/01/22/4058.aspx\n15. http://www.postgresql.org/docs/8.0/static/release.htmll\n12\n\nChapitre 3. Présentation de PostgreSQL\n3.5. D’autres informations\nOn pourra aller auusi consulter la rubrique PostgreSQL16 sur Wikipedia17.\nIl existe un site en français18 consacré entièrement à PostgreSQL.\n16. http://fr.wikipedia.org/wiki/PostgreSQL\n17. http://fr.wikipedia.org/\n18. http://www.postgresqlfr.org/\n13\n\nChapitre 3. Présentation de PostgreSQL\n14\n\nChapitre 4. Une base jouet pour découvrir SQL\nVous trouverez les réponses des exercices au Chapitre 14.\n4.1. Les tables\nTableau 4-1. La table UN\na\nb\nc\nx\nm\n2\nx\nn\n1\ny\nm\n4\nz\np\n1\nTableau 4-2. La table DEUX\nd\ne\nx\n8\ny\n4\nx\n1\n4.2. Quelques requêtes\nCalculer à la main le résultat des requêtes suivantes.\n1. SELECT * FROM un ;\n2. SELECT a FROM un ;\n3. SELECT a FROM un WHERE c=1 ;\n4. SELECT a FROM un WHERE c=1 OR c=2 ;\n5. SELECT DISTINCT a FROM un WHERE c=1 OR c=2 ;\n6. SELECT a FROM un ORDER BY b ;\n7. SELECT a,e FROM un,deux ;\n8. SELECT a,e FROM un,deux WHERE c=e ;\n15\n\nChapitre 4. Une base jouet pour découvrir SQL\n16\n\nChapitre 5. La base EXEMPLE\n5.1. La base EXEMPLE\nElle est constituée de deux tables : EMP et DEPT.\nCette base représente d’une manière simpliste (et remarquablement incomplète) le personnel d’une entre-\nprise. Elle n’est pas destinée à être réaliste, mais seulement à être simple à comprendre pour une première\napproche de SQL. On verra même plus tard que certaines informations de la base font référence à des tables\nque nous ne connaissons pas.\nLa table EMP contient les informations sur les employés.\nLa table DEPT recense les différents départements de l’entreprise.\n5.2. La table EMP\nTableau 5-1. La table EMP\nnoemp\nnom\nprenom\nembauche\nno-\nsupr\ntitre\nnodept\nsalaire\ntx_commission\n1\nPatamob\nAdhémar\n03/26/2000\nPrésident\n50\n50000.00\n2\nZeublouze\nAgathe\n04/15/2000\n1\nDir. Distrib\n41\n35000.00\n3\nKuzbidon\nAlex\n05/05/2000\n1\nDir. Vente\n31\n34000.00\n4\nLocale\nAnasthasie\n05/25/2000\n1\nDir. Finance\n10\n36000.00\n5\nTeutmaronne\nArmand\n06/14/2000\n1\nDir. Administr\n50\n36000.00\n6\nZoudanlkou\nDebbie\n07/04/2000\n2\nChef Entrepôt\n41\n25000.00\n7\nRivenbusse\nElsa\n07/24/2000\n2\nChef Entrepôt\n42\n24000.00\n8\nArdelpic\nHelmut\n08/13/2000\n2\nChef Entrepôt\n43\n23000.00\n9\nPeursconla\nHumphrey\n09/02/2000\n2\nChef Entrepôt\n44\n22000.00\n10\nVrante\nHéléna\n09/22/2000\n2\nChef Entrepôt\n45\n21000.00\n11\nEnfaillite\nMélusine\n10/12/2000\n3\nReprésentant\n31\n25000.00\n10.00\n12\nEurktumeme\nOdile\n11/01/2000\n3\nReprésentant\n32\n26000.00\n12.50\n13\nHotdeugou\nOlaf\n11/21/2000\n3\nReprésentant\n33\n27000.00\n10.00\n14\nOdlavieille\nPacôme\n12/11/2000\n3\nReprésentant\n34\n25500.00\n15.00\n15\nAmartakaldire\nQuentin\n12/31/2000\n3\nReprésentant\n35\n23000.00\n17.50\n16\nTraibien\nSamira\n12/31/2000\n6\nSecrétaire\n41\n15000.00\n17\nFonfec\nSophie\n01/10/2001\n6\nSecrétaire\n41\n14000.00\n18\nFairant\nTeddy\n01/20/2001\n7\nSecrétaire\n42\n13000.00\n19\nBlaireur\nTerry\n02/09/2001\n7\nSecrétaire\n42\n13000.00\n20\nAjerre\nTex\n02/09/2001\n8\nSecrétaire\n43\n13000.00\n21\nChmonﬁsse\nThierry\n02/19/2001\n8\nSecrétaire\n43\n12000.00\n22\nPhototetedemort\nThomas\n02/19/2001\n9\nSecrétaire\n44\n22500.00\n23\nKaécouté\nXavier\n03/01/2001\n9\nSecrétaire\n34\n11500.00\n24\nAdrouille-Toultan\nYves\n03/11/2001\n10\nSecrétaire\n45\n11000.00\n25\nAnchier\nYvon\n03/21/2001\n10\nSecrétaire\n45\n10000.00\nDétails sur les différents champs :\n17\n\nChapitre 5. La base EXEMPLE\nnoemp\nL’identiﬁant de la personne. Chaque employé a un noemp, tous les noemp sont différents. C’est une clef primaire\n(primary key).\nnom\nLe nom de la personnne.\nprenom\nLe prénom de la personnne.\nembauche\nSa date d’embauche.\nnosupr\nLe noemp de son supérieur hiérarchique.\nPar exemple Sophie Fonfec (dont le noemp est 17) a 6 pour nosupr, ce qui signiﬁe que le noemp de son supérieur\nhiérarchique est 6, c’est-à-dire que son supérieur hiérarchique est Debbie Zoudanlkou (dont le propre supérieur\nhiérarchique est Agathe Zeublouze, etc.).\ntitre\nLa fonction de l’employé (directeur, secrétaire, représentant, etc.).\nnodept\nLe numéro du département (dans l’entreprise) dont dépend l’employé. Ce numéro fait référence à la clef pri-\nmaire de la table DEPT (voir Section 5.3). C’est une clef étrangère (foreign key).\nsalaire\nSalaire mensuel de l’employé.\ntx_commission\nTaux de commission, exprimé en pourcentage.\n5.3. La table DEPT\nTableau 5-2. La table DEPT\nnodept\nnom\nnoregion\n10\nFinance\n1\n20\nAtelier\n2\n30\nAtelier\n3\n31\nVente\n1\n32\nVente\n2\n33\nVente\n3\n34\nVente\n4\n35\nVente\n5\n41\nDistribution\n1\n42\nDistribution\n2\n43\nDistribution\n3\n44\nDistribution\n4\n45\nDistribution\n5\n50\nAdministration\n1\nDétails sur les différents champs :\n18\n\nChapitre 5. La base EXEMPLE\nnodept\nL’identiﬁant du département. Chaque département a un nodept, tous les nodept sont différents. C’est une clef\nprimaire (primary key).\nnom\nLe nom du département. On peut remarquer que des départements différents peuvent avoir le même nom.\nnoregion\nRéférence à une région. Ce numéro fait référence à la clef primaire d’une table qui ne sera pas décrite ici1. C’est\nune clef étrangère (foreign key).\n1.\nOn rappelle ce qui est dit en tête de ce chapitre : Elle n’est pas destinée à être réaliste, mais seulement à être simple à\ncomprendre pour une première approche de SQL. On verra même plus tard que certaines informations de la base font référence à des\ntables que nous ne connaissons pas. (Section 5.1)\n19\n\nChapitre 5. La base EXEMPLE\n20\n\nChapitre 6. La commande SELECT, syntaxe de base\nVous trouverez les réponses des exercices au Chapitre 15.\n6.1. SELECT\nLa commande de recherche est le verbe SELECT .\nL’étude de la commande SELECT et des différentes clauses et fonctions est faite, pour commencer, en consi-\ndérant une seule table.\nPar la suite, l’utilisation de plusieurs tables dans le même SELECT, sera prise en compte.\nLa syntaxe de base est :\nSELECT colonnes d’une ou plusieurs tables séparées par « , »\nFROM tables séparées par « , »\nWHERE conditions logiques séparées par « AND » ou « OR »\nORDER BY colonnes séparées par « , »\nLe caractère « * » permet de demander l’afﬁchage de toutes les colonnes d’une table.\n1. Afﬁcher toutes les informations concernant les employés.\n2. Afﬁcher toutes les informations concernant les départements.\nA la place de « * » on peut donner la liste des colonnes souhaitées, dans l’ordre souhaité, en écrivant la\nrequête sur une ou plusieurs lignes. L’écriture sur plusieurs lignes est conseillée en vue de rendre plus simple\nla relecture et la modiﬁcation de la requête. Il s’agit de la projection vue Section 2.7.\n3. Afﬁcher le nom, la date d’embauche, le numéro du supérieur, le numéro de département et le salaire de tous\nles employés.\nLe titre des colonnes obtenues par un SELECT sont les noms des champs.\nOn peut cependant changer ces titres en utilisant AS. La commande\nSELECT nom AS Employe FROM emp ;\nproduira le même effet que\nSELECT nom FROM emp ;\nà la différence que la colonne ne sera pas intitulé nom mais Employe.\nSi vous voulez utiliser un titre de colonne qui contient autre chose que des lettres non accentuées (des es-\npaces, des ponctuations, des accents, etc.) il faut l’entourer par des guillemets (« \" »). On écrira ainsi :\nSELECT nom AS \"Nom de l’employé\" FROM emp ;\n6.2. Suppression des doublons\nIl peut être utile de supprimer les doublons, d’où utilisation de la clause DISTINCT. Elle a pour effet de\nn’afﬁcher qu’une seule fois les lignes qui seraient semblables à l’afﬁchage.\nOn l’utilise sous la forme SELECT DISTINCT ....\n4. Afﬁcher le titre de tous les employés.\n21\n\nChapitre 6. La commande SELECT, syntaxe de base\n5. Afﬁcher les différentes valeurs des titres des employés.\n6.3. Restriction\nLes clauses de restriction s’écrivent derrière WHERE. Elle permettent de sélectionner les lignes à afﬁcher. Il\ns’agit de la sélectiontelle que vue Section 2.7.\n6. Afﬁcher le nom, le numéro d’employé et le numéro du département des employés dont le titre est « Secrétaire ».\n7. Afﬁcher le nom et le numéro de département dont le numéro de departement est supérieur à 40.\n6.4. Restriction en comparant les colonnes entre elles\nLa restriction peut mettre en jeu la comparaison de deux ou plusieurs colonnes entre elles. Il sufﬁt de les\nappeler par leurs noms.\n8. Afﬁcher le nom et le prénom des employés dont le nom est alphabétiquement antérieur au prénom.\n9. Afﬁcher le nom, le salaire et le numéro du département des employés dont le titre est « Représentant », le\nnuméro de département est 35 et le salaire est supérieur à 20000.\n10. Afﬁcher le nom, le titre et le salaire des employés dont le titre est « Représentant » ou dont le titre est\n« Président ».\n11. Afﬁcher le nom, le titre, le numéro de département, le salaire des employés du département 34, dont le titre\nest « Représentant » ou « Secrétaire ».\n12. Afﬁcher le nom, le titre, le numéro de département, le salaire des employés dont le titre est Représentant,\nou dont le titre est Secrétaire dans le département numéro 34.\n13. Afﬁcher le nom, et le salaire des employés dont le salaire est compris entre 20000 et 30000.\n14. Afﬁcher le nom, le titre, le numéro de département des employés dont le titre appartient à la liste : « Représentant,\nSecrétaire ».\n6.5. Négation, recherche approchée\nLes opérateurs arithmétiques sont niés avec « ! » : par exemple « non égal » s’écrit « != » (ou « <> »).\nLes autres opérateurs sont niés par «\nNOT » : par exemple « pas dans » s’écrit « NOT IN ».\nLes caractères jokers sont « % » pour une chaîne et « _ » pour un caractère. On les utilise avec l’opérateur LIKE.\n15. Afﬁcher le nom des employés commençant par la lettre « H ».\n16. Afﬁcher le nom des employés se terminant par la lettre « n ».\n17. Afﬁcher le nom des employés contenant la lettre « u » en 3ème position.\n18. Afﬁcher le salaire et le nom des employés du service 41 classés par salaire croissant.\n19. Afﬁcher le salaire et le nom des employés du service 41 classés par salaire décroissant.\n20. Afﬁcher le titre, le salaire et le nom des employés classés par titre croissant et par salaire décroissant.\n22\n\nChapitre 6. La commande SELECT, syntaxe de base\n6.6. Valeurs non renseignées\nEn SQL il existe une valeur correspondant à la valeur vide. C’est l’équivalent de la valeur Null de certains\nlangages de programmation (comme java ou python). C’est la valeur qu’ont les champs non renseignés. Elle\ns’appelle également NULL. Cette valeur n’est pas prise en compte dans les classements.\n21. Afﬁcher le taux de commission, le salaire et le nom des employés classés par taux de commission croissante.\nSi on veut utiliser les valeurs non renseignées dans une restriction ce sera avec les clauses IS NULL ou IS\nNOT NULL.\n22. Afﬁcher le nom, le salaire, le taux de commission et le titre des employés dont le taux de commission n’est\npas renseigné.\n23. Afﬁcher le nom, le salaire, le taux de commission et le titre des employés dont le taux de commission est\nrenseigné.\n24. Afﬁcher le nom, le salaire, le taux de commission, le titre des employés dont le taux de commission est\ninférieur à 15.\n6.7. Expressions arithmétiques\nDes expressions arithmétiques1 peuvent être utilisées après : SELECT, WHERE, et ORDER BY.\n25. Afﬁcher le nom, le salaire, le taux de commission et la commission d employés dont le taux de commission\nn’est pas nul.\n26. Afﬁcher le nom, le salaire, le taux de commission, la commission des employés dont le taux de commission\nn’est pas nul, classé par taux de commission croissant.\n6.8. Éviter les valeurs NULL\nLe remplacement automatique des valeurs non renseignées (NULL) se fait par l’utilisation de\nla fonction\nCOALESCE.\nCOALESCE( arg1, arg2, ...)\noù :\n• arg1 = colonne qui peut être non renseignée\n• arg2 = valeur ou nom d’une autre colonne de substitution\n• ...\nLe résultat renvoyé est la première valeur non NULL.\n27. Afﬁcher le nom, la rémunération totale des employés.\n28. Afﬁcher le nom, la rémunération totale, en tenant compte des taux de commission non renseignés des\nemployés.\n1.\nC’est-à-dire des calculs sur les nombres.\n23\n\nChapitre 6. La commande SELECT, syntaxe de base\n6.9. Arrondis\nLa fonction ROUND(arg1, arg2) permet de faire l’arrondi mathématique de arg1 avec arg2 décimales.\nLa fonction TRUNC(arg1, arg2) permet de tronquer arg1 avec arg2 décimales.\n29. Afﬁcher le nom, le salaire et le salaire horaire arrondi à deux décimales des employés du département 35.\nRenommer les colonnes.\n6.10. Concaténation\nL’opérateur de concaténation de chaînes de caractères est « || » (2 caractères « pipe »).\n30. Afﬁcher le nom et le prénom (concaténés) des employés. Renommer les colonnes.\n6.11. Opérateur conditionnel\nLa fonction de codiﬁcation du SQL standard n’existe pas en PostgreSQL :\nDECODE (arg1, arg20,arg21, arg30,arg31, arg40)\nMais on dispose de la structure CASE qui donne le même résultat (et avec plus de possibilités) : 1\nCASE WHEN cond1 THEN arg1 WHEN cond2 THEN arg2 ... ELSE arg3 END\n• si la condition cond1 est vériﬁée, alors le résultat est arg1,\n• sinon, si la condition cond2 est vériﬁée, alors le résultat est arg2,\n• ...\n• sinon le résultat est arg3.\n31. Afﬁcher le nom, le numéro de département, le numéro de département décodé des départements.\nOu, pour simpliﬁer : pour le département de numéro 10, afﬁcher « Vu », pour le département de numéro 50,\nafﬁcher « Pas vu », pour les autres départements, afﬁcher « En cours »....\n32. Afﬁcher le prénom si le département est 41 sinon le nom des employés, le numéro de département, et le\nsalaire des employés classé par numéro de département.\n6.12. Chaînes de caractères\nLa fonction extraction de chaîne de caractères SUBSTR(arg1, arg2, arg3) permet d’extraire de arg1 à\npartir de la position arg2, les arg3 caractères. Si arg3 n’est pas précisé, on obtient toute la ﬁn de la chaîne de\ncaractères.\nLa fonction de retour du rang d’une chaîne dans une autre chaîne, STRPOS (arg1, arg2) permet de retour-\nner le rang de la chaîne arg2 dans la chaîne arg1.\nLes fonctions UPPER(arg1) et LOWER(arg1) permettent respectivement de forcer à la majuscule ou à la mi-\nnuscule.\nLa fonction LENGTH(arg1) permet d’obtenir le nombre de caractères d’une chaîne de caractères.\n24\n\nChapitre 6. La commande SELECT, syntaxe de base\n33. Afﬁcher les 5 premières lettres du nom des employés.\n34. Afﬁcher le nom et le rang de la lettre « r » à partir de la 3ème lettre dans le nom des employés.\n35. Afﬁcher le nom, le nom en majuscule et le nom en minuscule de l’employé dont le nom est Vrante.\n36. Afﬁcher le nom et le nombre de caractères du nom des employés.\n6.13. Opérations ensemblistes\nUtilisation des opérateurs ensemblistes : UNION, INTERSECT, EXCEPT.\nUNION seul prend les données distinctes uniquement.\nSi on veut toutes les données : UNION ALL.\n37. Afﬁcher le nom, le type de rémunération (salaire ou commission) et le montant de ce salaire ou de cette\ncommission, des employés dont le TX_COMMISSION n’est pas vide.\n38. Afﬁcher les numéros de département communs à la table EMP et à la table DEPT.\n39. Afﬁcher les numéros de département auxquels aucun employé n’est affecté.\n25\n\nChapitre 6. La commande SELECT, syntaxe de base\n26\n\nChapitre 7. Les jointures et les sous-requêtes\nVous trouverez les réponses des exercices au Chapitre 16.\n7.1. Jointures\nDans la table EMP la colonne nodept contient des valeurs qui se trouvent dans la colonne nodept de la table\nDEPT et inversement.\nLogiquement chaque ligne de EMP correspond à une ligne de DEPT et, chaque ligne DEPT correspond à une ou\nplusieurs lignes de EMP.\nCette correspondance se fait par l’opérateur égalité (« = ») entre les valeurs des deux colonnes des deux\ntables : c’est une équi-jointure.\nAprès FROM les deux tables sont citées, et le critère d’équi-jointure sert de restriction. Sans cette restriction\nc’est un produit cartésien de EMP et de DEPT qui serait obtenu.\n1. Rechercher le prénom des employés et le numéro de la région de leur département.\nDerrière SELECT il peut y avoir nécessité de préﬁxer la colonne par le nom de la table. En effet si la colonne\napparaît dans plusieurs tables il y a ambiguïté.\nPour faciliter l’écriture des requêtes, les tables citées derrière FROM peuvent être renommées temporairement,\net l’alias peut être utilisé pour préﬁxer les colonnes.\n2. Rechercher le numéro du département, le nom du département, le nom des employés classés par numéro\nde département (renommer les tables utilisées).\nSi le critère de jointure est omis, le résultat est un produit cartésien inutilisable le plus souvent.\n3. Rechercher le nom de l’employé Amartakaldire et le nom de son département, ne pas utiliser de critère de\njointure (volontairement).\n7.2. Auto-jointures\nLa possibilité de renommer temporairement une table dans une requête permet de faire la jointure d’une\ntable sur elle-même, c’est à dire l’auto-jointure.\n4. Rechercher le nom et le salaire des employés qui gagnent plus que leur patron, et le nom et le salaire de\nleur patron.\n5. Rechercher le nom et le salaire des employés qui gagnent plus que Amartakaldire, le nom et le salaire de\nAmartakaldire.\n7.3. Sous-requêtes\nLe résultat d’une requête peut servir dans une clause de restriction d’une autre requête, on parlera alors de\nsous-requête imbriquée.\nLa recherche suivante peut se faire de deux manières.\n27\n\nChapitre 7. Les jointures et les sous-requêtes\n6. Rechercher le nom et le titre des employés qui ont le même titre que Amartakaldire.\nDans ce qui précède, la sous-requête retourne une seule valeur, l’opérateur égalité peut être utilisé. Si ce n’est\npas le cas il faut utiliser les clauses ANY ou ALL.\n7. Rechercher le nom, le salaire et le numéro de département des employés qui gagnent plus qu’un seul\nemployé du département 31, classés par numéro de département et salaire.\n8. Rechercher le nom, le salaire et le numéro de département des employés qui gagnent plus que tous les\nemployés du service 31, classés par numéro de département et salaire.\nEn fait : « IN » est équivalent à « = ANY », tandis que « NOT IN » est équivalent à « != ALL ».\n9. Rechercher le nom et le titre des employés du service 31 qui ont un titre que l’on trouve dans le service 32.\n10. Rechercher le nom et le titre des employés du service 31 qui ont un titre l’on ne trouve pas dans le service\n32.\n11. Rechercher le nom, le titre et le salaire des employés qui ont le même titre et le même salaire que Fairant.\nRenommer une table et utiliser une sous-requête permet de synchroniser une sous-requête avec la requête\nprincipale.\n12. Rechercher le numéro de département, le nom et le salaire des employés qui gagnent plus que la moyenne\nde leur département, classés par département.\nL’opérateur EXISTS permet de retourner des lignes si la sous-requête en retourne.\n13. Rechercher le numéro d’employé, le nom, le prénom des employés pour lesquel il existe au moins un\nReprésentant dans leur département.\n14. Rechercher le numéro de département, le nom du département dans lesquels il n’y a personne et montrer\nque le département ne contient pas d’employé.\n7.4. LEFT JOIN, RIGHT JOIN\nDans la table DEPT il y a des lignes avec un numéro de département qui ne correspondent à aucune ligne de\nEMP.\nCette ligne est à l’extérieur de la jointure entre les deux tables.\nSi on souhaite, malgré tout, obtenir dans le résultat de la jointure ces lignes extra on utilise un LEFT JOIN.\nPour bien comprendre le sens et la syntaxe de LEFT JOIN il peut être utile de revenir sur la syntaxe des\nrequêtes. Il faut savoir que la requête\nSELECT ... FROM a,b,c WHERE a.x=b.y AND b.z=c.t ...\npeut s’écrire également\nSELECT ... FROM a JOIN b ON a.x=b.y JOIN c ON b.z=c.t ...\nIl s’agit de la syntaxe originale des jointures en SQL.\nPour écrire un LEFT JOIN, la syntaxe est la même, en remplaçant bien entendu JOIN par LEFT JOIN.\n28\n\nChapitre 7. Les jointures et les sous-requêtes\nQu’est-ce que cela va changer ? On se souvient que pour une jointure normale on ne prend que les enregis-\ntrements de chaque table qu’on peut relier par la condition de jointure. Avec un LEFT JOIN on prendra en\nplus les enregistrements de la table écrite à gauche (car LEFT) de l’expression LEFT JOIN et qui ne sont reliés\nà aucun enregistrement de celle de droite.\nIl existe également RIGHT JOIN qui fonctionne de manière tout à fait symétrique.\n15. Rechercher le numéro de département, le nom du département, le nom des employés en tenant compte des\nnuméro de département dans lesquels il y a personne classé par numéro de département.\n29\n\nChapitre 7. Les jointures et les sous-requêtes\n30\n\nChapitre 8. Créer votre propre base\n8.1. Créer la base\nUtiliser d’abord la commande :\nCREATE DATABASE base ;\noù base est un nom à votre choix (qui ne doit pas déjà exister).\nConnectez vous ensuite à votre base\n\\c base\nPuis tapez (ou recopiez) les commandes suivantes.\n8.2. Créer les tables\n8.2.1. DEPT\nCREATE TABLE dept\n(nodept NUMERIC(2) NOT NULL\nCONSTRAINT dept_nodept_pk PRIMARY KEY,\nnom VARCHAR(25) ,\nnoregion NUMERIC(1) NOT NULL\n)\n;\n8.2.2. EMP\nCREATE TABLE emp\n(noemp NUMERIC(7) NOT NULL\nCONSTRAINT emp_noemp_pk PRIMARY KEY,\nnom VARCHAR(25) ,\nprenom VARCHAR(25) ,\nembauche DATE,\nnosupr NUMERIC(7) ,\ntitre\nVARCHAR(25) ,\nnodept NUMERIC(2) NOT NULL ,\nsalaire NUMERIC(11, 2) ,\ntx_commission NUMERIC(4, 2)\nCONSTRAINT emp_tx_commission_ck\nCHECK (tx_commission BETWEEN 10 AND 20) ,\nCONSTRAINT emp_nodept_fk\nFOREIGN KEY (nodept) REFERENCES dept(nodept)\n)\n;\n8.3. Remplir les tables\n8.3.1. DEPT\nINSERT INTO dept VALUES (10 , ’Finance’ , 1 ) ;\nINSERT INTO dept VALUES (20 , ’Atelier’ , 2 ) ;\nINSERT INTO dept VALUES (30 , ’Atelier’ , 3 ) ;\nINSERT INTO dept VALUES (31 , ’Vente’ , 1 ) ;\nINSERT INTO dept VALUES (32 , ’Vente’ , 2 ) ;\nINSERT INTO dept VALUES (33 , ’Vente’ , 3 ) ;\nINSERT INTO dept VALUES (34 , ’Vente’ , 4 ) ;\n31\n\nChapitre 8. Créer votre propre base\nINSERT INTO dept VALUES (35 , ’Vente’ , 5 ) ;\nINSERT INTO dept VALUES (41 , ’Distribution’ , 1 ) ;\nINSERT INTO dept VALUES (42 , ’Distribution’ , 2 ) ;\nINSERT INTO dept VALUES (43 , ’Distribution’ , 3 ) ;\nINSERT INTO dept VALUES (44 , ’Distribution’ , 4 ) ;\nINSERT INTO dept VALUES (45 , ’Distribution’ , 5 ) ;\nINSERT INTO dept VALUES (50 , ’Administration’ , 1 ) ;\n8.3.2. EMP\nINSERT INTO emp VALUES (1 , ’Patamob’ , ’Adhémar’ , ’03/26/2000’ ,\nNULL , ’Président’ , 50 , 50000 , NULL) ;\nINSERT INTO emp VALUES (2 , ’Zeublouze’ , ’Agathe’ , ’04/15/2000’ ,\n1 , ’Dir. Distrib’ , 41 , 35000 , NULL) ;\nINSERT INTO emp VALUES (3 , ’Kuzbidon’ , ’Alex’ , ’05/05/2000’ ,\n1 , ’Dir. Vente’ , 31 , 34000 , NULL) ;\nINSERT INTO emp VALUES (4 , ’Locale’ , ’Anasthasie’ , ’05/25/2000’ ,\n1 , ’Dir. Finance’ , 10 , 36000 , NULL) ;\nINSERT INTO emp VALUES (5 , ’Teutmaronne’ , ’Armand’ , ’06/14/2000’ ,\n1 , ’Dir. Administr’ , 50 , 36000 , NULL) ;\nINSERT INTO emp VALUES (6 , ’Zoudanlkou’ , ’Debbie’ , ’07/04/2000’ ,\n2 , ’Chef Entrepôt’ , 41 , 25000 , NULL) ;\nINSERT INTO emp VALUES (7 , ’Rivenbusse’ , ’Elsa’ , ’07/24/2000’ ,\n2 , ’Chef Entrepôt’ , 42 , 24000 , NULL) ;\nINSERT INTO emp VALUES (8 , ’Ardelpic’ , ’Helmut’ , ’08/13/2000’ ,\n2 , ’Chef Entrepôt’ , 43 , 23000 , NULL) ;\nINSERT INTO emp VALUES (9 , ’Peursconla’ , ’Humphrey’ , ’09/02/2000’ ,\n2 , ’Chef Entrepôt’ , 44 , 22000 , NULL) ;\nINSERT INTO emp VALUES (10 , ’Vrante’ , ’Héléna’ , ’09/22/2000’ ,\n2 , ’Chef Entrepôt’ , 45 , 21000 , NULL) ;\nINSERT INTO emp VALUES (11 , ’Enfaillite’ , ’Mélusine’ , ’10/12/2000’ ,\n3 , ’Représentant’ , 31 , 25000 , 10) ;\nINSERT INTO emp VALUES (12 , ’Eurktumeme’ , ’Odile’ , ’11/01/2000’ ,\n3 , ’Représentant’ , 32 , 26000 , 12.5) ;\nINSERT INTO emp VALUES (13 , ’Hotdeugou’ , ’Olaf’ , ’11/21/2000’ ,\n3 , ’Représentant’ , 33 , 27000 , 10) ;\nINSERT INTO emp VALUES (14 , ’Odlavieille’ , ’Pacôme’ , ’12/11/2000’ ,\n3 , ’Représentant’ , 34 , 25500 , 15) ;\nINSERT INTO emp VALUES (15 , ’Amartakaldire’ , ’Quentin’ , ’12/31/2000’ ,\n3 , ’Représentant’ , 35 , 23000 , 17.5) ;\nINSERT INTO emp VALUES (16 , ’Traibien’ , ’Samira’ , ’01/10/2001’ ,\n6 , ’Secrétaire’ , 41 , 15000 , NULL) ;\nINSERT INTO emp VALUES (17 , ’Fonfec’ , ’Sophie’ , ’01/20/2001’ ,\n6 , ’Secrétaire’ , 41 , 14000 , NULL) ;\nINSERT INTO emp VALUES (18 , ’Fairant’ , ’Teddy’ , ’02/09/2001’ ,\n7 , ’Secrétaire’ , 42 , 13000 , NULL) ;\nINSERT INTO emp VALUES (19 , ’Blaireur’ , ’Terry’ , ’02/09/2001’ ,\n7 , ’Secrétaire’ , 42 , 13000 , NULL) ;\nINSERT INTO emp VALUES (20 , ’Ajerre’ , ’Tex’ , ’02/19/2001’ ,\n8 , ’Secrétaire’ , 43 , 13000 , NULL) ;\nINSERT INTO emp VALUES (21 , ’Chmonfisse’ , ’Thierry’ , ’02/19/2001’ ,\n8 , ’Secrétaire’ , 43 , 12000 , NULL) ;\nINSERT INTO emp VALUES (22 , ’Phototetedemort’ , ’Thomas’ , ’03/01/2001’ ,\n9 , ’Secrétaire’ , 44 , 22500 , NULL) ;\nINSERT INTO emp VALUES (23 , ’Kaécouté’ , ’Xavier’ , ’03/11/2001’ ,\n9 , ’Secrétaire’ , 34 , 11500 , NULL) ;\nINSERT INTO emp VALUES (24 , ’Adrouille-Toultan’ , ’Yves’ , ’03/21/2001’ ,\n10 , ’Secrétaire’ , 45 , 11000 , NULL) ;\nINSERT INTO emp VALUES (25 , ’Anchier’ , ’Yvon’ , ’12/31/2000’ ,\n10 , ’Secrétaire’ , 45 , 10000 , NULL) ;\n32\n\nChapitre 8. Créer votre propre base\n8.4. Téléchargement\nVous trouverez aussi les ﬁchiers SQL à télécharger :\n• creer_dept.sql1 pour créer la table DEPT.\n• creer_emp.sql2 pour créer la table EMP.\n• remplir_dept.sql3 pour remplir la table DEPT.\n• remplir_emp.sql4 pour remplir la table EMP.\n1.\nhttp://www.grappa.univ-lille3.fr/polys/sql/exemples/creer_dept.sql\n2.\nhttp://www.grappa.univ-lille3.fr/polys/sql/exemples/creer_emp.sql\n3.\nhttp://www.grappa.univ-lille3.fr/polys/sql/exemples/remplir_dept.sql\n4.\nhttp://www.grappa.univ-lille3.fr/polys/sql/exemples/remplir_emp.sql\n33\n\nChapitre 8. Créer votre propre base\n34\n\nChapitre 9. Modiﬁcation de base, transactions, tables et vues\nVous trouverez les réponses des exercices au Chapitre 17.\nL’utilisateur qui a créé les tables a tous les droits sur ces tables. Si rien n’est précisé aucun autre utilisateur\nne peut faire la moindre modiﬁcation sur les tables (contenu ou structure). Ce qui fait que vous ne pourrez\ntester les commandes de ce chapitre que sur une base de données que vous aurez créée personnellement\n(voir Chapitre 8).\nOn étudiera plus tard (Chapitre 10) la possibilité de donner (ou enlever) aux autres utilisateurs les droits de\nmodiﬁer la base de données.\n9.1. Transactions\n9.1.1. Pourquoi utiliser les transactions ?\nLe principe de base des transactions est de grouper un ensemble de commandes de façon à être sûr que\nTOUTES les commandes seront exécutées, ou sinon qu’AUCUNE ne sera exécutée.\nDans quel but ? Pour pouvoir résoudre un certain de problèmes différents. Par exemple :\n• Imaginez une transaction bancaire : la banque doit débiter un compte pour en créditer un autre. Facile à\nréaliser avec deux commandes UPDATE. Mais que faire si une fois la première commande exécutée, on se\nrend compte que la deuxième ne peut pas l’être ? Il faut annuler la première. Regrouper les deux com-\nmandes dans une transaction permet d’automatiser ce comportement : si tout se passe bien les deux se\nferont, si un quelconque problème survient aucune ne se fera.\n• D’une manière plus générale, une suite de commandes quelconques qui entraîne des modiﬁcations de\nla base ne doit surtout pas être arrêtée en plein milieu, ce qui risquerait de laisser la base dans un état\ninconsistant. Une transaction transforme cette suite de commandes en un ensemble insécable (on dira\naussi atomique) : ou TOUT se fait, ou RIEN ne sera fait.\n• Les transactions permettent aussi de gérer les accès concurrents dans une base en réseau : si deux (ou\nplus) utilisateurs utilisent en même temps la même base pour exécuter chacun une série de commandes\ndu style :\n• commande1 : recherche d’une information dans une table (par exemple : calcul d’un stock disponible) ;\n• commande2 : modiﬁcation de la table en fonction de l’information reçue (par exemple retrait d’un certain\nnombre d’articles dans la limite du stock diponible).\nDans ce cas rien ne permet de supposer que tout se passera bien. Il est tout à fait possible que la séquence\nde commandes de déroule de la façon suivante : commande1 pour le premier client, puis commande1 pour\nle deuxième client, puis commande2 pour le premier client, puis commande2 pour le deuxième client.\nDans ce cas la commande2 du deuxième client a toutes les chances d’entraîner des erreurs car elle est basée\nsur un résultat calculé avant l’exécution de la commande2 du premier client.\nL’utilisation de transaction transforme chaque suite (commande1, commande2) en un bloc non interruptible\n(atomique) qui assure que l’information du deuxième ne sera fournie que quand le premier aura modiﬁé la\ntable.\n• Enﬁn il peut être utile de se ménager une porte de sortie quand on exécute une commande modiﬁant la\ntable : on peut se tromper, changer d’avis, vouloir seulement faire un essai, etc. Il est toujours utile de\ndisposer de l’équivalent du undo de la plupart des logiciels.\nLa seule solution est alors d’utiliser une transaction : une fois les commandes exécutées, on peut décider\nde tout abandonner (comme pour un undo) ou au contraire d’accepter tout.\nVous pourrez trouver d’autre explications sur l’utilité des transactions dans les pages suivantes :\n• Comment protéger des ensembles d’opérations par des transactions ?1\n• À quoi servent les transactions ?2\n1.\nhttp://hcesbronlavau.developpez.com/Transactions/\n2.\nhttp://sqlpro.developpez.com/cours/sqlaz/techniques/#L1\n35\n\nChapitre 9. Modiﬁcation de base, transactions, tables et vues\n• JDBC : Gestion des transactions3\n9.1.2. Comment utiliser les transactions ?\nUne transaction commence par « BEGIN ; » :\n• Si elle se termine par « ROLLBACK ; », aucune des modiﬁcations faites ne sera prise ne compte.\n• Si elle se termine par « COMMIT ; », toutes les modiﬁcations sont prises en compte.\n• Ne pas taper « BEGIN ; » avant de commencer vos modiﬁcations revient à taper chacune de vos com-\nmandes en mode autocommit : chaque instruction isolée est une transaction en elle-même, une fois tapée\nelle est exécutée comme si elle était précédée d’un « BEGIN ; » et suivie d’un « COMMIT ; », et elle ne peut\nplus être défaite.\nToutes les commandes qui vont suivre dans ce chapitre vont modiﬁer votre base de données. Nul n’est à\nl’abri d’une erreur, il vous est donc fortement conseillé d’inclure vos commandes dans des transactions,\npour vous permettre d’annuler éventuellement toute fausse manœuvre.\nDans notre cas il ne se produira rien de castrophique : cette base n’a pas d’importance vitale, et si vous y\nfaites des erreurs, il vous reste toujours la possibilité de la recréer complétement (Chapitre 8).\nDans la vraie vie c’est rarement le cas. C’est donc une bonne habitude à prendre...\n9.2. Modiﬁer le contenu\n9.2.1. Créer une table\nLa commande CREATE TABLE permet de créer une table. On la fait suivre d’une liste (entre parenthèses) des\nchamps accompagnés de leur type.\nExemple 9-1. CREATE TABLE\nCréons la table AFFAIRE qui gardera les informations sur les affaires en cours :\n• NOAFF, numérique sur 3 chiffres ; il s’agit de la clef primaire (bien que ce ne soit pas précisé dans sa\ndéclaration) ;\n• NOM, texte sur 10 caractères ; texte décrivant l’affaire ;\n• BUDGET, numérique sur 8 chiffres dont 2 après la virgule ; budget consacrée à l’affaire.\nCREATE TABLE AFFAIRE (\nNOAFF NUMERIC(3) NOT NULL,\nNOM VARCHAR (10) ,\nBUDGET NUMERIC(8,2))\n;\nOn peut également, à la place de la liste des champs, utiliser une requête (précédée de AS) pour remplir en\nmême temps la table.\n1. Créer une table TRUC copie d’une autre table (EMP, par exemple)\n3.\nhttp://www.inﬁni-fr.com/Sciences/Informatique/Langages/Imperatifs/Java/Jdbc/transactions.html\n36\n\nChapitre 9. Modiﬁcation de base, transactions, tables et vues\n9.2.2. Insertion de lignes\nLa commande INSERT permet de créer une nouvelle ligne dans une table.\nPar exemple, pour insérer une nouvelle ligne dans la table EMP, essayez la suite de commandes que voici :\nBEGIN /* début de transaction */\n;\nINSERT INTO EMP /* insertion d’une ligne dans la table EMP */\nVALUES (1001,’Bodinoz’,’Arnaud’,’1998-05-19’,null,1, 50,15000,null)\n;\nSELECT * FROM EMP\n/* liste, pour vériﬁer l’insertion */\n;\nROLLBACK /* on annule la transaction */\n;\nSELECT * FROM EMP\n/* on vériﬁe à nouveau : la nouvelle ligne n’est plus là */\n;\nBEGIN /* on recommence... */\n;\nINSERT INTO EMP\nVALUES (1001,’Bodinoz’,’Arnaud’,’1998-05-19’,null,1, 50,15000,null)\n;\nSELECT * FROM EMP\n/* on vériﬁe à nouveau */\n;\nCOMMIT /* on conﬁrme la transaction */\n;\nSELECT * FROM EMP\n/* la nouvelle ligne est toujours là */\n;\nLa mise à jour n’est prise en compte que si l’intégrité des données est satisfaite.\nPar exemple, si on veut insérer une nouvelle ligne dans la table EMP avec le numéro d’employé non renseigné :\nBEGIN\n;\nINSERT INTO EMP /* cela produit une erreur */\nVALUES (null,’Nogues’, ’Annie’, ’11-SEP-97’,null,1, 50,12000,null)\n;\nSELECT * FROM EMP /* l’insertion n’a pas eu lieu */\n;\nCOMMIT\n;\nMême quand on ne souhaite pas remplir toutes les colonnes on peut insérer une nouvelle ligne dans la table\nEMP sans utiliser la clause NULL pour les valeurs non renseignées.\nBEGIN\n;\nINSERT INTO EMP (NOEMP, NOM, EMBAUCHE, NODEPT) /\nVALUES (1002, ’Charon’,’22-APR-98’,50)\n; /* on a créé une nouvelle ligne en ne remplissant que 4 champs */\nSELECT *\nFROM EMP\nWHERE NOM = ’Charon’\n;\nCOMMIT\n;\nCréer la table BONUS vide avec la commande suivante :\nCREATE TABLE bonus (\nnom VARCHAR(25) ,\n/* nom d’un employé */\ntitre\nVARCHAR(25) ,\n/* son titre */\nsalaire NUMERIC(11, 2) ,\n/* son salaire */\ntx_commission NUMERIC(4, 2) /* son taux de commission*/\nCONSTRAINT emp_tx_commission_ck\nCHECK (tx_commission BETWEEN 10 AND 20)\n/* avec une contrainte sur le taux de commission qui devra être entre 10 et 20 */\n)\n;\n37\n\nChapitre 9. Modiﬁcation de base, transactions, tables et vues\nL’insertion dans une table peut se faire par une sélection dans une autre table. Par exemple pour ajouter dans\nla table BONUS les lignes de EMP dont le titre est Chef Entrepôt ou dont le taux de commission est supérieur\nà 14 :\nBEGIN\n;\nSELECT *\nFROM BONUS /* vériﬁer que la table est vide */\n;\nINSERT INTO BONUS /* insertion dans la table... */\nSELECT NOM, TITRE, SALAIRE, TX_COMMISSION\nFROM EMP\n/* ...à partir d’éléments de EMP */\nWHERE TITRE = ’Chef Entrepôt’\nOR TX_COMMISSION > 14\n;\nSELECT * /* vériﬁer que l’insertion est faite */\nFROM BONUS\n;\nCOMMIT\n;\n2. Insérer des données dans la table AFFAIRES :\n•\n101, ’ALPHA’ ,250000 ;\n•\n102, ’BETA’ , 175000 ;\n•\n103, ’GAMMA’ ,95000.\n9.2.3. Modiﬁcation de lignes\nLa commande UPDATE permet de mettre à jour dans une table une ou plusieurs colonnes pour une ou plu-\nsieurs lignes.\nPour mettre à jour le salaire de l’employé Amartakaldire, en l’augmentant de 10%, il faudra taper :\nBEGIN /* ça DOIT être un réﬂexe avant un UPDATE */\n;\nSELECT *\nFROM EMP\nWHERE NOM =’Amartakaldire’\n;\nUPDATE EMP\n/* modiﬁcation */\nSET SALAIRE = SALAIRE * 1.1 ;\nWHERE NOM = ’Amartakaldire’\n;\nSELECT * /* vériﬁcation */\nFROM EMP\nWHERE NOM =’Amartakaldire’\n;\nCOMMIT\n/* conﬁrmation */\n;\n3. Mettre à jour le titre (Représentant), le salaire (20000) et le taux de commission (15%) de Kaécouté.\n4. Augmenter de 5% les employés de la table EMP qui se trouvent dans la table BONUS.\n38\n\nChapitre 9. Modiﬁcation de base, transactions, tables et vues\n9.2.4. Suppression de lignes\nLa commande DELETE permet de supprimer une ou plusieurs lignes d’une table. Si elle n’est pas suivi d’une\nrestriction (WHERE, avec la même syntaxe que pour SELECT), c’est toute la table qui est effacée.\n5. Supprimer de la table BONUS l’employé Zoudanlkou.\n6. Supprimer l’employé Amartakaldire de la table BONUS.\n7. Supprimer l’employé Amartakaldire de la table EMP et faire ROLLBACK.\n8. Supprimer toutes les lignes de BONUS et faire ROLLBACK, recommencer mais faire COMMIT (et essayer ROLLBACK\naprès).\n9.2.5. Suppression d’une table\nLa commande DROP TABLE permet de détruire une table (lignes et structure).\nPour supprimer totalement la table EMP :\nDROP TABLE EMP ;\nPour la recréer voir Chapitre 8.\n9.2.6. Modiﬁcation de la structure d’une table\nLa commande ALTER TABLE permet de modiﬁer la structure de la table, même si elle contient des données.\nLes principales façons de l’utiliser sont :\nALTER TABLE nom RENAME TO nouveau_nom\nrenommer une table\nALTER TABLE nom RENAME colonne TO nouvelle_colonne\nrenommer une colonne d’une table\nALTER TABLE nom ADD colonne type\najouter une colonne à une table\nALTER TABLE nom DROP colonn\nsupprimer une colonne\nALTER TABLE nom ALTER colonne TYPE type\nchanger le type d’une colonne\nALTER TABLE nom OWNER TO nouveau_propriétaire\nchanger le propriétaire d’une table\n9. Modiﬁer la structure de EMP en ajoutant une colonne NOAFF.\n10. Mettre à jour la table EMP :\n•\nnoaff prend la valeur 101 quand nodept vaut 10 ou 50 ;\n•\nnoaff prend la valeur 102 quand nodept vaut 31, 32, 33, 34 ou 35 ;\n•\nnoaff prend la valeur 103 quand nodept vaut 41, 42, 43, 44 ou 45.\n11. Détruire la table AFFAIRE.\nDétruire et re-créer la table EMP à l’original.\n39\n\nChapitre 9. Modiﬁcation de base, transactions, tables et vues\n9.3. Vues\nUne vue est une table virtuelle, c’est-à-dire dont les données ne sont pas stockées dans une table de la base\nde données, et dans laquelle il est possible de rassembler des informations provenant de plusieurs tables.\nOn parle de « vue » car il s’agit simplement d’une représentation des données dans le but d’une exploitation\nvisuelle. Les données présentes dans une vue sont déﬁnies grâce à une clause SELECT.\nUne vue est une déﬁnition dynamique dans le sens suivant : si on modiﬁe, ou si on ajoute ou si on supprime\ndes enregistrements, chaque exécution de la vue comprendra ces modiﬁcations.\nLa norme SQL propose un ensemble important de restrictions pour la modiﬁcation ou l’insertion ou la mo-\ndiﬁcation des données dans les vues. Les systèmes de gestion de base de données ont aussi chacun leur\nimplantation de ce concept et chacun leurs contraintes et restrictions. En particulier, peu d’opérations sont\nautorisées dès qu’une vue porte sur plusieurs tables ; aucune n’est possible si la vue comporte des opérateurs\nd’agrégation.\nEn PostgreSQL les vues ne sont que consultables par des instructions SELECT. Aucune autre opération n’est\npossible. Par contre, c’est la notion propre à PostgreSQL de règles qui assure cette fonctionnalité. Cette notion\ns’avère plus souple et puissante que les restrictions communément appliquées aux SGBD classiques.\nLa commande CREATE VIEW permet de créer une vue relative à une ou plusieurs tables de la base. Elle est\nsuivie de AS puis d’une requête qui la déﬁnit.\n12. Créer une vue relative au numéro, nom et titre des employés des départements supérieurs à 40 et utiliser la\nvue pour interroger. Mettre à jour EMP et utiliser la vue pour interroger.\nDans la version actuelle de PostgreSQL une vue ne peut pas servir à mettre à jour une table.\n13. Essayez de mettre à jour la table EMP en utilisant la vue DEPT4.\n14. Créer une vue relative au nom, numéro de service des employés et au nom du service. Utiliser la vue.\n15. Créer une vue relative au nom, salaire et salaire annuel des employés.\n40\n\nChapitre 10. Les droits\nVous trouverez les réponses des exercices au Chapitre 18.\nUne table ayant été créée, son propriétaire peut accorder (GRANT) ou retirer (REVOKE) à un\nautre utilisateur\n(ou à tous : PUBLIC) les droits suivants :\n• SELECT : Accès en lecture à toutes les colonnes d’une table ou d’une vue.\n• INSERT : Insérer des données dans toutes les colonnes d’une table.\n• UPDATE : Mettre à jour dans toutes les colonnes d’une table.\n• DELETE : Supprimer des enregistrements d’une table.\n• ALL : Donner tous les privilèges.\nLa syntaxe en est :\nGRANT droit ON table TO user ;\nREVOKE droit ON table FROM user ;\nÀ tout moment vous pouvez afﬁcher les droits actuellement donnés par la commande « \\dp » ou « \\z ».\n1. Accorder le droit de SELECT sur la table DEPT à un autre user.\n2. Accorder les droits de INSERT et UPDATE sur DEPT à un autre user.\n3. Accorder tous les droits sur la table DEPT à un autre user.\n4. Créer une vue relative au numéro, nom, titre, numéro de département des employés.\nPuis accorder les droits de SELECT sur la vue à un autre user\n5. Créer une vue relative à toutes les informations des employés du service 50.\nPuis accorder tous les droits sur la vue à un autre user.\n6. Retirer le droit INSERT à l’autre user, sur la table DEPT.\n41\n\nChapitre 10. Les droits\n42\n\nChapitre 11. Les groupes\nVous trouverez les réponses des exercices au Chapitre 19.\n11.1. Utilisation de fonctions de groupe\nPar exemple : AVG (moyenne), MIN (minimum), MAX (maximum), COUNT (dénombrement)...\nCes fonctions travaillent au niveau de groupe de lignes et non plus au niveau des lignes.\nExemple 11-1. Moyenne\nPar exemple pour rechercher la moyenne des salaires des secrétaires :\nSELECT AVG(SALAIRE)\nFROM EMP\nWHERE TITRE = ’Secrétaire’\n;\nAvec SELECT on ne peut pas travailler à la fois au niveau des lignes et des groupes.\nSi vous recherchez le nom et la moyenne des salaires des employés (cette phrase a-t-elle d’ailleurs un sens ?),\nvous allez essayer :\nSELECT NOM, AVG(SALAIRE)\nFROM EMP\n;\nCe qui ne produira qu’un message d’erreur.\nPar contre avec deux SELECT imbriqués on peut rechercher le nom et le salaire de l’employé dont le salaire\nest le plus grand.\nSELECT NOM, SALAIRE\nFROM EMP\nWHERE SALAIRE = (SELECT MAX (SALAIRE)\nFROM EMP\n)\n;\n11.2. Les groupes\nPour exprimer le groupe sur lequel doit porter la fonction de groupe on utilise la clause GROUP BY.\nCes fonctions et clauses peuvent s’utiliser avec une jointure.\nToute colonne qui intervient dans l’afﬁchage sans être utilisée dans une fonction de groupe doit être aussi\nincluse dans la clause GROUP BY.\nPour rechercher la moyenne des salaires de chaque département on écrira :\nSELECT NODEPT, AVG(SALAIRE)\nFROM EMP\nGROUP BY NODEPT\n;\n43\n\nChapitre 11. Les groupes\n11.3. La clause HAVING\nLa clause WHERE permet d’écrire une restriction au niveau ligne, la clause HAVING permet d’écrire une restric-\ntion au niveau groupe.\nPour rechercher les titres et le nombre d’employés pour les titres représentés plus de 2 fois, on écrira :\nSELECT TITRE, COUNT(*)\nFROM EMP\nGROUP BY TITRE\nHAVING COUNT(*) > 2\n;\n11.4. Exercices\n1. Rechercher le salaire maximum et le salaire minimum parmi tous les salariés et l’écart entre les deux.\n2. Rechercher le nombre de titres différents.\n3. Rechercher le numéro de département, le titre et le nombre d’employés par département, titre.\n4. Rechercher le nom du département, le titre et le nombre d’employés par département, titre.\n5. Rechercher les titres et la moyenne des salaires par titre dont la moyenne est supérieure à la moyenne des\nsalaires des Représentants.\n6. Rechercher le nombre de salaires renseignés et le nombre de taux de commission renseignés.\n7. Rechercher la moyenne des taux de commission renseignés et la moyenne des taux de commission en\ntenant compte des taux de commission non renseignés.\n44\n\nChapitre 12. Les dates\nVous trouverez les réponses des exercices au Chapitre 20.\n12.1. Généralités\nPour avoir la description de la table EMP, vous pouvez utiliser la commande « \\d emp ». Cela vous permettra\nde vériﬁer que la colonne embauche est bien de type date.\n1. Rechercher le nom et la date d’embauche des employés.\nPuis recommencez plusieurs fois en faisant précéder votre requête de l’instruction « SET DATESTYLE TO\nxxx ; » avec les valeurs suivantes de\nxxx :\n’European’ ’ISO’ ’Postgres’ DEFAULT ’German’ ’NonEuropean’ ’SQL’\n12.2. Afﬁchage d’une date\nL’afﬁchage d’une date peut être modiﬁé en utilisant la fonction TO_CHAR :\nTO_CHAR(arg1,arg2)\noù arg1 est une colonne (ou valeur) de type DATE, et arg2 est un masque de sortie (chaîne de caractères).\nTableau 12-1. Liste des masques au format numérique\nMasque\nSigniﬁcation\nCC\nSiècle\nYYYY\nAnnée\nYYY\n3 derniers chiffres de l’année\nYY\n2 derniers chiffres de l’année\nY\nLe dernier chiffre de l’année\nQ\nTrimestre\nWW\nSemaine dans l’année\nW\nSemaine dans le mois\nMM\nMois\nDDD\nJour dans l’année\nDD\nJour dans le mois\nD\nJour dans la semaine\nHH ou HH12\nHeure de la journée (1-12)\nHH24\nHeure de la journée (0-23)\nMI\nMinutes\nSS\nSecondes\nSSSSS\nSecondes aprés minuit (0-86399)\nJ\nJour julien\nExemple 12-1. Utilisation de TO_CHAR (numérique)\nSELECT TO_CHAR(embauche,’CC’), TO_CHAR(embauche,’W’) FROM emp ;\nSELECT TO_CHAR(embauche,’DD/MM/YYYY’) FROM emp ;\nSELECT TO_CHAR(embauche, WWème semaine, MMème mois’) FROM emp ;\n45\n\nChapitre 12. Les dates\nTableau 12-2. Liste des masques au format caractère\nMasque\nSigniﬁcation\nMONTH\nNom du mois en toutes lettres\nMON\n3 premieres lettres du nom du mois\nDAY\nNom du jour en toutes lettres\nDY\n3 premieres lettres du nom du jour\nAM ou PM\nAvant midi ou aprés midi\nBC ou AD\nAvant ou aprés J.C.\nExemple 12-2. Utilisation de TO_CHAR (caractères)\nSELECT TO_CHAR(embauche,’DAY MONTH YYYY’) FROM emp ;\nSELECT TO_CHAR(embauche,’DY MON YYYY BC’) FROM emp ;\nTableau 12-3. Masque de sufﬁxe\nMasque\nSigniﬁcation\nTH\nST, ND, RD, TH aprés le nombre\nExemple 12-3. Utilisation de TO_CHAR (sufﬁxe)\nSELECT TO_CHAR(embauche, WWTH semaine, MMTH mois, CCTH siècle’) FROM emp ;\nLe masque d’afﬁchage par défaut est YYYY-MM-DD.\n2. Rechercher le nom et la date d’embauche (masque dd/mm/yy) des employés du département 41.\n3. Rechercher le nom et la date d’embauche (masque Day DD Month YYYY) des employés du département 41.\n4. Rechercher le nom et la date d’embauche (masque DD MON yyyy HH24:MI:SS) des employés.\n12.3. Calculs sur les dates\nUne colonne de type DATE peut être additionnée à un nombre qui sera considéré comme un nombre de jours\nmême s’il est fractionnaire. Le résultat afﬁché sera une date.\n5. Rechercher le nom, la date d’embauche (masque par défaut) et la date d’embauche + 90 jours renommée\n« Fin période essai » des employés du département 41.\nLa différence entre deux dates sera un nombre de jours qui peut être fractionnaire si les dates stockées\ncontiennent des heures, des minutes et des secondes.\n6. Rechercher le nom et l’intervalle en jours entre aujourd’hui et la date d’embauche (renommé DELTA) des\nemployés.\nLa date actuelle s’obtient par « CURRENT_DATE » ;\nL’instant actuel (avec heures, minutes, secondes et fractions de secondes) s’obtient par « NOW() », qu’on peut\ntransformer en date simple par « CAST(NOW() AS DATE) ».\nLes calculs sur les dates peuvent servir de critères de restriction.\n46\n\nChapitre 12. Les dates\n7. Rechercher le nom, la date d’embauche des employés embauchés moins d’une année après la première\nembauche d’un employé.\n47\n\nChapitre 12. Les dates\n48\n\nChapitre 13. Exercices récapitulatifs\nVous trouverez les réponses des exercices au Chapitre 21.\n1. Afﬁcher le nombre d’employés de chaque département (en afﬁchant les noms des départements).\n2. Afﬁcher dans l’ordre alphabétique la liste des employés qui possédent plus de deux subordonnés (donc au\nmoins 3).\n3. Afﬁcher les employés qui ont le salaire minimum et le salaire maximum.\n4. Afﬁcher par ordre alphabétique les employés qui ont au moins deux niveaux de subordonnés (ils sont le\nsupérieur de quelqu’un, qui est lui-même le supérieur de quelqu’un).\n5. Afﬁcher le nom du département qui a le plus d’employés.\n6. Afﬁcher l’employé dont le salaire est le plus proche du salaire moyen des employés.\n49\n\nChapitre 13. Exercices récapitulatifs\n50\n\nChapitre 14. Réponses aux premiers exercices sur la base jouet\nVous trouverez les énoncés correspondant au Chapitre 4.\nSolution de l’exercice 1\na\nb\nc\nx\nm\n2\nx\nn\n1\ny\nm\n4\nz\np\n1\nSolution de l’exercice 2\na\nx\nx\ny\nz\nSolution de l’exercice 3\na\nx\nz\nSolution de l’exercice 4\na\nx\nx\nz\nSolution de l’exercice 5\na\nx\nz\nSolution de l’exercice 6\na\n51\n\nChapitre 14. Réponses aux premiers exercices sur la base jouet\na\nx\ny\nx\nz\nSolution de l’exercice 7\na\ne\nx\n8\nx\n4\nx\n1\nx\n8\nx\n4\nx\n1\ny\n8\ny\n4\ny\n1\nz\n8\nz\n4\nz\n1\nOn remarquera que cela donne 12 lignes c’est-à-dire 4×3, soit le produit du nombre de lignes de UN et du\nnombre de lignes de DEUX.\nSolution de l’exercice 8\na\ne\nx\n1\ny\n8\nz\n1\n52\n\nChapitre 15. Réponses aux premiers exercices sur la commande\nSELECT\nVous trouverez les énoncés correspondant au Chapitre 6.\nSolution de l’exercice 1\nSELECT *\nFROM EMP ;\nSolution de l’exercice 2\nSELECT *\nFROM DEPT\n;\nSolution de l’exercice 3\nSELECT NOM, EMBAUCHE, NOSUPR, NODEPT, SALAIRE\nFROM EMP\n;\nSolution de l’exercice 4\nSELECT TITRE\nFROM EMP\n;\nSolution de l’exercice 5\nSELECT DISTINCT TITRE\nFROM EMP\n;\nSolution de l’exercice 6\nSELECT NOM, NOEMP, NODEPT\nFROM EMP\nWHERE TITRE = ’Secrétaire’\n;\nLa valeur Secrétaire est entre deux « ’ » car la colonne TITRE est alpha-numérique, ce qui n’est pas le cas\npour NODEPT qui est numérique.\nSolution de l’exercice 7\nSELECT NOM, NODEPT\nFROM DEPT\nWHERE NODEPT > 40\n;\n53\n\nChapitre 15. Réponses aux premiers exercices sur la commande SELECT\nSolution de l’exercice 8\nSELECT NOM, PRENOM\nFROM EMP\nWHERE NOM < PRENOM\n;\nSolution de l’exercice 9\nSELECT NOM, SALAIRE, NODEPT\nFROM EMP\nWHERE TITRE = ’Représentant’\nAND NODEPT = 35\nAND SALAIRE > 20000\n;\nSolution de l’exercice 10\nSELECT NOM, TITRE, SALAIRE\nFROM EMP\nWHERE TITRE = ’Représentant’\nOR TITRE = ’Président’\n;\nSolution de l’exercice 11\nSELECT NOM, TITRE, NODEPT, SALAIRE\nFROM EMP\nWHERE (TITRE = ’Représentant’ OR TITRE = ’Secrétaire’)\nAND NODEPT = 34\n;\nSi les clauses de restriction sont reliées par « AND » ou « OR », ATTENTION aux parenthèses.\nSolution de l’exercice 12\nSELECT NOM, TITRE, NODEPT, SALAIRE\nFROM EMP\nWHERE TITRE = ’Représentant’\nOR (TITRE = ’Secrétaire’ AND NODEPT = 34)\n;\nSolution de l’exercice 13\nSELECT NOM, SALAIRE\nFROM EMP\nWHERE SALAIRE >= 20000 AND SALAIRE <= 30000\n;\nLa clause « WHERE SALAIRE >= 20000 AND SALAIRE <= 30000 » peut s’écrire avec l’opérateur « BETWEEN » :\nSELECT NOM, SALAIRE\nFROM EMP\nWHERE SALAIRE BETWEEN 20000 AND 30000\n;\n54\n\nChapitre 15. Réponses aux premiers exercices sur la commande SELECT\nSolution de l’exercice 14\nSELECT NOM, TITRE, NODEPT\nFROM EMP\nWHERE TITRE=’Représentant’ OR TITRE=’Secrétaire’\n;\nLa clause « WHERE colonne IN (’val1’, ’val2’) » permet d’éviter « WHERE colonne = ’val1’ OR colonne\n= ’val2’ » :\nSELECT NOM, TITRE, NODEPT\nFROM EMP\nWHERE TITRE IN (’Représentant’ , ’Secrétaire’)\n;\nSolution de l’exercice 15\nSELECT NOM\nFROM EMP\nWHERE NOM LIKE ’H%’\n;\nSolution de l’exercice 16\nSELECT NOM\nFROM EMP\nWHERE NOM LIKE ’%n’\n;\nSolution de l’exercice 17\nSELECT NOM\nFROM EMP\nWHERE NOM LIKE ’__u%’\n;\nSolution de l’exercice 18\nSELECT SALAIRE, NOM\nFROM EMP\nWHERE NODEPT = 41\nORDER BY SALAIRE\n;\nSolution de l’exercice 19\nSELECT SALAIRE, NOM\nFROM EMP\nWHERE NODEPT = 41\nORDER BY SALAIRE DESC\n;\n55\n\nChapitre 15. Réponses aux premiers exercices sur la commande SELECT\nSolution de l’exercice 20\nSELECT TITRE, SALAIRE, NOM\nFROM EMP\nORDER BY TITRE, SALAIRE DESC\n;\nSolution de l’exercice 21\nSELECT TX_COMMISSION, SALAIRE, NOM\nFROM EMP\nORDER BY TX_COMMISSION\n;\nSolution de l’exercice 22\nSELECT NOM, SALAIRE, TX_COMMISSION, TITRE\nFROM EMP\nWHERE TX_COMMISSION IS NULL\n;\nSolution de l’exercice 23\nSELECT NOM, SALAIRE, TX_COMMISSION, TITRE\nFROM EMP\nWHERE TX_COMMISSION IS NOT NULL\n;\nSolution de l’exercice 24\nSELECT NOM, SALAIRE, TX_COMMISSION, TITRE\nFROM EMP\nWHERE TX_COMMISSION < 15\n;\nPar défaut, les colonnes alphanumériques non renseignées ne sont pas considérées comme une suite d’espaces,\nles colonnes numériques ne sont pas considérées comme égale à 0.\nSolution de l’exercice 25\nSELECT NOM, SALAIRE, TX_COMMISSION, SALAIRE * TX_COMMISSION/100\nFROM EMP\nWHERE TX_COMMISSION IS NOT NULL\n;\nSolution de l’exercice 26\nSELECT NOM, SALAIRE, TX_COMMISSION, SALAIRE * TX_COMMISSION/100\nFROM EMP\nWHERE TX_COMMISSION IS NOT NULL\nORDER BY 3\n;\n56\n\nChapitre 15. Réponses aux premiers exercices sur la commande SELECT\nSolution de l’exercice 27\nSELECT NOM, SALAIRE * (1 + TX_COMMISSION/100) AS \"Rémunération\ntotale\"\nFROM EMP ;\nCertains salaires semblent vides. C’est parce qu’une expression algébrique1 qui contient une valeur NULL\ndonne toujours un résultat NULL. Une valeur NULL n’est pas considérée comme zéro.\nSolution de l’exercice 28\nSELECT NOM, SALAIRE * (1 + COALESCE(TX_COMMISSION,0)/100) AS \"Remuneration totale\"\nFROM EMP\n;\nSolution de l’exercice 29\nSELECT NOM, SALAIRE AS \"PAR MOIS\", ROUND (SALAIRE/150,2) AS \"PAR HEURE\"\nFROM EMP\nWHERE NODEPT = 35\n;\nSolution de l’exercice 30\nSELECT NOM ||’ ’|| PRENOM AS \"Nom, Prenom\"\nFROM EMP\n;\nSolution de l’exercice 31\nSELECT NOM, NODEPT,\nCASE WHEN NODEPT=10 THEN ’Vu’\nWHEN NODEPT=50 THEN ’Pas vu’\nELSE ’En cours’\nEND AS \"Situation\"\nFROM DEPT\n;\nSolution de l’exercice 32\nSELECT CASE WHEN NODEPT=41 THEN PRENOM\nELSE NOM\nEND AS \"NOM OU PRENOM\", NODEPT, SALAIRE\nFROM EMP\nORDER BY 2\n;\nSolution de l’exercice 33\nSELECT SUBSTR (NOM, 1,5)\nFROM EMP\n;\n1.\nIci : SALAIRE*(1+TX_COMMISSION/100).\n57\n\nChapitre 15. Réponses aux premiers exercices sur la commande SELECT\nSolution de l’exercice 34\nPour la position à partir du début :\nSELECT NOM, STRPOS (NOM,’r’)\nFROM EMP\n;\nPour avoir le résultat à partir de la 3ème lettre, il sufﬁt de « supprimer » les 2 premières...\nSELECT NOM, STRPOS (SUBSTR(NOM,3),’r’)\nFROM EMP\n;\nSolution de l’exercice 35\nSELECT NOM, UPPER(NOM) , LOWER(NOM)\nFROM EMP\nWHERE UPPER(NOM) = UPPER(’Vrante’)\n;\nSolution de l’exercice 36\nSELECT NOM, LENGTH(NOM)\nFROM EMP\n;\nSolution de l’exercice 37\nSELECT NOM, ’Salaire’ AS \"TYPE\", SALAIRE AS \"MONTANT\"\nFROM EMP\nUNION\nSELECT NOM, ’Commission’ AS \"TYPE\", SALAIRE * TX_COMMISSION/100\nAS \"MONTANT\"\nFROM EMP\nWHERE TX_COMMISSION IS NOT NULL\n;\nSolution de l’exercice 38\nSELECT NODEPT\nAS \"Dep.\"\nFROM EMP\nINTERSECT\nSELECT NODEPT AS \"Dep.\"\nFROM DEPT\n;\nSolution de l’exercice 39\nSELECT NODEPT AS \"Dep.\"\nFROM DEPT\nEXCEPT\nSELECT NODEPT AS \"Dep.\"\nFROM EMP\n;\n58\n\nChapitre 16. Réponses aux exercices sur les jointures et les\nsous-requêtes\nVous trouverez les énoncés correspondant au Chapitre 7.\nSolution de l’exercice 1\nSELECT PRENOM, NOREGION\nFROM EMP,DEPT\nWHERE EMP.NODEPT = DEPT.NODEPT\n;\nSolution de l’exercice 2\nSELECT D.NODEPT, D.NOM, E.NOM\nFROM EMP E, DEPT D\nWHERE E.NODEPT = D.NODEPT\nORDER BY D.NODEPT\n;\nSolution de l’exercice 3\nSELECT EMP.NOM, DEPT.NOM\nFROM EMP,DEPT\nWHERE EMP.NOM = ’Amartakaldire’\n;\nSolution de l’exercice 4\nSELECT E.NOM, E.SALAIRE, P.NOM, P.SALAIRE\nFROM EMP E,EMP P\nWHERE E.NOSUPR = P.NOEMP\nAND E.SALAIRE > P.SALAIRE\n;\nSolution de l’exercice 5\nSELECT X.NOM, X.SALAIRE, Y.NOM, Y.SALAIRE\nFROM EMP X, EMP Y\nWHERE X.SALAIRE > Y.SALAIRE\nAND Y.NOM = ’Amartakaldire’\n;\nSolution de l’exercice 6\nSELECT TITRE\nFROM EMP\nWHERE NOM =’Amartakaldire’\n;\nSELECT NOM\nFROM EMP\nWHERE TITRE = ’Représentant’\n;\nMais aussi... (et c’est mieux !) :\n59\n\nChapitre 16. Réponses aux exercices sur les jointures et les sous-requêtes\nSELECT NOM, TITRE\nFROM EMP\nWHERE TITRE = (SELECT TITRE\nFROM EMP\nWHERE NOM = ’Amartakaldire’)\n;\nSolution de l’exercice 7\nSELECT NOM, SALAIRE, NODEPT\nFROM EMP\nWHERE SALAIRE > ANY (SELECT SALAIRE\nFROM EMP\nWHERE NODEPT = 31)\nORDER BY 3, 2\n;\nSolution de l’exercice 8\nSELECT NOM, SALAIRE, NODEPT\nFROM EMP\nWHERE SALAIRE > ALL (SELECT SALAIRE\nFROM EMP\nWHERE NODEPT = 31)\nORDER BY 3, 2\n;\nSolution de l’exercice 9\nSELECT NOM, TITRE\nFROM EMP\nWHERE NODEPT = 31\nAND TITRE IN (SELECT TITRE\nFROM EMP\nWHERE NODEPT = 32)\n;\nSolution de l’exercice 10\nSELECT NOM, TITRE\nFROM EMP\nWHERE NODEPT = 31\nAND TITRE NOT IN (SELECT TITRE\nFROM EMP\nWHERE NODEPT = 32)\n;\nSolution de l’exercice 11\nSELECT NOM, TITRE, SALAIRE\nFROM EMP\nWHERE (TITRE, SALAIRE) = (SELECT TITRE, SALAIRE\nFROM EMP\nWHERE NOM = ’Fairant’)\n;\n60\n\nChapitre 16. Réponses aux exercices sur les jointures et les sous-requêtes\nSolution de l’exercice 12\nSELECT NODEPT, NOM, SALAIRE\nFROM EMP E\nWHERE SALAIRE > (SELECT AVG(SALAIRE)\nFROM EMP\nWHERE NODEPT = E.NODEPT)\nORDER BY NODEPT\n;\nSolution de l’exercice 13\nSELECT NOEMP, NOM, PRENOM\nFROM EMP E\nWHERE EXISTS (SELECT NULL\nFROM EMP\nWHERE TITRE=’Représentant’\nAND NODEPT = E.NODEPT)\n;\nSolution de l’exercice 14\nSELECT NODEPT, NOM AS \"Dept\"\nFROM DEPT\nWHERE NODEPT NOT IN (SELECT DEPT.NODEPT\nFROM EMP, DEPT\nWHERE EMP.NODEPT = DEPT.NODEPT)\n;\nSolution de l’exercice 15\nAvec LEFT JOIN cela donne :\nSELECT D.NODEPT,D.NOM,E.NOM\nFROM DEPT D LEFT JOIN EMP E\nON E.NODEPT=D.NODEPT\nORDER BY D.NOM\n;\nOn peut aussi se passer de LEFT JOIN (certains systèmes ne l’autorisent pas), mais c’est moins simple. Avec\nune union cela donne :\n(\nSELECT DEPT.NODEPT, DEPT.NOM AS \"Dept\", EMP.NOM AS \"Emp\"\nFROM EMP, DEPT\nWHERE EMP.NODEPT = DEPT.NODEPT\nUNION\nSELECT NODEPT, NOM AS \"Dept\", NULL AS \"Emp\"\nFROM DEPT\n)\nORDER BY DEPT.NODEPT\n;\nMais on a une ligne vide pour chaque département, même quand ce n’est pas nécessaire. On peut améliorer\nainsi :\n(\nSELECT DEPT.NODEPT, DEPT.NOM AS \"Dept\", EMP.NOM AS \"Emp\"\nFROM EMP, DEPT\nWHERE EMP.NODEPT = DEPT.NODEPT\nUNION\nSELECT NODEPT, NOM AS \"Dept\", NULL AS \"Emp\"\nFROM DEPT\nWHERE NODEPT NOT IN (SELECT DEPT.NODEPT\n61\n\nChapitre 16. Réponses aux exercices sur les jointures et les sous-requêtes\nFROM EMP, DEPT\nWHERE EMP.NODEPT = DEPT.NODEPT)\n)\nORDER BY \"Dept\"\n;\n62\n\nChapitre 17. Réponses aux exercices sur modiﬁcation de base, etc.\nVous trouverez les énoncés correspondant au Chapitre 9.\nSolution de l’exercice 1\nCREATE TABLE TRUC\nAS (SELECT *\nFROM EMP)\n;\nSELECT * FROM TRUC;\nSolution de l’exercice 2\nINSERT INTO AFFAIRE VALUES (101, ’ALPHA’ ,250000)\n;\nINSERT INTO AFFAIRE VALUES (102, ’BETA’ , 175000)\n;\nINSERT INTO AFFAIRE VALUES (103, ’GAMMA’ ,95000)\n;\nSELECT * FROM AFFAIRE\n;\nSELECT * FROM AFFAIRE ;\nSolution de l’exercice 3\nBEGIN\n;\nSELECT * FROM EMP WHERE NOM =’Kaécouté’\n;\nUPDATE EMP\nSET TITRE = ’Représentant’ ,\nSALAIRE = 20000 ,\nTX_COMMISSION = 15\nWHERE NOM = ’Kaécouté’\n;\nSELECT * FROM EMP WHERE NOM =’Kaécouté’\n;\nCOMMIT ;\nSolution de l’exercice 4\nBEGIN\n;\nSELECT *\nFROM EMP\nWHERE NOM IN (SELECT NOM\nFROM BONUS)\n;\nUPDATE EMP\nSET SALAIRE = SALAIRE * CAST (1.05 AS NUMERIC)\nWHERE NOM IN (SELECT NOM\nFROM BONUS)\n;\nSELECT *\nFROM EMP\nWHERE NOM IN (SELECT NOM\nFROM BONUS)\n;\nCOMMIT ;\n63\n\nChapitre 17. Réponses aux exercices sur modiﬁcation de base, etc.\nSolution de l’exercice 5\nBEGIN\n;\nSELECT * FROM BONUS\n;\nDELETE FROM BONUS WHERE NOM = ’Zoudanlkou’\n;\nSELECT *\nFROM BONUS\n;\nCOMMIT ;\nSolution de l’exercice 6\nBEGIN\n;\nSELECT NOM FROM BONUS\n;\nDELETE FROM BONUS WHERE NOM = ’Amartakaldire’\n;\nSELECT NOM FROM BONUS\n;\nCOMMIT;\nSolution de l’exercice 7\nBEGIN\n;\nSELECT * FROM EMP WHERE NOM =’Amartakaldire’\n;\nDELETE FROM EMP WHERE NOM = ’Amartakaldire’\n;\nSELECT *\nFROM EMP WHERE NOM =’Amartakaldire’\n;\nROLLBACK\n;\nSELECT * FROM EMP WHERE NOM =’Amartakaldire’ ;\nSolution de l’exercice 8\nBEGIN\n;\nSELECT * FROM BONUS\n;\nDELETE\nFROM BONUS\n;\nSELECT * FROM BONUS\n;\nROLLBACK\n;\nSELECT * FROM BONUS\n;\nBEGIN\n;\nDELETE FROM BONUS\n;\nSELECT * FROM BONUS\n;\nCOMMIT\n;\nROLLBACK\n;\nSELECT * FROM BONUS;\n64\n\nChapitre 17. Réponses aux exercices sur modiﬁcation de base, etc.\nSolution de l’exercice 9\nALTER TABLE EMP\nADD NOAFF NUMERIC(3) ;\nSolution de l’exercice 10\nBEGIN\n;\nSELECT NOM, NOAFF FROM EMP\n;\nUPDATE EMP\nSET NOAFF = 101\nWHERE NODEPT IN (10,50)\n;\nSELECT NOM, NOAFF FROM EMP WHERE NOAFF = 101\n;\nUPDATE EMP\nSET NOAFF = 102\nWHERE NODEPT IN (31,32,33,34,35)\n;\nSELECT NOM, NOAFF FROM EMP WHERE NOAFF = 102\n;\nUPDATE EMP\nSET NOAFF = 103\nWHERE NODEPT IN (41,42,43,44,45)\n;\nSELECT NOM, NOAFF FROM EMP\n;\nCOMMIT ;\nSolution de l’exercice 11\nDROP TABLE AFFAIRE ;\nPour la table EMP voir plus haut.\nSolution de l’exercice 12\nBEGIN\n;\nCREATE VIEW DEPT4\nAS SELECT NOEMP, NOM, TITRE\nFROM EMP\nWHERE NODEPT > 40\n;\nSELECT * FROM DEPT4\n;\nSELECT NOM, TITRE FROM DEPT4 WHERE NOEMP > 20\n;\nUPDATE EMP\nSET TITRE = ’Chef Entrepôt’\nWHERE NOM = ’Phototetedemort’\n;\nSELECT * FROM DEPT4\n;\nCOMMIT ;\n65\n\nChapitre 17. Réponses aux exercices sur modiﬁcation de base, etc.\nSolution de l’exercice 13\nUPDATE DEPT4\nSET TITRE = ’Chef Entrepôt’\nWHERE NOM = ’Anchier’\n;\nSELECT * FROM DEPT4 ;\nSolution de l’exercice 14\nCREATE VIEW EMPDEPT(NOM, NOSERV, NOMSERV)\nAS SELECT EMP.NOM, EMP.NODEPT, DEPT.NOM\nFROM EMP,DEPT\nWHERE EMP.NODEPT = DEPT.NODEPT\n;\nSELECT NOM, NOMSERV FROM EMPDEPT WHERE NOSERV = 50 ;\nSolution de l’exercice 15\nCREATE VIEW PAYE (NOM, SALAIRE, SALANNUEL)\nAS SELECT NOM, SALAIRE, SALAIRE * 13\nFROM EMP\n;\nSELECT * FROM PAYE ;\n66\n\nChapitre 18. Réponses aux exercices sur les droits\nVous trouverez les énoncés correspondant au Chapitre 10.\nSolution de l’exercice 1\nGRANT SELECT\nON DEPT\nTO nom de l’autre user ;\nSolution de l’exercice 2\nGRANT INSERT,UPDATE\nON DEPT\nTO nom de l’autre user ;\nSolution de l’exercice 3\nGRANT ALL ON DEPT TO nom de l’autre user ;\nSolution de l’exercice 4\nCREATE VIEW EMPVUE AS\nSELECT NOEMP, NOM, TITRE, NODEPT\nFROM EMP\n;\nGRANT SELECT\nON EMPVUE\nTO nom de l’autre user\n;\nSolution de l’exercice 5\nCREATE VIEW EMP50 AS\nSELECT *\nFROM EMP\nWHERE NODEPT = 50\n;\nGRANT ALL\nON EMP50\nTO nom de l’autre user\n;\nSolution de l’exercice 6\nREVOKE INSERT ON DEPT FROM nom de l’autre user ;\n67\n\nChapitre 18. Réponses aux exercices sur les droits\n68\n\nChapitre 19. Réponses aux exercices sur les groupes\nVous trouverez les énoncés correspondant au Chapitre 11.\nSolution de l’exercice 1\nSELECT MAX(SALAIRE) ,\nMIN(SALAIRE) ,\nMAX(SALAIRE) - MIN(SALAIRE) AS \"Différence\"\nFROM EMP\n;\nSolution de l’exercice 2\nSELECT COUNT(DISTINCT TITRE)\nFROM EMP\n;\nEssayez aussi, pour voir la différence\\,:\nSELECT COUNT(TITRE)\nFROM EMP\n;\nSolution de l’exercice 3\nSELECT NODEPT, TITRE, COUNT(*)\nFROM EMP\nGROUP BY NODEPT, TITRE\n;\nSolution de l’exercice 4\nSELECT DEPT.NOM, TITRE, COUNT(*)\nFROM EMP,DEPT\nWHERE DEPT.NODEPT = EMP.NODEPT\nGROUP BY DEPT.NOM, TITRE\n;\nSolution de l’exercice 5\nSELECT TITRE, AVG(SALAIRE)\nFROM EMP\nGROUP BY TITRE\nHAVING AVG(SALAIRE) > (SELECT AVG(SALAIRE)\nFROM EMP\nWHERE TITRE = ’Représentant’\n)\n;\n69\n\nChapitre 19. Réponses aux exercices sur les groupes\nSolution de l’exercice 6\nSELECT COUNT(SALAIRE),COUNT(TX_COMMISSION)\nFROM EMP\n;\nSolution de l’exercice 7\nSELECT AVG(TX_COMMISSION) ,AVG(COALESCE(TX_COMMISSION,0))\nFROM EMP\n;\n70\n\nChapitre 20. Réponses aux exercices sur les dates\nVous trouverez les énoncés correspondant au Chapitre 12.\nSolution de l’exercice 1\nSELECT nom,embauche FROM emp ;\nSET DATESTYLE TO ’European’;\nSELECT nom,embauche from emp;\nSET DATESTYLE TO ’ISO’;\nSELECT nom,embauche from emp;\nSET DATESTYLE TO ’Postgres’;\nSELECT nom,embauche from emp;\nSET DATESTYLE TO DEFAULT;\nSELECT nom,embauche from emp;\nSET DATESTYLE TO ’German’;\nSELECT nom,embauche from emp;\nSET DATESTYLE TO ’NonEuropean’;\nSELECT nom,embauche from emp;\nSET DATESTYLE TO ’SQL’;\nSELECT nom,embauche from emp;\nSolution de l’exercice 2\nSELECT nom,TO_CHAR(embauche,’dd/mm/yy’) FROM emp WHERE nodept=41;\nSolution de l’exercice 3\nSELECT nom,TO_CHAR(embauche,’Day DD Month YYYY’) FROM emp WHERE nodept=41;\nSolution de l’exercice 4\nSELECT nom,TO_CHAR(embauche,’DD MON yyyy HH24:MI:SS’) FROM emp WHERE nodept=41;\nSolution de l’exercice 5\nSELECT nom,embauche,embauche+90 AS \"Fin période essai\" FROM emp WHERE nodept=41;\nSolution de l’exercice 7\nSELECT nom,embauche FROM emp WHERE nodept=41;\nSolution de l’exercice 6\nSELECT nom,embauche,CAST(NOW() AS DATE)-embauche AS \"Delta\" FROM emp;\n71\n\nChapitre 20. Réponses aux exercices sur les dates\nSolution de l’exercice 7\nSELECT nom,embauche FROM emp\nWHERE embauche-(SELECT MIN(embauche) FROM emp) < 365;\n72\n\nChapitre 21. Réponses aux exercices récapitulatifs\nVous trouverez les énoncés correspondant au Chapitre 13.\nSolution de l’exercice 1\nSELECT d.nodept,d.nom,COUNT(*)\nFROM dept d,emp e\nWHERE d.nodept=e.nodept\nGROUP BY d.nodept,d.nom\n;\nSolution de l’exercice 2\nSELECT e.nom,e.prenom,COUNT(*)\nFROM emp e,emp s\nWHERE e.noemp=s.nosupr\nGROUP BY e.noemp,e.nom,e.prenom\nHAVING count(*)>2\nORDER BY e.nom,e.prenom\n;\nSolution de l’exercice 3\n(SELECT prenom,nom,salaire,’Minimum’ AS \"min ou max?\"\nFROM emp\nWHERE salaire=(SELECT MIN(salaire)\nFROM emp)\n)\nUNION\n(SELECT prenom,nom,salaire,’Maximum’ AS \"min ou max?\"\nFROM emp\nWHERE salaire=(SELECT MAX(salaire)\nFROM emp)\n)\n;\nSolution de l’exercice 4\nSELECT DISTINCT e.prenom,e.nom\nFROM emp e,emp a,emp b\nWHERE e.noemp=a.nosupr\nAND a.noemp=b.nosupr\nORDER BY e.nom,e.prenom\n;\nSolution de l’exercice 5\nSELECT nodept,nom\nFROM (\nSELECT d.nodept,d.nom,count(*) AS xxx\nFROM dept d,emp e\nWHERE d.nodept=e.nodept\nGROUP BY d.nodept,d.nom) yyy\nWHERE xxx=(SELECT MAX(xxx) FROM (\nSELECT COUNT(*) AS xxx\nFROM dept d,emp e\nWHERE d.nodept=e.nodept\nGROUP BY d.nodept) yyy\n)\n73\n\nChapitre 21. Réponses aux exercices récapitulatifs\n;\nSolution de l’exercice 6\nSELECT nom,prenom,salaire\nFROM emp\nWHERE (SELECT abs(salaire\n-(SELECT avg(salaire)\nFROM emp)))\n=(SELECT min(diff)\nFROM (SELECT abs(salaire\n-(SELECT avg(salaire)\nFROM emp)) as diff\nFROM emp)\na)\n;\n74\n\nIndex\naccès concurrents, 35\nadministrateur, 4\nafﬁchage d’une , 45\nalgèbre relationnelle, 4, 7\nALL, 28\nALTER TABLE, 12, 39\nANY, 28\narchitecture\nclient-serveur, 3, 3, 5\nen couches, 3\natomique, 35\nattribut, 4\nauto-jointure, 27\nautocommit, 36\nAVG, 43\nbase de données, 5\nrelationnelle, 4\nbase jouet, 15\nsolutions des exercices, 51\nBEGIN, 36\nBETWEEN, 54\nCASE, 24\nchaîne de caractères, 24\nclef\nprimaire, 4, 18, 19, 36\nétrangère, 5, 18, 19\nclient-serveur, 5\nCOALESCE, 23\ncolonne, 4\nCOMMIT, 36\nconcaténation, 24\ncontrainte\nd’intégrité, 5\nd’intégrité référentielle, 5\nd’intégrité d’entité, 5\nd’intégrité référentielle, 5\nde domaine, 5\nCOUNT, 43\nCREATE\nDATABASE, 31\nTABLE, 31, 31, 36\nVIEW, 40\nCURRENT_DATE, 46\ndate, 45\nactuelle, 46\nafﬁchage d’une -, 45\nDATESTYLE, 45\nDECODE, 24\nDELETE, 39, 41\nDEPT\nla table, 18\nDEUX\nla table, 15\ndictionnaire, 6\ndifférence, 7\nDISTINCT, 21\nDocBook, 1\ndomaine, 5\ndroits, 35\nDROP\nTABLE, 39\ndénombrement, 43\ndéveloppeur, 4\nemacs, 1\nEMP\nla table, 17\nEXEMPLE\nla base, 17\nEXISTS, 28\nexpression arithmétique, 23\nfonctions, 43\nGilleron, Rémi, 3\nGRANT, 41\nGROUP BY, 43\ngroupes, 43\nHAVING, 44\nHTML, 1, 1\nIDAPI, 6\nidentiﬁant, 5\nIN, 55\nINSERT, 32, 32, 37, 41\ninstant actuel, 46\ninterface\nutilisateur, 6\nINTERSECT, 25\njointure, 7, 27\nsolutions des exercices, 59\néqui-jointure, 27\njouet\nla base, 15, 51\nkey\nforeign, 18, 19\nprimary, 18, 19\nlangage\nde contrôle des données, 6\nde déﬁnition de données, 6\nde manipulation de données, 6\nLCD, 6\nLDD, 6\nLedant, Guy, 3\nLEFT JOIN, 28\nLENGTH, 24\nLMD, 6\nLOWER, 24\nMarée, Christian, 3\nMAX, 43\nmaximum, 43\nMIN, 43\nminimum, 43\nmoteur\nSQL, 8\nmoyenne, 43\nniveau\nexterne, 4\ninterne, 4\nlogique, 4\nphysique, 4\nNOT IN, 28\nNOW, 46\nNULL, 23\nODBC, 6, 6\nopenjade, 1\nopérateur\nalgébrique, 7\nPDF, 1, 1\nPostgres95, 10, 10\n75\n\nPostgreSQL, 9\nprimitives SQL, 6\nproduit, 7\nproduit cartésien, 27\nprojection, 7, 21\nprotocole, 3\nrelation, 4, 7\nrelationnel, 4\nrenommer une table, 28\nrequête, 3, 7\nREVOKE, 41\nROLLBACK, 36\nROUND, 24\nschéma\nexterne, 4\ninterne, 4\nlogique, 4, 5\nphysique, 4\nSELECT, 6, 21, 41, 43\nDISTINCT, 21\nsolutions des exercices, 53\nserveur\nde bases de données, 6\nde ﬁchiers, 5\nde bases de données, 6\nSET\nDATESTYLE, 45\nSGBD, 3\nsous-requête, 27\nsynchroniser une, 28\nSQL, 3\ndynamique, 6\ninteractif, 6\nintégré, 6\nSTRPOS, 24\nstructure en couches, 3\nSUBSTR, 24\nsécurité, 5, 6\nsélection, 7, 22\ntable, 4, 7\nTommasi, Marc, 3\ntransaction, 6, 35\nTRUNC, 24\ntuple, 4, 7\nUN\nla table, 15\nundo, 35\nUNION, 7, 25\nALL, 25\nUPDATE, 38, 41\nUPPER, 24\nVALUES, 37\nversion, 1\nXML, 1\nxsltproc, 1\n76",
  "file_type": "document",
  "original_path": "data/uploads\\module_sql.pdf"
}