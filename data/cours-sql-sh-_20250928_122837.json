{
  "filename": "cours-sql-sh-.pdf",
  "extraction_date": "2025-09-28T12:28:37.014128",
  "statistics": {
    "word_count": 17682,
    "character_count": 117772,
    "line_count": 2397
  },
  "top_keywords": [
    [
      "pour",
      250
    ],
    [
      "table",
      249
    ],
    [
      "requête",
      225
    ],
    [
      "dans",
      176
    ],
    [
      "select",
      135
    ],
    [
      "commande",
      125
    ],
    [
      "from",
      120
    ],
    [
      "cette",
      115
    ],
    [
      "données",
      113
    ],
    [
      "exemple",
      102
    ]
  ],
  "extracted_data": {
    "emails": [
      "esmee.lefort@example.com",
      "4GregoryRouxg.roux@example.com",
      "3MarinePrevostm.prevost@example.com",
      "1SebastienMartins.martin@example.com",
      "aime.marechal@example.com",
      "lucrolland@example.com",
      ".lefort@example.com",
      "4LucRollandlucrolland@example.com",
      "2GustaveDuboisg.dubois@example.com",
      "3GeorgetteLeroyg.leroy@example.com",
      "m.prevost@example.com",
      ".marechal@example.com"
    ],
    "urls": [
      "http://sql.sh,",
      "http://sql.sh"
    ],
    "dates": [
      "10/04/2012"
    ]
  },
  "content_preview": "Cours SQL\n_____________\nBase du langage SQL et des bases de données\nAuteurTony Archambeau\nSite webhttp://sql.sh\nDate24 mai 2014\nLicenceMis à disposition selon les termes de la licence Creative Commons Attribution - Pas \nd’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. . \nVous êtes libres de reproduire, distribuer et communiquer cette création au public à \ncondition de faire un lien vers http://sql.sh, de redistribuer dans les mêmes conditions et \nde ne pas faire d...",
  "full_content": "Cours SQL\n_____________\nBase du langage SQL et des bases de données\nAuteurTony Archambeau\nSite webhttp://sql.sh\nDate24 mai 2014\nLicenceMis à disposition selon les termes de la licence Creative Commons Attribution - Pas \nd’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. . \nVous êtes libres de reproduire, distribuer et communiquer cette création au public à \ncondition de faire un lien vers http://sql.sh, de redistribuer dans les mêmes conditions et \nde ne pas faire d'utilisation commerciale du cours.\n1/89 sql.sh\nSommaire\nSQL SELECT.......................................................................................................................................... 3\nSQL DISTINCT........................................................................................................................................ 6\nSQL AS (alias)......................................................................................................................................... 8\nSQL WHERE......................................................................................................................................... 11\nSQL AND & OR..................................................................................................................................... 13\nSQL IN................................................................................................................................................... 15\nSQL BETWEEN..................................................................................................................................... 17\nSQL LIKE............................................................................................................................................... 19\nSQL IS NULL / IS NOT NULL ................................................................................................................ 21\nSQL GROUP BY................................................................................................................................... 23\nSQL HAVING......................................................................................................................................... 25\nSQL ORDER BY.................................................................................................................................... 27\nSQL LIMIT............................................................................................................................................. 29\nSQL CASE............................................................................................................................................. 31\nSQL UNION........................................................................................................................................... 35\nSQL UNION ALL.................................................................................................................................... 37\nSQL INTERSECT .................................................................................................................................. 39\nSQL EXCEPT / MINUS ......................................................................................................................... 41\nSQL INSERT INTO ................................................................................................................................ 43\nSQL ON DUPLICATE KEY UPDATE .................................................................................................... 45\nSQL UPDATE........................................................................................................................................ 48\nSQL DELETE........................................................................................................................................ 49\nSQL MERGE......................................................................................................................................... 50\nSQL TRUNCATE TABLE ....................................................................................................................... 51\nSQL CREATE DATABASE .................................................................................................................... 52\nSQL DROP DATABASE ........................................................................................................................ 53\nSQL CREATE TABLE ............................................................................................................................ 54\nSQL ALTER TABLE ............................................................................................................................... 56\nSQL DROP TABLE ................................................................................................................................ 58\nJointure SQL......................................................................................................................................... 59\nSQL INNER JOIN .................................................................................................................................. 60\nSQL CROSS JOIN ................................................................................................................................ 62\nSQL LEFT JOIN.................................................................................................................................... 64\nSQL RIGHT JOIN .................................................................................................................................. 66\nSQL FULL JOIN.................................................................................................................................... 68\nSQL SELF JOIN.................................................................................................................................... 70\nSQL NATURAL JOIN ............................................................................................................................. 72\nSQL Sous-requête ................................................................................................................................. 74\nSQL EXISTS.......................................................................................................................................... 77\nSQL ALL................................................................................................................................................ 79\nSQL ANY / SOME .................................................................................................................................. 80\nIndex SQL............................................................................................................................................. 82\nSQL CREATE INDEX ............................................................................................................................ 83\nSQL EXPLAIN....................................................................................................................................... 85\nCommentaires en SQL .......................................................................................................................... 88\n2/89 sql.sh\nSQL SELECT\nL’utilisation la plus courante de SQL consiste à lire des données issues de la base de données. Cela \ns’effectue grâce à la commande SELECT, qui retourne des enregistrements dans un tableau de \nrésultat. Cette commande peut sélectionner une ou plusieurs colonnes d’une table.\nCommande basique\nL’utilisation basique de cette commande s’effectue de la manière suivante  :\nSELECT nom_du_champ\nFROM nom_du_tableau\nCette requête va sélectionner (SELECT) le champ « nom_du_champ » provenant (FROM) du \ntableau appelé « nom_du_tableau ».\nExemple\nImaginons une base de données appelée « client » qui contient des informations sur les clients d’une\nentreprise.\nTable « client » :\nidentifiant prenom nom ville\n1 Pierre Dupond Paris\n2 Sabrina Durand Nantes\n3 Julien Martin Lyon\n4 David Bernard Marseille\n5 Marie Leroy Grenoble\nSi l’ont veut avoir la liste de toutes les villes des clients, il suffit d’effectuer la requête suivante  :\nSELECT ville \nFROM client\nRésultat :\nville\nParis\nNantes\nLyon\nMarseille\nGrenoble\n3/89 sql.sh\nObtenir plusieurs colonnes\nAvec la même table client il est possible de lire plusieurs colonnes à la fois. Il suffit tout simplement \nde séparer les noms des champs souhaités par une virgule. Pour obtenir les prénoms et les noms \ndes clients il faut alors faire la requête suivante:\nSELECT prenom, nom \nFROM client\nRésultat :\nprenom nom\nPierre Dupond\nSabrina Durand\nJulien Martin\nDavid Bernard\nMarie Leroy\nObtenir toutes les colonnes d’un tableau\nIl est possible de retourner automatiquement toutes les colonnes d’un tableau sans avoir à connaître \nle nom de toutes les colonnes. Au lieu de lister toutes les colonnes, il faut simplement utiliser le \ncaractère « * » (étoile). C’est un joker qui permet de sélectionner toutes les colonnes. Il s’utilise de la \nmanière suivante  :\nSELECT * FROM client\nCette requête retourne exactement les mêmes colonnes qu’il y a dans la base de données. Dans \nnotre cas, le résultat sera donc  :\nidentifiant prenom nom ville\n1 Pierre Dupond Paris\n2 Sabrina Durand Nantes\n3 Julien Martin Lyon\n4 David Bernard Marseille\n5 Marie Leroy Grenoble\nIl y a des avantages et des inconvénient à l’utiliser. Pour en savoir plus sur le sujet il est recommandé\nde lire l’article avantage et inconvénient du sélecteur étoile.\nCours avancé : ordre des commandes du SELECT\nCette commande SQL est relativement commune car il est très fréquent de devoir lire les données \nissues d’une base de données. Il existe plusieurs commandes qui permettent de mieux gérer les \ndonnées que l’ont souhaite lire. Voici un petit aperçu des fonctionnalités possibles qui sont abordées \nsur le reste du site:\n4/89 sql.sh\n•Joindre un autre tableau aux résultats\n•Filtrer pour ne sélectionner que certains enregistrements\n•Classer les résultats\n•Grouper les résultats pour faire uniquement des statistiques (note moyenne, prix le plus élevé \n…)\nUn requête SELECT peut devenir assez longue. Juste à titre informatif, voici une requête SELECT \nqui possède presque toutes les commandes possibles  :\nSELECT *\nFROM table\nWHERE condition\nGROUP BY expression\nHAVING condition\n{ UNION | INTERSECT | EXCEPT }\nORDER BY expression\nLIMIT count\nOFFSET start\nA noter : cette requête imaginaire sert principale d’aide-mémoire pour savoir dans quel ordre sont \nutilisé chacun des commandes au sein d’une requête SELECT.\n5/89 sql.sh\nSQL DISTINCT\nL’utilisation de la commande SELECT en SQL permet de lire toutes les données d’une ou plusieurs \ncolonnes. Cette commande peut potentiellement afficher des lignes en doubles. Pour éviter des \nredondances dans les résultats il faut simplement ajouter DISTINCT après le mot SELECT.\nCommande basique\nL’utilisation basique de cette commande consiste alors à effectuer la requête suivante  :\nSELECT DISTINCT ma_colonne\nFROM nom_du_tableau\nCette requête sélectionne le champ « ma_colonne » de la table « nom_du_tableau » en évitant de \nretourner des doublons.\nRequête pour Oracle\nPour le Système de Gestion de Bases de Données (SGBD) Oracle, cette requête est remplacée par \nla commande « UNIQUE »  :\nSELECT UNIQUE ma_colonne\nFROM nom_du_tableau\nExemple\nPrenons le cas concret d’une table « client » qui contient des noms et prénoms  :\nidentifiant prenom nom\n1 Pierre Dupond\n2 Sabrina Bernard\n3 David Durand\n4 Pierre Leroy\n5 Marie Leroy\nEn utilisant seulement SELECT tous les noms sont retournés, or la table contient plusieurs fois le \nmême prénom (cf. Pierre). Pour sélectionner uniquement les prénoms uniques il faut utiliser la \nrequête suivante :\nSELECT DISTINCT prenom \nFROM client\nRésultat :\nprenom\nPierre\nSabrina\n6/89 sql.sh\nDavid\nMarie\nCe résultat affiche volontairement qu’une seule fois le prénom « Pierre » grâce à l’utilisation de la \ncommande DISTINCT qui n’affiche que les résultats distincts.\nIntérêt\nL’utilisation de la commande DISTINCT est très pratique pour éviter les résultats en doubles. \nCependant, pour optimiser les performances il est préférable d’utiliser la commande SQL GROUP BY\nlorsque c’est possible.\n7/89 sql.sh\nSQL AS (alias)\nDans le langage SQL il est possible d’utiliser des alias pour renommer temporairement une colonne \nou une table dans une requête. Cette astuce est particulièrement utile pour faciliter la lecture des \nrequêtes.\nIntérêts et utilités\nAlias sur une colonne\nPermet de renommer le nom d’une colonne dans les résultats d’une requête SQL. C’est pratique \npour avoir un nom facilement identifiable dans une application qui doit ensuite exploiter les résultats \nd’une recherche.\nCas concrets d’utilisations  :\n•Une colonne qui s’appelle normalement c_iso_3166 peut être renommée « code_pays » (cf. le\ncode ISO 3166 correspond au code des pays), ce qui est plus simple à comprendre dans le \nreste du code par un développeur.\n•Une requête qui utilise la commande UNION sur des champs aux noms différents peut être \nambigu pour un développeur. En renommant les champs avec un même nom il est plus simple\nde traiter les résultats.\n•Lorsqu’une fonction est utilisé, le nom d’une colonne peut-être un peu complexe. Il est ainsi \npossible de renommer la colonne sur laquelle il y a une fonction SQL. Exemple : SELECT \nCOUNT(*) AS nombre_de_resultats FROM `table`.\n•Lorsque plusieurs colonnes sont combinées il est plus simple de renommer la nouvelle \ncolonne qui est une concaténation de plusieurs champs.\nAlias sur une table\nPermet d’attribuer un autre nom à une table dans une requête SQL. Cela peut aider à avoir des \nnoms plus court, plus simple et plus facilement compréhensible. Ceci est particulièrement vrai \nlorsqu’il y a des jointures.\nSyntaxe\nAlias sur une colonne\nLa syntaxe pour renommer une colonne de colonne1 à c1 est la suivante  :\nSELECT colonne1 AS c1, colonne2\nFROM `table`\nCette syntaxe peut également s’afficher de la façon suivante  :\nSELECT colonne1 c1, colonne2\nFROM `table`\nA noter : à choisir il est préférable d’utiliser la commande « AS » pour que ce soit plus explicite (plus \nsimple à lire qu’un simple espace), d’autant plus que c’est recommandé dans le standard ISO pour \nconcevoir une requête SQL.\n8/89 sql.sh\nAlias sur une table\nLa syntaxe pour renommer une table dans une requête est la suivante  :\nSELECT *\nFROM `nom_table` AS t1\nCette requête peut également s’écrire de la façon suivante  :\nSELECT *\nFROM `table`t1\nExemple\nRenommer une colonne\nImaginons une site d’e-commerce qui possède une table de produits. Ces produits sont disponibles \ndans une même table dans plusieurs langues , dont le français. Le nom du produit peut ainsi être \ndisponible dans la colonne « nom_fr_fr », « nom_en_gb » ou « nom_en_us ». Pour utiliser l’un ou \nl’autre des titres dans le reste de l’application sans avoir à se soucier du nom de la colonne, il est \npossible de renommer la colonne de son choix avec un nom générique. Dans notre cas, la requête \npourra ressemble à ceci  :\nSELECT p_id, p_nom_fr_fr AS nom, p_description_fr_fr AS description, \np_prix_euro AS prix\nFROM `produit`\nRésultat :\nidnom description prix\n1Ecran Ecran de grandes tailles. 399.99\n2Clavier Clavier sans fil. 27\n3Souris Souris sans fil. 24\n4Ordinateur portable Grande autonomie et et sacoche offerte. 700\nComme nous pouvons le constater les colonnes ont été renommées.\nRenommer une ou plusieurs tables\nImaginons que les produits du site e-commerce soit répartis dans des catégories. Pour récupérer la \nliste des produits en même temps que la catégorie auquel il appartient il est possible d’utiliser une \nrequête SQL avec une jointure. Cette requête peut utiliser des alias pour éviter d’utiliser à chaque \nfois le nom des tables.\nLa requête ci-dessous renomme la table « produit » en « p » et la table « produit_categorie » en « pc \n» (plus court et donc plus rapide à écrire)  :\nSELECT p_id, p_nom_fr_fr, pc_id, pc_nom_fr_fr\nFROM `produit` AS p\nLEFT JOIN `produit_categorie` AS pc ON pc.pc_id = p.p_fk_category_id\n9/89 sql.sh\nCette astuce est encore plus pratique lorsqu’il y a des noms de tables encore plus compliqués et \nlorsqu’il y a beaucoup de jointures.\n10/89 sql.sh\nSQL WHERE\nLa commande WHERE dans une requête SQL permet d’extraire les lignes d’une base de données \nqui respectent une condition. Cela permet d’obtenir uniquement les informations désirées.\nSyntaxe\nLa commande WHERE s’utilise en complément à une requête utilisant SELECT. La façon la plus \nsimple de l’utiliser est la suivante  :\nSELECT nom_colonnes \nFROM nom_table \nWHERE condition\nExemple\nImaginons une base de données appelée « client » qui contient le nom des clients, le nombre de \ncommandes qu’ils ont effectués et leur ville  :\nid nom nbr_commande ville\n1 Paul 3 paris\n2 Maurice 0 rennes\n3 Joséphine 1 toulouse\n4 Gérard 7 paris\nPour obtenir seulement la liste des clients qui habitent à Paris, il faut effectuer la requête suivante  :\nSELECT * \nFROM client \nWHERE ville = 'paris'\nRésultat :\nid nom nbr_commande nbr_commande\n1 Paul 3 paris\n4 Gérard 7 paris\nAttention : dans notre cas tout est en minuscule donc il n’y a pas eu de problème. Cependant, si un \ntable est sensible à la casse, il faut faire attention aux majuscules et minuscules.\nOpérateurs de comparaisons\nIl existe plusieurs opérateurs de comparaisons. La liste ci-jointe présente quelques uns des \nopérateurs les plus couramment utilisés.\n11/89 sql.sh\nOpérateurDescription\n= Égale\n<> Pas égale\n!= Pas égale\n> Supérieur  à\n< Inférieur  à\n>= Supérieur ou  égale  à\n<= Inférieur ou  égale  à\nIN Liste de plusieurs valeurs possibles\nBETWEEN Valeur comprise dans un intervalle donn ée (utile pour les nombres ou dates)\nLIKE Recherche en sp écifiant le d ébut, milieu ou fin d'un mot.\nIS NULL Valeur est nulle\nIS NOT NULL Valeur n'est pas nulle\nAttention : il y a quelques opérateurs qui n’existe pas dans des vieilles versions de système de \ngestion de bases de données (SGBD). De plus, il y a de nouveaux opérateurs non indiqués ici qui \nsont disponibles avec certains SGBD. N’hésitez pas à consulter la documentation de MySQL, \nPostgreSQL ou autre pour voir ce qu’il vous est possible de faire.\n12/89 sql.sh\nSQL AND & OR\nUne requête SQL peut être restreinte à l’aide de la condition WHERE. Les opérateurs logiques AND \net OR peuvent être utilisées au sein de la commande WHERE pour combiner des conditions.\nSyntaxe d’utilisation des opérateurs AND et OR\nLes opérateurs sont à ajoutés dans la condition WHERE. Ils peuvent être combinés à l’infini pour \nfiltrer les données comme souhaités.\nL’opérateur AND permet de s’assurer que la condition1 ET la condition2 sont vrai  :\nSELECT nom_colonnes\nFROM nom_table\nWHERE condition1 AND condition2\nL’opérateur OR vérifie quant à lui que la condition1 OU la condition2 est vrai  :\nSELECT nom_colonnes FROM nom_table\n WHERE condition1 OR condition2\nCes opérateurs peuvent être combinés à l’infini et mélangés. L’exemple ci-dessous filtre les résultats \nde la table « nom_table » si condition1 ET condition2 OU condition3 est vrai  :\nSELECT nom_colonnes FROM nom_table\n WHERE condition1 AND (condition2 OR condition3)\nAttention : il faut penser à utiliser des parenthèses lorsque c’est nécessaire. Cela permet d’éviter les \nerreurs car et ça améliore la lecture d’une requête par un humain.\nExemple de données\nPour illustrer les prochaines commandes, nous allons considérer la table « produit » suivante  :\nid nom categorie stock prix\n1 ordinateur informatique 5 950\n2 clavier informatique 32 35\n3 souris informatique 16 30\n4 crayon fourniture 147 2\nOpérateur AND\nL’opérateur AND permet de joindre plusieurs conditions dans une requête. En gardant la même table \nque précédemment, pour filtrer uniquement les produits informatique qui sont presque en rupture de \nstock (moins de 20 produits disponible) il faut exécuter la requête suivante  :\nSELECT * FROM produit\nWHERE categorie = 'informatique' AND stock < 20\n13/89 sql.sh\nRésultat :\nid nom categorie stock prix\n1 ordinateur informatique 5 950\n3 souris informatique 16 30\nOpérateur OR\nPour filtrer les données pour avoir uniquement les données sur les produits « ordinateur » ou « \nclavier » il faut effectuer la recherche suivante  :\nSELECT * FROM produit\nWHERE nom = 'ordinateur' OR nom = 'clavier'\nRésultats :\nid nom categorie stock prix\n1 ordinateur informatique 5 950\n2 clavier informatique 32 35\nCombiner AND et OR\nIl ne faut pas oublier que les opérateurs peuvent être combinés pour effectuer de puissantes \nrecherche. Il est possible de filtrer les produits « informatique » avec un stock inférieur à 20 et les \nproduits « fourniture » avec un stock inférieur à 200 avec la recherche suivante  :\nSELECT * FROM produit\nWHERE ( categorie = 'informatique' AND stock < 20 )\nOR ( categorie = 'fourniture' AND stock < 200 )\nRésultats :\nid nom categorie stock prix\n1 ordinateur informatique 5 950\n2 clavier informatique 32 35\n4 crayon fourniture 147 2\n14/89 sql.sh\nSQL IN\nL’opérateur logique IN dans SQL  s’utilise avec la commande WHERE pour vérifier si une colonne est\négale à une des valeurs comprise dans set de valeurs déterminés. C’est une méthode simple pour \nvérifier si une colonne est égale à une valeur OU une autre valeur OU une autre valeur et ainsi de \nsuite, sans avoir à utiliser de multiple fois l’opérateur OR.\nSyntaxe\nPour chercher toutes les lignes où la colonne « nom_colonne » est égale à ‘valeur 1′ OU ‘valeur 2′ ou\n‘valeur 3′, il est possible d’utiliser la syntaxe suivante  :\nSELECT nom_colonne\nFROM table\nWHERE nom_colonne IN ( valeur1, valeur2, valeur3, ... )\nA savoir : entre les parenthèses il n’y a pas de limite du nombre d’arguments. Il est possible \nd’ajouter encore d’autres valeurs.\nCette syntaxe peut être associée à l’opérateur NOT pour recherche toutes les lignes qui ne sont pas \négales à l’une des valeurs stipulées.\nSimplicité de l’opérateur IN\nLa syntaxe utilisée avec l’opérateur est plus simple que d’utiliser une succession d’opérateur OR. \nPour le montrer concrètement avec un exemple, voici 2 requêtes qui retournerons les mêmes \nrésultats, l’une utilise l’opérateur IN, tandis que l’autre utilise plusieurs OR.\nRequête avec plusieurs OR\nSELECT prenom\nFROM utilisateur\nWHERE prenom = 'Maurice' OR prenom = 'Marie' OR prenom = 'Thimoté'\nRequête équivalent avec l’opérateur IN\nSELECT prenom\nFROM utilisateur\nWHERE prenom IN ( 'Maurice', 'Marie', 'Thimoté' )\nExemple\nImaginons une table « adresse » qui contient une liste d’adresse associée à des utilisateurs d’une \napplication.\nidid_utilisateuraddr_rue addr_code_postal addr_ville\n12335 Rue Madeleine Pelletier 25250 Bournois\n24321 Rue du Moulin Collet 75006 Paris\n15/89 sql.sh\n36528 Avenue de Cornouaille 27220 Mousseaux­Neuville\n46741 Rue Marcel de la Provot é76430 Graimbouville\n56818 Avenue de Navarre 75009 Paris\nSi l’ont souhaite obtenir les enregistrements des adresses de Paris et de Graimbouville, il est \npossible d’utiliser la requête suivante  :\nSELECT *\nFROM adresse\nWHERE addr_ville IN ( 'Paris', 'Graimbouville' )\nRésultats :\nidid_utilisateuraddr_rue addr_code_postal addr_ville\n24321 Rue du Moulin Collet 75006 Paris\n46741 Rue Marcel de la Provot é76430 Graimbouville\n56818 Avenue de Navarre 75009 Paris\n16/89 sql.sh\nSQL BETWEEN\nL’opérateur BETWEEN est utilisé dans une requête SQL pour sélectionner un intervalle de données \ndans une requête utilisant WHERE. L’intervalle peut être constitué de chaînes de caractères, de \nnombres ou de dates. L’exemple le plus concret consiste par exemple à récupérer uniquement les \nenregistrements entre 2 dates définies.\nSyntaxe\nL’utilisation de la commande BETWEEN s’effectue de la manière suivante  :\nSELECT *\nFROM table\nWHERE nom_colonne BETWEEN 'valeur1' AND 'valeur2'\nLa requête suivante retournera toutes les lignes dont la valeur de la colonne « nom_colonne » sera \ncomprise entre valeur1 et valeur2.\nExemple : filtrer entre 2 dates\nImaginons une table « utilisateur » qui contient les membres d’une application en ligne.\nid nom date_inscription\n1 Maurice 2012­03­02\n2 Simon 2012­03­05\n3 Chloé 2012­04­14\n4 Marie 2012­04­15\n5 Clémentine 2012­04­26\nSi l’ont souhaite obtenir les membres qui se sont inscrit entre le 1 avril 2012 et le 20 avril 2012 il est \npossible d’effectuer la requête suivante  :\nSELECT *\nFROM utilisateur\nWHERE date_inscription BETWEEN ’2012-04-01′ AND ’2012-04-20′\nRésultat :\nid nom date_inscription\n3 Chloé 2012­04­14\n4 Marie 2012­04­15\nExemple : filtrer entre 2 entiers\nSi l’ont souhaite obtenir tous les résultats dont l’identifiant n’est pas situé entre 4 et 10, il faudra alors \nutiliser la requête suivante  :\n17/89 sql.sh\nSELECT *\nFROM utilisateur\nWHERE id NOT BETWEEN 4 AND 10\nRésultat :\nid nom date_inscription\n1 Maurice 2012­03­02\n2 Simon 2012­03­05\n3 Chloé 2012­04­14\nBon à savoir\nCertaines vieilles versions de systèmes de gestion de bases de données ne prennent pas en compte\nla commande BETWEEN. Mais si vous utilisez une version récente de MySQL ou PostgreSQL, cela \nne cause aucun problème.\nL’autre élément important à savoir c’est que toutes les bases de données ne gèrent pas l’opérateur \nBETWEEN de la même manière. Certains systèmes vont inclurent les valeurs qui définissent \nl’intervalle  tandis que d’autres systèmes considèrent ces valeurs sont exclues. Il est important de \nconsulter la documentation officielle de la base de données que vous utilisez pour avoir une réponse \nexacte à ce sujet.\n18/89 sql.sh\nSQL LIKE\nL’opérateur LIKE est utilisé dans la clause WHERE des requêtes SQL. Ce mot-clé permet d’effectuer\nune recherche sur un modèle particulier. Il est par exemple possible de rechercher les \nenregistrements dont la valeur d’une colonne commence par telle ou telle lettre. Les modèles de \nrecherches sont multiple.\nSyntaxe\nLa syntaxe à utiliser pour utiliser l’opérateur LIKE est la suivante  :\nSELECT *\nFROM table\nWHERE colonne LIKE modele\nDans cet exemple le « modèle » n’a pas été défini, mais il ressemble très généralement à l’un des \nexemples suivants  :\n•LIKE ‘%a’ : le caractère « % » est un caractère joker qui remplace tous les autres caractères. \nAinsi, ce modèle permet de rechercher toutes les chaines de caractère qui se termine par un «\na ».\n•LIKE ‘a%’ : ce modèle permet de rechercher toutes les lignes de « colonne » qui commence \npar un « a ».\n•LIKE ‘%a%’ : ce modèle est utilisé pour rechercher tous les enregistrement qui utilisent le \ncaractère « a ».\n•LIKE ‘pa%on’ : ce modèle permet de rechercher les chaines qui commence par « pa » et qui \nse terminent par « on », comme « pantalon » ou « pardon ».\n•LIKE ‘a_c’ : peu utilisé, le caractère « _ » (underscore) peut être remplacé par n’importe quel \ncaractère, mais un seul caractère uniquement (alors que le symbole pourcentage « % » peut \nêtre remplacé par un nombre incalculable de caractères . Ainsi, ce modèle permet de \nretourner les lignes « aac », « abc » ou même « azc ».\nExemple\nImaginons une table « client » qui contient les enregistrement d’utilisateurs  :\nid nom ville\n1 Léon Lyon\n2 Odette Nice\n3 Vivien Nantes\n4 Etienne Lille\nObtenir les résultats qui commencent par « N »\nSi l’ont souhaite obtenir uniquement les clients des villes qui commencent par un « N », il est \npossible d’utiliser la requête suivante  :\nSELECT *\nFROM client\nWHERE ville LIKE 'N%'\n19/89 sql.sh\nAvec cette requête, seul les enregistrements suivants seront retournés  :\nid nom ville\n2 Odette Nice\n3 Vivien Nantes\nObtenir les résultats terminent par « e »\nRequête :\nSELECT *\nFROM client\nWHERE ville LIKE '%e'\nRésultat :\nid nom ville\n2 Odette Nice\n4 Etienne Lille\n20/89 sql.sh\nSQL IS NULL / IS NOT NULL\nDans le langage SQL, l’opérateur IS permet de filtrer les résultats qui contiennent la valeur NULL. \nCet opérateur est indispensable car la valeur NULL est une valeur inconnue et ne peut par \nconséquent pas être filtrée par les opérateurs de comparaison (cf. égal, inférieur, supérieur ou \ndifférent).\nSyntaxe\nPour filtrer les résultats où les champs d’une colonne sont à NULL il convient d’utiliser la syntaxe \nsuivante :\nSELECT *\nFROM `table`\nWHERE nom_colonne IS NULL\nA l’inverse, pour filtrer les résultats et obtenir uniquement les enregistrements qui ne sont pas null, il \nconvient d’utiliser la syntaxe suivante  :\nSELECT *\nFROM `table`\nWHERE nom_colonne IS NOT NULL\nA savoir : l’opérateur IS retourne en réalité un booléen, c’est à dire une valeur TRUE si la condition \nest vrai ou FALSE si la condition n’est pas respectée. Cet opérateur est souvent utilisé avec la \ncondition WHERE mais peut aussi trouvé son utilité lorsqu’une sous-requête est utilisée.\nExemple\nImaginons une application qui possède une table contenant les utilisateurs. Cette table possède 2 \ncolonnes pour associer les adresses de livraison et de facturation à un utilisateur (grâce à une clé \nétrangère). Si cet utilisateur n’a pas d’adresse de facturation ou de livraison, alors le champ reste à \nNULL.\nTable « utilisateur »  :\nidnom date_inscription fk_adresse_livraison_id fk_adresse_facturation_id\n23Grégoire2013­02­12 12 12\n24Sarah 2013­02­17 NULL NULL\n25Anne 2013­02­21 13 14\n26Frédérique2013­03­02 NULL NULL\nExemple 1 : utilisateurs sans adresse de livraison\nIl est possible d’obtenir la liste des utilisateurs qui ne possèdent pas d’adresse de livraison en \nutilisant la requête SQL suivante  :\n21/89 sql.sh\nSELECT *\nFROM `utilisateur`\nWHERE `fk_adresse_livraison_id` IS NULL\nRésultat :\nidnom date_inscription fk_adresse_livraison_id fk_adresse_facturation_id\n24Sarah 2013­02­17 NULL NULL\n26Frédérique2013­03­02 NULL NULL\nLes enregistrements retournés montrent bien que seul les utilisateurs ayant la valeur NULL pour le \nchamp de l’adresse de livraison.\nExemple 2 : utilisateurs avec une adresse de livraison\nPour obtenir uniquement les utilisateurs qui possèdent une adresse de livraison il convient de lancer \nla requête SQL suivante  :\nSELECT *\nFROM `utilisateur`\nWHERE `fk_adresse_livraison_id` IS NOT NULL\nRésultat :\nidnom date_inscription fk_adresse_livraison_id fk_adresse_facturation_id\n23Grégoire2013­02­12 12 12\n25Anne 2013­02­21 13 14\nLes lignes retournés sont exclusivement celles qui n’ont pas une valeur NULL pour le champ de \nl’adresse de livraison.\n22/89 sql.sh\nSQL GROUP BY\nLa commande GROUP BY est utilisée en SQL pour grouper plusieurs résultats et utiliser une fonction\nde totaux sur un groupe de résultat. Sur une table qui contient toutes les ventes d’un magasin, il est \npar exemple possible de liste regrouper les ventes par clients identiques et d’obtenir le coût total des \nachats pour chaque client.\nSyntaxe d’utilisation de GROUP BY\nDe façon générale, la commande GROUP BY s’utilise de la façon suivante  :\nSELECT colonne1, fonction(colonne2)\nFROM table\nGROUP BY colonne1\nA noter : cette commande doit toujours s’utiliser après la commande WHERE et avant la commande \nHAVING.\nExemple d’utilisation\nPrenons en considération une table « achat » qui résume les ventes d’une boutique  :\nid client tarif date\n1 Pierre 102 2012-10-23\n2 Simon 47 2012-10-27\n3 Marie 18 2012-11-05\n4 Marie 20 2012-11-14\n5 Pierre 160 2012-12-03\nCe tableau contient une colonne qui sert d’identifiant pour chaque ligne, une autre qui contient le \nnom du client, le coût de la vente et la date d’achat.\nPour obtenir le coût total de chaque client en regroupant les commandes des mêmes clients, il faut \nutiliser la requête suivante  :\nSELECT client, SUM(tarif)\nFROM achat\nGROUP BY client\nLa fonction SUM() permet d’additionner la valeur de chaque tarif pour un même client. Le résultat \nsera donc le suivant  :\nclient SUM(tarif)\nPierre 262\nSimon 47\nMarie 38\n23/89 sql.sh\nLa manière simple de comprendre le GROUP BY c’est tout simplement d’assimiler qu’il va éviter de \nprésenter plusieurs fois les mêmes lignes. C’est une méthode pour éviter les doublons.\nJuste à titre informatif, voici ce qu’on obtient de la requête sans utiliser GROUP BY.\nRequête :\nSELECT client, SUM(tarif)\nFROM achat\nRésultat :\nclient SUM(tarif)\nPierre 262\nSimon 47\nMarie 38\nMarie 38\nPierre 262\nUtilisation d’autres fonctions de statistiques\nIl existe plusieurs fonctions qui peuvent être utilisées pour manipuler plusieurs enregistrements, il \ns’agit des fonctions d’agrégations statistiques, les principales sont les suivantes  :\n•AVG() pour calculer la moyenne d’un set de valeur. Permet de connaître le prix du panier \nmoyen pour de chaque client\n•COUNT() pour compter le nombre de lignes concernées. Permet de savoir combien d’achats a\nété effectué par chaque client\n•MAX() pour récupérer la plus haute valeur. Pratique pour savoir l’achat le plus cher\n•MIN() pour récupérer la plus petite valeur. Utile par exemple pour connaître la date du premier \nachat d’un client\n•SUM() pour calculer la somme de plusieurs lignes. Permet par exemple de connaître le total \nde tous les achats d’un client\nCes petites fonctions se révèlent rapidement indispensable pour travailler sur des données.\n24/89 sql.sh\nSQL HAVING\nLa condition HAVING en SQL est presque similaire à WHERE à la seule différence que HAVING \npermet de filtrer en utilisant des fonctions telles que SUM(), COUNT(), AVG(), MIN() ou MAX().\nSyntaxe\nL’utilisation de HAVING s’utilise de la manière suivante  :\nSELECT colonne1, SUM(colonne2)\nFROM nom_table\nGROUP BY colonne1\nHAVING fonction(colonne2) operateur valeur\nCela permet donc de SÉLECTIONNER les colonnes DE la table « nom_table » en GROUPANT les \nlignes qui ont des valeurs identiques sur la colonne « colonne1″ et que la condition de HAVING soit \nrespectée.\nImportant : HAVING est très souvent utilisé en même temps que GROUP BY bien que ce ne soit \npas obligatoire.\nExemple\nPour utiliser un exemple concret, imaginons une table « achat » qui contient les achats de différents \nclients avec le coût du panier pour chaque achat.\nid client tarif date_achat\n1 Pierre 102 2012­10­23\n2 Simon 47 2012­10­27\n3 Marie 18 2012­11­05\n4 Marie 20 2012­11­14\n5 Pierre 160 2012­12­03\nSi dans cette table on souhaite récupérer la liste des clients qui ont commandé plus de 40€, toute \ncommandes confondu alors il est possible d’utiliser la requête suivante  :\nSELECT client, SUM(tarif)\nFROM achat\nGROUP BY client\nHAVING SUM(tarif) > 40\nRésultat :\nclient SUM(tarif)\nPierre 162\nSimon 47\n25/89 sql.sh\nLa cliente « Marie » a cumulée 38€ d’achat (un achat de 18€ et un autre de 20€) ce qui est inférieur à\nla limite de 40€ imposée par HAVING. En conséquent cette ligne n’est pas affichée dans le résultat.\n26/89 sql.sh\nSQL ORDER BY\nLa commande ORDER BY permet de trier les lignes dans un résultat d’une requête SQL. Il est \npossible de trier les données sur une ou plusieurs colonnes, par ordre ascendant ou descendant.\nSyntaxe\nUne requête où l’ont souhaite filtrer l’ordre des résultats utilise la commande ORDER BY de la sorte  :\nSELECT colonne1, colonne2\nFROM table\nORDER BY colonne1\nPar défaut les résultats sont classés par ordre ascendant, toutefois il est possible d’inverser l’ordre \nen utilisant le suffixe DESC après le nom de la colonne. Par ailleurs, il est possible de trier sur \nplusieurs colonnes en les séparant par une virgule. Une requête plus élaboré ressemblerais alors \ncela :\nSELECT colonne1, colonne2, colonne3\nFROM table\nORDER BY colonne1 DESC, colonne2 ASC\nA noter : il n’est pas obligé d’utiliser le suffixe « ASC » sachant que les résultats sont toujours classé \npar ordre ascendant par défaut. Toutefois, c’est plus pratique pour mieux s’y retrouver, surtout si on a\noublié l’ordre par défaut.\nExemple\nPour l’ensemble de nos exemple, nous allons prendre un base « utilisateur » de test, qui contient les \ndonnées suivantes  :\nid nom prenom date_inscription tarif_total\n1 Durand Maurice 2012­02­05 145\n2 Dupond Fabrice 2012­02­07 65\n3 Durand Fabienne 2012­02­13 90\n4 Dubois Chloé2012­02­16 98\n5 Dubois Simon 2012­02­23 27\nPour récupérer la liste de ces utilisateurs par ordre alphabétique du nom de famille, il est possible \nd’utiliser la requête suivante  :\nSELECT *\nFROM utilisateur\nORDER BY nom\nRésultat :\n27/89 sql.sh\nid nom prenom date_inscription tarif_total\n4 Dubois Chloé2012­02­16 98\n5 Dubois Simon 2012­02­23 27\n2 Dupond Fabrice 2012­02­07 65\n1 Durand Maurice 2012­02­05 145\n3 Durand Fabienne 2012­02­13 90\nEn utilisant deux méthodes de tri, il est possible de retourner les utilisateurs par ordre alphabétique \nET pour ceux qui ont le même nom de famille, les trier par ordre décroissant d’inscription. La requête \nserait alors la suivante  :\nSELECT *\nFROM utilisateur\nORDER BY nom, date_inscription DESC\nRésultat :\nid nom prenom date_inscription tarif_total\n5 Dubois Simon 2012­02­23 27\n4 Dubois Chloé2012­02­16 98\n2 Dupond Fabrice 2012­02­07 65\n3 Durand Fabienne 2012­02­13 90\n1 Durand Maurice 2012­02­05 145\n28/89 sql.sh\nSQL LIMIT\nLa clause LIMIT est à utiliser dans une requête SQL pour spécifier le nombre maximum de résultats \nque l’ont souhaite obtenir. Cette clause est souvent associé à un OFFSET, c’est-à-dire effectuer un \ndécalage sur le jeu de résultat. Ces 2 clauses permettent par exemple d’effectuer des système de \npagination (exemple : récupérer les 10 articles de la page 4).\nATTENTION : selon le système de gestion de base de données, la syntaxe ne sera pas pareil. Ce \ntutoriel va donc présenter la syntaxe pour MySQL et pour PostgreSQL.\nSyntaxe simple\nLa syntaxe commune aux principales système de gestion de bases de données est la suivante  :\nSELECT *\nFROM table\nLIMIT 10\nCette requête permet de récupérer seulement les 10 premiers résultats d’une table. Bien entendu, si \nla table contient moins de 10 résultats, alors la requête retournera toutes les lignes.\nBon à savoir : la bonne pratique lorsque l’ont utilise LIMIT consiste à utiliser également la clause \nORDER BY pour s’assurer que quoi qu’il en soit ce sont toujours les bonnes données qui sont \nprésentées. En effet, si le système de tri est non spécifié, alors il est en principe inconnu et les \nrésultats peuvent être imprévisible.\nLimit et Offset avec PostgreSQL\nL’offset est une méthode simple de décaler les lignes à obtenir. La syntaxe pour utiliser une limite et \nun offset est la suivante  :\nSELECT *\nFROM table\nLIMIT 10 OFFSET 5\nCette requête permet de récupérer les résultats 6 à 15 (car l’OFFSET commence toujours à 0). A titre\nd’exemple, pour récupérer les résultats 16 à 25 il faudrait donc utiliser: LIMIT 10 OFFSET 15\nA noter : Utiliser OFFSET 0 reviens au même que d’omettre l’OFFSET.\nLimit et Offset avec MySQL\nLa syntaxe avec MySQL est légèrement différente  :\nSELECT *\nFROM table\nLIMIT 5, 10;\nCette requête retourne les enregistrements 6 à 15 d’une table. Le premier nombre est l’OFFSET \ntandis que le suivant est la limite.\n29/89 sql.sh\nBon à savoir : pour une bonne compatibilité, MySQL accepte également la syntaxe LIMIT nombre \nOFFSET nombre. En conséquent, dans la conception d’une application utilisant MySQL il est \npréférable d’utiliser cette syntaxe car c’est potentiellement plus facile de migrer vers un autre \nsystème de gestion de base de données sans avoir à ré-écrire toutes les requêtes.\nPerformance\nCe dernier chapitre est destiné à un public averti. Il n’est pas nécessaire de le comprendre \nentièrement, mais simplement d’avoir compris les grandes lignes.\nCertains développeur pensent à tort que l’utilisation de LIMIT permet de réduire le temps d’exécution \nd’une requête. Or, le temps d’exécution est sensiblement le même car la requête va permettre de \nrécupérer toutes les lignes (donc temps d’exécution identique) PUIS seulement les résultats définit \npar LIMIT et OFFSET seront retournés. Au mieux, utiliser LIMIT permet de réduire le temps \nd’affichage car il y a moins de lignes à afficher.\n30/89 sql.sh\nSQL CASE\nDans le langage SQL, la commande « CASE … WHEN … » permet d’utiliser des conditions de type \n« si / sinon » (cf. if / else) similaire à un langage de programmation pour retourner un résultat \ndisponible entre plusieurs possibilités. Le CASE peut être utilisé dans n’importe quelle instruction ou \nclause, telle que SELECT, UPDATE, DELETE, WHERE, ORDER BY ou HAVING.\nSyntaxe\nL’utilisation du CASE est possible de 2 manières différentes  :\n•Comparer une colonne à un set de résultat possible\n•Élaborer une série de conditions booléennes pour déterminer un résultat\nComparer une colonne à un set de résultat\nVoici la syntaxe nécessaire pour comparer une colonne à un set d’enregistrement  :\nCASE a \n       WHEN 1 THEN 'un'\n       WHEN 2 THEN 'deux'\n       WHEN 3 THEN 'trois'\n       ELSE 'autre'\nEND\nDans cet exemple les valeurs contenus dans la colonne « a » sont comparé à 1, 2 ou 3. Si la \ncondition est vrai, alors la valeur située après le THEN sera retournée.\nA noter : la condition ELSE est facultative et sert de ramasse-miette. Si les conditions précédentes \nne sont pas respectées alors ce sera la valeur du ELSE qui sera retournée par défaut.\nÉlaborer une série de conditions booléennes pour déterminer un résultat\nIl est possible d’établir des conditions plus complexes pour récupérer un résultat ou un autre. Cela \ns’effectue en utilisant la syntaxe suivante  :\nCASE \n     WHEN a=b THEN 'A égal à B'\n     WHEN a>b THEN 'A supérieur à B'\n     ELSE 'A inférieur à B'\nEND\nDans cet exemple les colonnes « a », « b » et « c » peuvent contenir des valeurs numériques. \nLorsqu’elles sont respectées, les conditions booléennes permettent de rentrer dans l’une ou l’autre \ndes conditions.\nIl est possible de reproduire le premier exemple présenté sur cette page en utilisant la syntaxe \nsuivante :\nCASE \n       WHEN a=1 THEN 'un'\n31/89 sql.sh\n       WHEN a=2 THEN 'deux'\n       WHEN a=3 THEN 'trois'\n       ELSE 'autre'\nEND\nExemple\nPour présenter le CASE dans le langage SQL il est possible d’imaginer une base de données \nutilisées par un site de vente en ligne. Dans cette base il y a une table contenant les achats, cette \ntable contient le nom des produits, le prix unitaire, la quantité achetée et une colonne consacrée à \nune marge fictive sur certains produits.\nTable « achat » :\nid nom surcharge prix_unitaire quantite\n1 Produit A 1.3 6 3\n2 Produit B 1.5 8 2\n3 Produit C 0.75 7 4\n4 Produit D 1 15 2\nAfficher un message selon une condition\nIl est possible d’effectuer une requête qui va afficher un message personnalisé en fonction de la \nvaleur de la marge. Le message sera différent selon que la marge soit égale à 1, supérieur à 1 ou \ninférieure à 1. La requête peut se présenter de la façon suivante  :\nSELECT id, nom, marge_pourcentage, prix_unitaire, quantite, \n    CASE \n      WHEN marge_pourcentage=1 THEN 'Prix ordinaire'\n      WHEN marge_pourcentage>1 THEN 'Prix supérieur à la normale'\n      ELSE 'Prix inférieur à la normale'\n    END\nFROM `achat`\nRésultat :\nidnomsurchargeprix_unitairequantiteCASE\n1Produit A1.363Prix sup érieur  à la normale\n2Produit B1.582Prix sup érieur  à la normale\n3Produit C0.7574Prix inf érieur  à la normale\n4Produit D1152Prix ordinaire\nCe résultat montre qu’il est possible d’afficher facilement des messages personnalisés selon des \nconditions simples.\n32/89 sql.sh\nAfficher un prix unitaire différent selon une condition\nAvec un CASE il est aussi possible d’utiliser des requêtes plus élaborées. Imaginons maintenant que\nnous souhaitions multiplier le prix unitaire par 2 si la marge est supérieur à 1, la diviser par 2 si la \nmarge est inférieure à 1 et laisser le prix unitaire tel quel si la marge est égale à 1. C’est possible \ngrâce à la requête SQL  :\nSELECT id, nom, marge_pourcentage, prix_unitaire, quantite, \n  CASE \n    WHEN marge_pourcentage=1 THEN prix_unitaire\n    WHEN marge_pourcentage>1 THEN prix_unitaire*2\n    ELSE prix_unitaire/2\n   END\nFROM `achat`\nRésultat :\nidnom surchargeprix_unitaire quantite CASE\n1Produit A 1.36 3 12\n2Produit B 1.58 2 16\n3Produit C 0.757 4 3.5\n4Produit D 115 2 15\nComparer un champ à une valeur donnée\nImaginons maintenant que l’application propose des réductions selon le nombre de produits \nachetés :\n•1 produit acheté permet d’obtenir une réduction de -5% pour le prochain achat\n•2 produit acheté permet d’obtenir une réduction de -6% pour le prochain achat\n•3 produit acheté permet d’obtenir une réduction de -8% pour le prochain achat\n•Pour plus de produits achetés il y a un réduction de -10% pour le prochain achat\nPour effectuer une telle procédure, il est possible de comparer la colonne « quantite » aux différentes\nvaleurs spécifiée et d’afficher un message personnalisé en fonction du résultat. Cela peut être réalisé\navec cette requête SQL  :\nSELECT id, nom, marge_pourcentage, prix_unitaire, quantite,\n  CASE quantite\n    WHEN 0 THEN 'Erreur'\n    WHEN 1 THEN 'Offre de -5% pour le prochain achat'\n    WHEN 2 THEN 'Offre de -6% pour le prochain achat'\n    WHEN 3 THEN 'Offre de -8% pour le prochain achat'\n    ELSE 'Offre de -10% pour le prochain achat'\n  END\n FROM `achat`\nRésultat :\n33/89 sql.sh\nidnomsurchargeprix_unitairequantiteCASE\n1Produit A1.363Offre de ­8% pour le prochain achat\n2Produit B1.582Offre de ­6% pour le prochain achat\n3Produit C0.7574Offre de ­10% pour le prochain achat\n4Produit D1152Offre de ­6% pour le prochain achat\nAstuce : la condition ELSE peut parfois être utilisée pour gérer les erreurs.\nUPDATE avec CASE\nComme cela a été expliqué au début, il est aussi possible d’utiliser le CASE à la suite de la \ncommande SET d’un UPDATE pour mettre à jour une colonne avec une données spécifique selon \nune règle. Imaginons par exemple que l’ont souhaite offrir un produit pour tous les achats qui ont une\nsurcharge inférieur à 1 et que l’ont souhaite retirer un produit pour tous les achats avec une \nsurcharge supérieur à 1. Il est possible d’utiliser la requête SQL suivante  :\nUPDATE `achat`\nSET `quantite` = (\n  CASE \n    WHEN `surcharge` < 1 THEN `quantite` + 1\n    WHEN `surcharge` > 1 THEN `quantite` - 1\n    ELSE quantite\n  END\n)\n34/89 sql.sh\nSQL UNION\nLa commande UNION de SQL permet de mettre bout-à-bout les résultats de plusieurs requêtes \nutilisant elles-même la commande SELECT. C’est donc une commande qui permet de concaténer les\nrésultats de 2 requêtes ou plus. Pour l’utiliser il est nécessaire que chacune des requêtes à \nconcaténer retournes le même nombre de colonnes, avec les mêmes types de données et dans le \nmême ordre.\nA savoir : par défaut, les enregistrements exactement identiques ne seront pas répétés dans les \nrésultats. Pour effectuer une union dans laquelle même les lignes dupliquées sont affichées il faut \nplutôt utiliser la commande UNION ALL.\nSyntaxe\nLa syntaxe pour unir les résultats de 2 tableaux sans afficher les doublons est la suivante  :\nSELECT * FROM table1\nUNION\nSELECT * FROM table2\nSchéma explicatif\nL’union de 2 ensembles A et B est un concept qui consiste à obtenir tous les éléments qui \ncorrespondent à la fois à l’ensemble A ou à l’ensemble B. Cela se résume très simplement par un \npetit schéma où la zone en bleu correspond à la zone que l’ont souhaite obtenir (dans notre cas : \ntous les éléments).\nUnion de 2 ensembles\nExemple\nImaginons une entreprise qui possède plusieurs magasins et dans chacun de ces magasins il y a \nune table qui liste les clients.\nLa table du magasin n°1 s’appelle « magasin1_client » et contient les données suivantes  :\n35/89 sql.sh\n\nprenom nom ville date_naissance total_achat\nLéon Dupuis Paris 1983­03­06 135\nMarie Bernard Paris 1993­07­03 75\nSophie Dupond Marseille 1986­02­22 27\nMarcel Martin Paris 1976­11­24 39\nLa table du magasin n°2 s’appelle « magasin2_client » et contient les données suivantes  :\nprenom nom ville date_naissance total_achat\nMarion Leroy Lyon 1982­10­27 285\nPaul Moreau Lyon 1976­04­19 133\nMarie Bernard Paris 1993­07­03 75\nMarcel Martin Paris 1976­11­24 39\nSachant que certains clients sont présents dans les 2 tables, pour éviter de retourner plusieurs fois \nles mêmes enregistrement, il convient d’utiliser la requête UNION. La requête SQL est alors la \nsuivante :\nSELECT * FROM magasin1_client\nUNION\nSELECT * FROM magasin2_client\nRésultat :\nprenom nom ville date_naissance total_achat\nLéon Dupuis Paris 1983­03­06 135\nMarie Bernard Paris 1993­07­03 75\nSophie Dupond Marseille 1986­02­22 27\nMarcel Martin Paris 1976­11­24 39\nMarion Leroy Lyon 1982­10­27 285\nPaul Moreau Lyon 1976­04­19 133\nLe résultat de cette requête montre bien que les enregistrements des 2 requêtes sont mis bout-à-\nbout mais sans inclure plusieurs fois les mêmes lignes.\n36/89 sql.sh\nSQL UNION ALL\nLa commande UNION ALL de SQL est très similaire à la commande UNION. Elle permet de \nconcaténer les enregistrements de plusieurs requêtes, à la seule différence que cette commande \npermet d’inclure tous les enregistrements, même les doublons. Ainsi, si un même enregistrement est \nprésents normalement dans les résultats des 2 requêtes concaténées, alors l’union des 2 avec \nUNION ALL retournera 2 fois ce même résultat.\nA savoir : tout comme la commande UNION, il convient que les 2 requêtes retournes exactement le \nmême nombre de colonnes, avec les mêmes types de données et dans le même ordre.\nSyntaxe\nLa syntaxe de la requête SQL pour unir les résultats des 2 tables est la suivante  :\nSELECT * FROM table1\nUNION ALL\nSELECT * FROM table2\nExemple\nImaginons une entreprise qui possède des bases de données dans chacun de ces magasins. Sur \nces bases de données il y a une table de la liste des clients avec quelques informations et le total \ndes achats dans l’entreprise.\nLa table « magasin1_client » correspond au premier magasin  :\nprenom nom ville date_naissance total_achat\nLéon Dupuis Paris 1983­03­06 135\nMarie Bernard Paris 1993­07­03 75\nSophie Dupond Marseille 1986­02­22 27\nMarcel Martin Paris 1976­11­24 39\nLa table « magasin2_client » correspond au deuxième magasin  :\nprenom nom ville date_naissance total_achat\nMarion Leroy Lyon 1982­10­27 285\nPaul Moreau Lyon 1976­04­19 133\nMarie Bernard Paris 1993­07­03 75\nMarcel Martin Paris 1976­11­24 39\nPour concaténer les tous les enregistrements de ces tables, il est possible d’effectuer une seule \nrequête utilisant la commande UNION ALL, comme l’exemple ci-dessous  :\n37/89 sql.sh\nSELECT * FROM magasin1_client\nUNION ALL\nSELECT * FROM magasin2_client\nRésultat :\nprenom nom ville date_naissance total_achat\nLéon Dupuis Paris 1983­03­06 135\nMarie Bernard Paris 1993­07­03 75\nSophie Dupond Marseille 1986­02­22 27\nMarcel Martin Paris 1976­11­24 39\nMarion Leroy Lyon 1982­10­27 285\nPaul Moreau Lyon 1976­04­19 133\nMarie Bernard Paris 1993­07­03 75\nMarcel Martin Paris 1976­11­24 39\nLe résultat de cette requête montre qu’il y a autant d’enregistrement que dans les 2 tables réunis. A \nsavoir, il y a quelques clients qui étaient présents dans les 2 tables d’origines en conséquent ils sont \nprésent 2 fois dans le résultat de cette requête SQL.\n38/89 sql.sh\nSQL INTERSECT\nLa commande SQL INTERSECT permet d’obtenir l’intersection des résultats de 2 requêtes. Cette \ncommande permet donc de récupérer les enregistrements communs à 2 requêtes. Cela peut s’avérer\nutile lorsqu’il faut trouver s’il y a des données similaires sur 2 tables distinctes.\nA savoir : pour l’utiliser convenablement il faut que les 2 requêtes retourne le même nombre de \ncolonnes, avec les mêmes types et dans le même ordre.\nSyntaxe\nLa syntaxe à adopter pour utiliser cette commande est la suivante  :\nSELECT * FROM table1\nINTERSECT\nSELECT * FROM table2\nDans cet exemple, il faut que les 2 tables soient similaires (mêmes colonnes, mêmes types et même \nordre). Le résultat correspondra aux enregistrements qui existent dans table1 et dans table2.\nSchéma explicatif\nL’intersection de 2 ensembles A et B correspond aux éléments qui sont présent dans A et dans B, et \nseulement ceux-là. Cela peut être représenté par un schéma explicatif simple ou l’intersection de A et\nB correspond à la zone en bleu.\nIntersection de 2 ensembles\nExemple\nPrenons l’exemple de 2 magasins qui appartiennent au même groupe. Chaque magasin possède sa \ntable de clients.\nLa table du magasin n°1 est « magasin1_client »  :\nprenom nom ville date_naissance total_achat\nLéon Dupuis Paris 1983­03­06 135\nMarie Bernard Paris 1993­07­03 75\n39/89 sql.sh\n\nSophie Dupond Marseille 1986­02­22 27\nMarcel Martin Paris 1976­11­24 39\nLa table du magasin n°2 est « magasin2_client »  :\nprenom nom ville date_naissance total_achat\nMarion Leroy Lyon 1982­10­27 285\nPaul Moreau Lyon 1976­04­19 133\nMarie Bernard Paris 1993­07­03 75\nMarcel Martin Paris 1976­11­24 39\nPour obtenir la liste des clients qui sont présents de façon identiques dans ces 2 tables, il est \npossible d’utiliser la commande INTERSECT de la façon suivante  :\nSELECT * FROM magasin1_client\nINTERSECT\nSELECT * FROM magasin2_client\nRésultat :\nprenom nom ville date_naissance total_achat\nMarie Bernard Paris 1993­07­03 75\nMarcel Martin Paris 1976­11­24 39\nLe résultat présente 2 enregistrements, il s’agit des clients qui sont à la fois dans la table « \nmagasin1_client » et dans la table « magasin2_client ». Sur certains systèmes une telle requête \npermet de déceler des erreurs et d’enregistrer seulement à un seul endroit la même information.\n40/89 sql.sh\nSQL EXCEPT / MINUS\nDans le langage SQL la commande EXCEPT s’utilise entre 2 instructions pour récupérer les \nenregistrements de la première instruction sans inclure les résultats de la seconde requête. Si un \nmême enregistrement devait être présent dans les résultats des 2 syntaxes, ils ne seront pas présent\ndans le résultat final.\nA savoir : cette commande s’appelle différemment selon les Systèmes de Gestion de Base de \nDonnées (SGBD)  :\n•EXCEPT : PostgreSQL\n•MINUS : MySQL et Oracle\nDès lors, il faut remplacer tout le reste de ce cours par MINUS pour les SGBD correspondants.\nSyntaxe\nLa syntaxe d’une requête SQL est toute simple  :\nSELECT * FROM table1\nEXCEPT\nSELECT * FROM table2\nCette requête permet de lister les résultats du table 1 sans inclure les enregistrements de la table 1 \nqui sont aussi dans la table 2.\nAttention : les colonnes de la première requête doivent être similaires entre la première et la \ndeuxième requête (même nombre, même type et même ordre).\nSchéma explicatif\nCette commande permet de récupérer les éléments de l’ensemble A sans prendre en compte les \néléments de A qui sont aussi présent dans l’ensemble B. Dans le schéma ci-dessous seule la zone \nbleu sera retournée grâce à la commande EXCEPT (ou MINUS).\nSélection d’un ensemble avec exception\nExemple\nImaginons un système informatique d’une entreprise. Ce système contient 2 tables contenant des \n41/89 sql.sh\n\nlistes de clients :\n•Une table « clients_inscrits » qui contient les prénoms, noms et date d’inscription de clients\n•Une table « clients_refus_email » qui contient les informations des clients qui ne souhaitent \npas être contacté par email\nCet exemple aura pour objectif de sélectionner les utilisateurs pour envoyer un email d’information. \nLes utilisateurs de la deuxième table ne devront pas apparaître dans les résultats.\nTable « clients_inscrits »  :\nid prenom nom date_inscription\n1 Lionel Martineau 2012­11­14\n2 Paul Cornu 2012­12­15\n3 Sarah Schmitt 2012­12­17\n4 Sabine Lenoir 2012­12­18\nTable « clients_refus_email »  :\nid prenom nom date_inscription\n1 Paul Cornu 2013­01­27\n2 Manuel Guillot 2013­01­27\n3 Sabine Lenoir 2013­01­29\n4 Natalie Petitjean 2013­02­03\nPour pouvoir sélectionner uniquement le prénom et le nom des utilisateurs qui accepte de recevoir \ndes emails informatifs. La requête SQL à utiliser est la suivante  :\nSELECT prenom, nom FROM clients_inscrits\nEXCEPT\nSELECT prenom, nom FROM clients_refus_email\nRésultats :\nprenom nom\nLionel Martineau\nSarah Schmitt\nCe tableau de résultats montre bien les utilisateurs qui sont dans inscrits et qui ne sont pas présent \ndans le deuxième tableau. Par ailleurs, les résultats du deuxième tableau ne sont pas présent sur ce \nrésultat final.\n42/89 sql.sh\nSQL INSERT INTO\nL’insertion de données dans une table s’effectue à l’aide de la commande INSERT INTO. Cette \ncommande permet au choix d’inclure une seule ligne à la base existante ou plusieurs lignes d’un \ncoup.\nInsertion d’une ligne à la fois\nPour insérer des données dans une base, il y a 2 syntaxes principales  :\n•Insérer une ligne en indiquant les informations pour chaque colonne existante (en respectant \nl’ordre)\n•Insérer une ligne en spécifiant les colonnes que vous souhaiter compléter. Il est possible \nd’insérer une ligne en renseigner seulement une partie des colonnes\nInsérer une ligne en spécifiant toutes les colonnes\nLa syntaxe pour remplir une ligne avec cette méthode est la suivante  :\nINSERT INTO table \nVALUES ('valeur 1', 'valeur 2', ...)\nCette syntaxe possède les avantages et inconvénients suivants  :\n•Obliger de remplir toutes les données, tout en respectant l’ordre des colonnes\n•Il n’y a pas le nom de colonne, donc les fautes de frappe sont limitées. Par ailleurs, les \ncolonnes peuvent être renommées sans avoir à changer la requête\n•L’ordre des colonnes doit resté identique sinon certaines valeurs prennent le risque d’être \ncomplétée dans la mauvaise colonne\nInsérer une ligne en spécifiant seulement les colonnes souhaitées\nCette deuxième solution est très similaire, excepté qu’il faut indiquer le nom des colonnes avant « \nVALUES ». La syntaxe est la suivante  :\nINSERT INTO table \n(nom_colonne_1, nom_colonne_2, ...\nVALUES ('valeur 1', 'valeur 2', ...)\nA noter : il est possible de ne pas renseigner toutes les colonnes. De plus, l’ordre des colonnes n’est\npas important.\nInsertion de plusieurs lignes à la fois\nIl est possible d’ajouter plusieurs lignes à un tableau avec une seule requête. Pour ce faire, il \nconvient d’utiliser la syntaxe suivante  :\nINSERT INTO client (prenom, nom, ville, age)\n VALUES\n ('Rébecca', 'Armand', 'Saint-Didier-des-Bois', 24),\n ('Aimée', 'Hebert', 'Marigny-le-Châtel', 36),\n ('Marielle', 'Ribeiro', 'Maillères', 27),\n43/89 sql.sh\n ('Hilaire', 'Savary', 'Conie-Molitard', 58);\nA noter : lorsque le champ à remplir est de type VARCHAR ou TEXT il faut indiquer le texte entre \nguillemet simple. En revanche, lorsque la colonne est un numérique tel que INT ou BIGINT il n’y a \npas besoin d’utiliser de guillemet, il suffit juste d’indiquer le nombre.\nUn tel exemple sur une table vide va créer le tableau suivant  :\nidprenom nom ville age\n1RébeccaArmand Saint­Didier­des­Bois 24\n2AiméeHebert Marigny­le­Ch âtel 36\n3Marielle Ribeiro Maillères 27\n4Hilaire Savary Conie­Molitard 58\n44/89 sql.sh\nSQL ON DUPLICATE KEY UPDATE\nL’instruction ON DUPLICATE KEY UPDATE est une fonctionnalité de MySQL qui permet de mettre à \njour des données lorsqu’un enregistrement existe déjà dans une table. Cela permet d’avoir qu’une \nseule requête SQL pour effectuer selon la convenance un INSERT ou un UPDATE.\nSyntaxe\nCette commande s’effectue au sein de la requête INSERT INTO avec la syntaxe suivante  :\nINSERT INTO table (a, b, c)\nVALUES (1, 20, 68)\nON DUPLICATE KEY UPDATE a=a+1\nA noter : cette requête se traduit comme suit :\n1.insérer les données a, b et c avec les données respectives de 1, 20 et 68\n2.Si la clé primaire existe déjà pour ces valeurs alors seulement faire une mise à jour de a = a+1\nExemple avec la commande WHERE\nGrâce à la commande « ON DUPLICATE KEY » Il est possible d’enregistrer la date à laquelle la \ndonnées est insérée pour la première fois et la date de dernière mise à jour, comme le montre la \ncommande ci-dessous  :\nINSERT INTO table (a, b, c, date_insert)\nVALUES (1, 20, 1, NOW())\nON DUPLICATE KEY UPDATE date_update=NOW\nWHERE c=1\nA noter : cette requête se traduit comme suit :\n1.insérer les données a, b, c et date_insert, avec les données respectives de 1, 20, 1 ainsi que \nla date et l’heure actuelle\n2.Si la clé primaire existe déjà pour ces valeurs alors mettre a jour la date et l’heure du champ « \ndate_update »\n3.Effectuer la mise à jour uniquement sur les champs où c = 1\nExemple\nImaginons une application qui laisse les utilisateurs voter pour les produits qu’ils préfèrent. Le \nsystème de vote est très simple et est basé sur des +1. La table des votes contient le nombre de \nvotes par produits avec la date du premier vote et la date du dernier vote.\nTable vote :\nidproduit_idvote_count vote_first_date vote_last_date\n1462 2012­04­25 17:45:24 2013­02­16 09:47:02\n2394 2012­04­28 16:54:44 2013­02­14 21:04:35\n3491 2012­04­25 19:11:09 2013­01­06 20:32:57\n45/89 sql.sh\nPour n’utiliser qu’une seule ligne qui permet d’ajouter des votes dans cette table, sans se préoccuper\nde savoir s’il faut faire un INSERT ou un UPDATE, il est possible d’utiliser la requête SQL suivante  :\nINSERT INTO vote (produit_id, vote_count, vote_first_date, vote_last_date)\nVALUES (50, 1, NOW(), NOW())\nON DUPLICATE KEY UPDATE vote_count = vote_count+1, vote_last_date = NOW()\nDans cette requête la date et l’heure est générée automatiquement avec la fonction NOW().\nRésultat après la première exécution de la requête  :\nidproduit_idvote_count vote_first_date vote_last_date\n1462 2012­04­25 17:45:24 2013­02­16 09:47:02\n2394 2012­04­28 16:54:44 2013­02­14 21:04:35\n3491 2012­04­25 19:11:09 2013­01­06 20:32:57\n4551 2013­04­02 15:06:34 2013­04­02 15:06:34\nCe résultat montre bien l’ajout d’une ligne en fin de table, donc la requête a été utilisé sous la forme \nd’un INSERT. Après une deuxième exécution de cette même requête le lendemain, les données \nseront celles-ci:\nidproduit_idvote_count vote_first_date vote_last_date\n1462 2012­04­25 17:45:24 2013­02­16 09:47:02\n2394 2012­04­28 16:54:44 2013­02­14 21:04:35\n3491 2012­04­25 19:11:09 2013­01­06 20:32:57\n4552 2013­04­02 15:06:34 2013­04­03 08:14:57\nCes résultats montre bien qu’il y a eu un vote supplémentaire et que la date du dernier vote a été mis\nà jour.\nInsérer une ligne ou ne rien faire\nDans certains cas il est intéressant d’utiliser un INSERT mais de ne rien faire si la commande a déjà \nété insérée précédemment. Malheureusement, si la clé primaire existe déjà la requête retournera une\nerreur. Et s’il n’y a rien à mettre à jour, la commande ON DUPLICATE KEY UPDATE (ODKU) ne \nsemble pas convenir. Toutefois il y a une astuce qui consiste à utiliser une requête de ce type  :\nINSERT INTO table (a, b, c)\nVALUES (1, 45, 6)\nON DUPLICATE KEY UPDATE id = id\nCette requête insert les données et ne produit aucune erreur si l’enregistrement existait déjà dans la \ntable.\nA savoir : théoriquement il aurait été possible d’utiliser INSERT IGNORE mais malheureusement cela\n46/89 sql.sh\nempêche de retourner des erreurs telles que des erreurs de conversions de données.\nCompatibilité\nPour le moment cette fonctionnalité n’est possible qu’avec MySQL depuis la version 4.1 (date de \n2003). Les autres Systèmes de Gestion de Bases de Données (SGBD) n’intègrent pas cette \nfonctionnalité. Pour simuler cette fonctionnalité il y a quelques alternatives  :\n•PostgreSQL : il y a une astuce en utilisant une fonction. L’astuce est expliquée dans la \ndocumentation officielle : fonction INSERT/UPDATE.\n•Oracle : il est possible d’utiliser la commande MERGE pour effectuer la même chose.\n•SQL Server : il est possible d’utiliser une procédure.\n47/89 sql.sh\nSQL UPDATE\nLa commande UPDATE permet d’effectuer des modifications sur des lignes existantes. Très souvent \ncette commande est utilisée avec WHERE pour spécifier sur quelles lignes doivent porter la ou les \nmodifications.\nSyntaxe\nLa syntaxe basique d’une requête utilisant UPDATE est la suivante  :\nUPDATE table\nSET nom_colonne_1 = 'nouvelle valeur'\nWHERE condition\nCette syntaxe permet d’attribuer une nouvelle valeur à la colonne nom_colonne_1 pour les lignes qui \nrespectent la condition stipulé avec WHERE. Il est aussi possible d’attribuer la même valeur à la \ncolonne nom_colonne_1 pour toutes les lignes d’une table si la condition WHERE n’était pas utilisée.\nA noter, pour spécifier en une seule fois plusieurs modification, il faut séparer les attributions de \nvaleur par des virgules. Ainsi la syntaxe deviendrait la suivante  :\nUPDATE table\nSET colonne_1 = 'valeur 1', colonne_2 = 'valeur 2', colonne_3 = 'valeur 3'\nWHERE condition\nExemple\nidnomrue villecode_postalpays\n1Chantal12 Avenue du Petit Trianon Puteaux92800France\n2Pierre18 Rue de l'Allier Ponthion51300France\n3Romain3 Chemin du Chiron Trévérien35190France\nImaginons une table « client » qui présente les coordonnées de clients.\nPour modifier l’adresse du client Pierre, il est possible d’utiliser la requête suivante  :\nUPDATE client\nSET rue = '49 Rue Ameline',\n  ville = 'Saint-Eustache-la-Forêt',\n  code_postal = '76210'\nWHERE id = 2\nRésultat :\nidnomrue ville code_postalpays\n1Chantal12 Avenue du Petit Trianon Puteaux 92800France\n2Pierre49 Rue Ameline Saint­Eustache­la­For êt76210France\n3Romain3 Chemin du Chiron Trévérien 35190France\n48/89 sql.sh\nSQL DELETE\nLa commande DELETE en SQL permet de supprimer des lignes dans une table. En utilisant cette \ncommande associé à WHERE il est possible de sélectionner les lignes concernées qui seront \nsupprimées.\nAttention : Avant d’essayer de supprimer des lignes, il est recommandé d’effectuer une sauvegarde \nde la base de données, ou tout du moins de la table concernée par la suppression. Ainsi, s’il y a une \nmauvaise manipulation il est toujours possible de restaurer les données.\nSyntaxe\nLa syntaxe pour supprimer des lignes est la suivante  :\nDELETE FROM table\nWHERE condition\nAttention : s’il n’y a pas de condition WHERE alors toutes les lignes seront supprimées et la table \nsera alors vide.\nExemple\nImaginons une table « utilisateur » qui contient des informations sur les utilisateurs d’une application.\nid nom prenom date_inscription\n1 Bazin Daniel 2012­02­13\n2 Favre Constantin 2012­04­03\n3 Clerc Guillaume 2012­04­12\n4 Ricard Rosemonde 2012­06­24\n5 Martin Natalie 2012­07­02\nSi l’ont souhaite supprimer les utilisateurs qui se sont inscrit avant le « 10/04/2012″, il va falloir \neffectuer la requête suivante  :\nDELETE FROM utilisateur\nWHERE date_inscription < '2012-04-10'\nLa requête permettra alors de supprimer les utilisateurs « Daniel » et « Constantin ». La table \ncontiendra alors les données suivantes  :\nid nom prenom date_inscription\n3 Clerc Guillaume 2012­04­12\n4 Ricard Rosemonde 2012­06­24\n5 Martin Natalie 2012­07­02\nIl ne faut pas oublier qu’il est possible d’utiliser d’autres conditions pour sélectionner les lignes à \nsupprimer.\n49/89 sql.sh\nSQL MERGE\nDans le langage SQL, la commande MERGE permet d’insérer ou de mettre à jour des données dans\nune table. Cette commande permet d’éviter d’effectuer plusieurs requêtes pour savoir si une donnée \nest déjà dans la base de données et ainsi adapter l’utilisation d’une requête pour ajouter ou une autre\npour modifier la donnée existante. Cette commande peut aussi s’appeler « upsert ».\nAttention : bien que l’instruction a été ajoutée dans le standard SQL:2003, les différentes SGBD \nn’utilisent pas toutes les mêmes méthodes pour effectuer un upsert.\nSyntaxe\nLa syntaxe standard pour effectuer un merge consiste à utiliser une requête SQL semblable à celle \nci-dessous :\nMERGE INTO table1\n  USING table_reference\n  ON (conditions)\n  WHEN MATCHED THEN\n    UPDATE SET table1.colonne1 = valeur1, table1.colonne2 = valeur2\n    DELETE WHERE conditions2\n  WHEN NOT MATCHED THEN\n    INSERT (colonnes1, colonne3) \n    VALUES (valeur1, valeur3)\nVoici les explications détaillées de cette requête  :\n•MERGE INTO permet de sélectionner la table à modifier\n•USING et ON permet de lister les données sources et la condition de correspondance\n•WHEN MATCHED permet de définir la condition de mise à jour lorsque la condition est \nvérifiée\n•WHEN NOT MATCHED permet de définir la condition d’insertion lorsque la condition n’est pas\nvérifiée\nCompatibilité\nLes systèmes de gestion de bases de données peuvent implémenter cette fonctionnalité soit de \nfaçon standard, en utilisant une commande synonyme ou en utilisant une syntaxe non standard.\n•Syntaxe standard  : SQL Server, Oracle, DB2, Teradata et EXASOL\n•Utilisation du terme UPSERT  : Microsoft SQL Azure et MongoDB\n•Utilisation non standard  : MySQL, SQLite, Firebird, IBM DB2 et Microsoft SQL\n50/89 sql.sh\nSQL TRUNCATE TABLE\nEn SQL, la commande TRUNCATE permet de supprimer toutes les données d’une table sans \nsupprimer la table en elle-même. En d’autres mots, cela permet de purger la table. Cette instruction \ndiffère de la commande DROP qui à pour but de supprimer les données ainsi que la table qui les \ncontient.\nA noter : l’instruction TRUNCATE est semblable à l’instruction DELETE sans utilisation de WHERE. \nParmi les petite différences TRUNCATE est toutefois plus rapide et utilise moins de ressource. Ces \ngains en performance se justifie notamment parce que la requête n’indiquera pas le nombre \nd’enregistrement supprimés et qu’il n’y aura pas d’enregistrement des modifications dans le journal.\nSyntaxe\nCette instruction s’utilise dans une requête SQL semblable à celle-ci  :\nTRUNCATE TABLE `table`\nDans cet exemple, les données de la table « table » seront perdues une fois cette requête exécutée.\nExemple\nPour montrer un exemple concret de l’utilisation de cette commande, nous pouvons imaginez un \nsystème informatique contenant la liste des fournitures d’une entreprise. Ces données seraient tout \nsimplement stockées dans une table « fourniture ».\nTable « fourniture »  :\nid nom date_ajout\n1 Ordinateur 2013-04-05\n2 Chaise 2013-04-14\n3 Bureau 2013-07-18\n4 Lampe 2013-09-27\nIl est possible de supprimer toutes les données de cette table en utilisant la requête suivante  :\nTRUNCATE TABLE `fourniture`\nUne fois la requête exécutée, la table ne contiendra plus aucun enregistrement. En d’autres mots, \ntoutes les lignes du tableau présenté ci-dessus auront été supprimées.\n51/89 sql.sh\nSQL CREATE DATABASE\nLa création d’une base de données en SQL est possible en ligne de commande. Même si les \nsystèmes de gestion de base de données (SGBD) sont souvent utilisés pour créer une base, il \nconvient de connaître la commande à utiliser, qui est très simple.\nSyntaxe\nPour créer une base de données qui sera appelé « ma_base » il suffit d’utiliser la requête suivante \nqui est très simple  :\nCREATE DATABASE ma_base\nBase du même nom qui existe déjà\nAvec MySQL, si une base de données porte déjà ce nom, la requête retournera une erreur. Pour \néviter d’avoir cette erreur, il convient d’utiliser la requête suivante pour MySQL  :\nCREATE DATABASE IF NOT EXISTS ma_base\nL’option IF NOT EXISTS permet juste de ne pas retourner d’erreur si une base du même nom existe \ndéjà. La base de données ne sera pas écrasée.\nOptions\nDans le standard SQL la commande CREATE DATABASE n’existe normalement pas. En conséquent\nil revient de vérifier la documentation des différents SGBD pour vérifier les syntaxes possibles pour \ndéfinir des options. Ces options permettent selon les cas, de définir les jeux de caractères, le \npropriétaire de la base ou même les limites de connexion.\n52/89 sql.sh\nSQL DROP DATABASE\nEn SQL, la commande DROP DATABASE permet de supprimer totalement une base de données et \ntout ce qu’elle contient. Cette commande est à utiliser avec beaucoup d’attention car elle permet de \nsupprimer tout ce qui est inclus dans une base: les tables, les données, les index …\nSyntaxe\nPour supprimer la base de données « ma_base », la requête est la suivante  :\nDROP DATABASE ma_base\nAttention : cela va supprimer toutes les tables et toutes les données de cette base. Si vous n’êtes \npas sûr de ce que vous faites, n’hésitez pas à effectuer une sauvegarde de la base avant de \nsupprimer.\nNe pas afficher d’erreur si la base n’existe pas\nPar défaut, si le nom de base utilisé n’existe pas, la requête retournera une erreur. Pour éviter \nd’obtenir cette erreur si vous n’êtes pas sûr du nom, il est possible d’utiliser l’option IF EXISTS. La \nsyntaxe sera alors la suivante  :\nDROP DATABASE IF EXISTS ma_base\n53/89 sql.sh\nSQL CREATE TABLE\nLa commande CREATE TABLE permet de créer une table en SQL. Un tableau est une entité qui est \ncontenu dans une base de données pour stocker des données ordonnées dans des colonnes. La \ncréation d’une table sert à définir les colonnes et le type de données qui seront contenus dans \nchacun des colonne (entier, chaîne de caractères, date, valeur binaire …).\nSyntaxe\nLa syntaxe générale pour créer une table est la suivante  :\nCREATE TABLE nom_de_la_table\n(\n    colonne1 type_donnees,\n    colonne2 type_donnees,\n    colonne3 type_donnees,\n    colonne4 type_donnees\n)\nDans cette requête, 4 colonnes ont été définies. Le mot-clé « type_donnees » sera à remplacer par \nun mot-clé pour définir le type de données (INT, DATE, TEXT …). Pour chaque colonne, il est \négalement possible de définir des options telles que (liste non-exhaustive)  :\n•NOT NULL : empêche d’enregistrer une valeur nulle pour une colonne.\n•DEFAULT : attribuer une valeur par défaut si aucune données n’est indiquée pour cette \ncolonne lors de l’ajout d’une ligne dans la table.\n•PRIMARY KEY : indiquer si cette colonne est considérée comme clé primaire pour un index.\nExemple\nImaginons que l’ont souhaite créer une table utilisateur, dans laquelle chaque ligne correspond à un \nutilisateur inscrit sur un site web. La requête pour créer cette table peut ressembler à ceci  :\nCREATE TABLE utilisateur\n(\n    id INT PRIMARY KEY NOT NULL,\n    nom VARCHAR(100),\n    prenom VARCHAR(100),\n    email VARCHAR(255),\n    date_naissance DATE,\n    pays VARCHAR(255),\n    ville VARCHAR(255),\n    code_postal VARCHAR(5),\n    nombre_achat INT\n)\nVoici des explications sur les colonnes créées  :\n•id : identifiant unique qui est utilisé comme clé primaire et qui n’est pas nulle\n•nom : nom de l’utilisateur dans une colonne de type VARCHAR avec un maximum de 100 \n54/89 sql.sh\ncaractères au maximum\n•prenom : idem mais pour le prénom\n•email : adresse email enregistré sous 255 caractères au maximum\n•date_naissance : date de naissance enregistré au format AAAA-MM-JJ (exemple : 1973-11-\n17)\n•pays : nom du pays de l’utilisateur sous 255 caractères au maximum\n•ville : idem pour la ville\n•code_postal : 5 caractères du code postal\n•nombre_achat : nombre d’achat de cet utilisateur sur le site\n55/89 sql.sh\nSQL ALTER TABLE\nLa commande ALTER TABLE en SQL permet de modifier une table existante. Il est ainsi possible \nd’ajouter une colonne, d’en supprimer une ou de modifier une colonne existante, par exemple pour \nchanger le type.\nSyntaxe de base\nD’une manière générale, la commande s’utilise de la manière suivante  :\nALTER TABLE nom_table\ninstruction\nLe mot-clé « instruction » ici sert à désigner une commande supplémentaire, qui sera détaillée ci-\ndessous selon l’action que l’ont souhaite effectuer : ajouter, supprimer ou modifier une colonne.\nAjouter une colonne\nSyntaxe\nL’ajout d’une colonne dans une table est relativement simple et peut s’effectuer à l’aide d’une requête\nressemblant à ceci  :\nALTER TABLE nom_table\nADD nom_colonne type_donnees\nExemple\nPour ajouter une colonne qui correspond à une rue sur une table utilisateur, il est possible d’utiliser la\nrequête suivante :\nALTER TABLE utilisateur\nADD adresse_rue VARCHAR(255)\nSupprimer une colonne\nUne syntaxe permet également de supprimer une colonne pour une table. Il y a 2 manières \ntotalement équivalente pour supprimer une colonne  :\nALTER TABLE nom_table\nDROP nom_colonne\nOu (le résultat sera le même)\nALTER TABLE nom_table\nDROP COLUMN nom_colonne\nModifier une colonne\nPour modifier une colonne, comme par exemple changer le type d’une colonne, il y a différentes \nsyntaxes selon le SGBD.\n56/89 sql.sh\nMySQL\nALTER TABLE nom_table\nMODIFY nom_colonne type_donnees\nPostgreSQL\nALTER TABLE nom_table\nALTER COLUMN nom_colonne TYPE type_donnees\nIci, le mot-clé « type_donnees » est à remplacer par un type de données tel que INT, VARCHAR, \nTEXT, DATE …\nRenommer une colonne\nPour renommer une colonne, il convient d’indiquer l’ancien nom de la colonne et le nouveau nom de \ncelle-ci.\nMySQL\nPour MySQL, il faut également indiquer le type de la colonne.\nALTER TABLE nom_table \nCHANGE colonne_ancien_nom colonne_nouveau_nom type_donnees\nIci « type_donnees » peut correspondre par exemple à INT, VARCHAR, TEXT, DATE …\nPostgreSQL\nPour PostgreSQL la syntaxe est plus simple et ressemble à ceci (le type n’est pas demandé)  :\nALTER TABLE nom_table\nRENAME COLUMN colonne_ancien_nom TO colonne_nouveau_nom\n57/89 sql.sh\nSQL DROP TABLE\nLa commande DROP TABLE en SQL permet de supprimer définitivement une table d’une base de \ndonnées. Cela supprime en même temps les éventuels index, trigger, contraintes et permissions \nassociées à cette table.\nAttention : il faut utiliser cette commande avec attention car une fois supprimée, les données sont \nperdues. Avant de l’utiliser sur une base importante il peut être judicieux d’effectuer un backup (une \nsauvegarde) pour éviter les mauvaises surprises.\nSyntaxe\nPour supprimer une table « nom_table » il suffit simplement d’utiliser la syntaxe suivante  :\nDROP TABLE nom_table\nA savoir : s’il y a une dépence avec une autre table, il est recommandé de les supprimer avant de \nsupprimer la table. C’est le cas par exemple s’il y a des clés étrangères.\nIntérêts\nIl arrive qu’une table soit créé temporairement pour stoquer des données qui n’ont pas vocation à \nêtre ré-utiliser. La suppression d’une table non utilisée est avantageux sur plusieurs aspects :\n•Libérer de la mémoire et alléger le poids des backups\n•Éviter des erreurs dans le futur si une table porte un nom similaire ou qui porte à confusion\n•Lorsqu’un développeur ou administrateur de base de données découvre une application, il est \nplus rapide de comprendre le système s’il n’y a que les tables utilisées qui sont présente\nExemple de requête\nImaginons qu’une base de données possède une table «  client_2009 » qui ne sera plus jamais utilisé\net qui existe déjà dans un ancien backup. Pour supprimer cette table, il suffit d’effectuer la requête \nsuivante :\nDROP TABLE client_2009\nL’exécution de cette requête va permettre de supprimer la table.\n58/89 sql.sh\nJointure SQL\nLes jointures en SQL permettent d’associer plusieurs tables dans une même requête. Cela permet \nd’exploiter la puissance des bases de données relationnelles pour obtenir des résultats qui \ncombinent les données de plusieurs tables de manière efficace.\nExemple\nEn général, les jointures consistent à associer des lignes de 2 tables en associant l’égalité des \nvaleurs d’une colonne d’une première table par rapport à la valeur d’une colonne d’une seconde \ntable. Imaginons qu’une base de 2 données possède une table « utilisateur » et une autre table « \nadresse » qui contient les adresses de ces utilisateurs. Avec une jointure, il est possible d’obtenir les \ndonnées de l’utilisateur et de son adresse en une seule requête.\nOn peut aussi imaginer qu’un site web possède une table pour les articles (titre, contenu, date de \npublication …) et une autre pour les rédacteurs (nom, date d’inscription, date de naissance …). Avec \nune jointure il est possible d’effectuer une seule recherche pour afficher un article et le nom du \nrédacteur. Cela évite d’avoir à afficher le nom du rédacteur dans la table « article ».\nIl y a d’autres cas de jointures, incluant des jointures sur la même table ou des jointure d’inégalité. \nCes cas étant assez particulier et pas si simple à comprendre, ils ne seront pas élaboré sur cette \npage.\nTypes de jointures\nIl y a plusieurs méthodes pour associer 2 tables ensemble. Voici la liste des différentes techniques \nqui sont utilisées :\n•INNER JOIN : jointure interne pour retourner les enregistrements quand la condition est vrai \ndans les 2 tables. C’est l’une des jointures les plus communes.\n•CROSS JOIN : jointure croisée permettant de faire le produit cartésien de 2 tables. En \nd’autres mots, permet de joindre chaque lignes d’une table avec chaque lignes d’une seconde \ntable. Attention, le nombre de résultats est en général très élevé.\n•LEFT JOIN (ou LEFT OUTER JOIN)  : jointure externe pour retourner tous les \nenregistrements de la table de gauche (LEFT = gauche) même si la condition n’est pas vérifié \ndans l’autre table.\n•RIGHT JOIN (ou RIGHT OUTER JOIN)  : jointure externe pour retourner tous les \nenregistrements de la table de droite (RIGHT = droite) même si la condition n’est pas vérifié \ndans l’autre table.\n•FULL JOIN (ou FULL OUTER JOIN)  : jointure externe pour retourner les résultats quand la \ncondition est vrai dans au moins une des 2 tables.\n•SELF JOIN : permet d’effectuer une jointure d’une table avec elle-même comme si c’était une \nautre table.\n•NATURAL JOIN : jointure naturelle entre 2 tables s’il y a au moins une colonne qui porte le \nmême nom entre les 2 tables SQL\n•UNION JOIN : jointure d’union\n59/89 sql.sh\nSQL INNER JOIN\nDans le langage SQL la commande INNER JOIN, aussi appelée EQUIJOIN, est un type de jointures \ntrès communes pour lier plusieurs tables entre-elles. Cette commande retourne les enregistrements \nlorsqu’il y a au moins une ligne dans chaque colonne qui correspond à la condition.\nSyntaxe\nPour utiliser ce type de jointure il convient d’utiliser une requête SQL avec cette syntaxe  :\nSELECT *\nFROM table1\nINNER JOIN table2 ON table1.id = table2.fk_id\nLa syntaxe ci-dessus stipule qu’il faut sélectionner les enregistrements des tables table1 et table2 \nlorsque les données de la colonne « id » de table1 est égal aux données de la colonne fk_id de \ntable2.\nLa jointure SQL peux aussi être écrite de la façon suivante  :\nSELECT *\nFROM table1\nINNER JOIN table2\nWHERE table1.id = table2.fk_id\nLa syntaxe avec la condition WHERE est une manière alternative de faire la jointure mais qui \npossède l’inconvénient d’être moins facile à lire s’il y a déjà plusieurs conditions dans le WHERE.\nExemple\nImaginons une application qui possède une table utilisateur ainsi qu’une table commande qui \ncontient toutes les commandes effectuées par les utilisateurs.\nTable utilisateur  :\nidprenomnom email ville\n1AiméeMarechal aime.marechal@example.com Paris\n2EsméeLefort esmee.lefort@example.com Lyon\n3MarinePrevost m.prevost@example.com Lille\n4LucRolland lucrolland@example.com Marseille\nTable commande :\n60/89 sql.sh\nutilisateur_id date_achat num_facture prix_total\n1 2013­01­23 A00103 203.14\n1 2013­02­14 A00104 124.00\n2 2013­02­17 A00105 149.45\n2 2013­02­21 A00106 235.35\n5 2013­03­02 A00107 47.58\nPour afficher toutes les commandes associées aux utilisateurs, il est possible d’utiliser la requête \nsuivante :\nSELECT id, prenom, nom, date_achat, num_facture, prix_total\nFROM utilisateur\nINNER JOIN commande ON utilisateur.id = commande.utilisateur_id\nRésultats :\nidprenomnomdate_achatnum_factureprix_total\n1AiméeMarechal2013­01­23A00103203.14\n1AiméeMarechal2013­02­14A00104124.00\n2EsméeLefort2013­02­17A00105149.45\n2EsméeLefort2013­02­21A00106235.35\nLe résultat de la requête montre parfaite la jointure entre les 2 tables. Les utilisateurs 3 et 4 ne sont \npas affichés puisqu’il n’y a pas de commandes associés à ces utilisateurs.\nAttention : il est important de noter que si un utilisateur à été supprimé, alors on ne verra pas ses \ncommandes dans la liste puisque INNER JOIN retourne uniquement les résultats ou la condition est \nvrai dans les 2 tables.\n61/89 sql.sh\nSQL CROSS JOIN\nDans le langage SQL, la commande CROSS JOIN est un type de jointure sur 2 tables SQL qui \npermet de retourner le produit cartésien. Autrement dit, cela permet de retourner chaque ligne d’une \ntable avec chaque ligne d’une autre table. Ainsi effectuer le produit cartésien d’une table A qui \ncontient 30 résultats avec une table B de 40 résultats va produire 1200 résultats (30 x 40 = 1200). En\ngénéral la commande CROSS JOIN est combinée avec la commande WHERE pour filtrer les \nrésultats qui respectent certaines conditions.\nAttention, le nombre de résultat peut facilement être très élevé. S’il est effectué sur des tables avec \nbeaucoup d’enregistrements, cela peut ralentir sensiblement le serveur.\nSyntaxe\nPour effectuer un jointure avec CROSS JOIN, il convient d’effectuer une requête SQL respectant la \nsyntaxe suivante :\nSELECT *\nFROM table1\nCROSS JOIN table2\nMéthode alternative pour retourner les mêmes résultats  :\nSELECT *\nFROM table1, table2\nL’une ou l’autre de ces syntaxes permettent d’associer tous les résultats de table1 avec chacun des \nrésultats de table2.\nExemple\nImaginons une application de recettes de cuisines qui contient 2 tables d’ingrédients, la table legume \net la table fruit.\nTable legume :\nl_id l_nom_fr_fr l_nom_en_gb\n45 Carotte Carott\n46 Oignon Onion\n47 Poireau Leek\nTable fruit :\nf_id f_nom_fr_fr f_nom_en_gb\n87 Banane Banana\n88 Kiwi Kiwi\n89 Poire Pear\n62/89 sql.sh\nPour une raison quelconque l’application doit associer tous les légumes avec tous les fruits. Toutes \nles combinaisons doivent être affichées. Pour cela il convient d’effectuer l’une ou l’autre des requêtes\nsuivantes :\nSELECT l_id, l_nom_fr_fr, f_id, f_nom_fr_fr\nFROM legume\nCROSS JOIN fruit\nou :\nSELECT l_id, l_nom_fr_fr, f_id, f_nom_fr_fr\nFROM legume, fruit\nRésultats :\nl_id l_nom_fr_fr f_id f_nom_fr_fr\n45 Carotte 87 Banane\n45 Carotte 88 Kiwi\n45 Carotte 89 Poire\n46 Oignon 87 Banane\n46 Oignon 88 Kiwi\n46 Oignon 89 Poire\n47 Poireau 87 Banane\n47 Poireau 88 Kiwi\n47 Poireau 89 Poire\nLe résultat montre bien que chaque légume est associé à chaque fruit. Avec 3 fruits et 3 légumes, il y\na donc 9 lignes de résultats (3 x3 = 9).\n63/89 sql.sh\nSQL LEFT JOIN\nDans le langage SQL, la commande LEFT JOIN (aussi appelée LEFT OUTER JOIN) est un type de \njointure entre 2 tables. Cela permet de lister tous les résultats de la table de gauche (left = gauche) \nmême s’il n’y a pas de correspondance dans la deuxième tables.\nSyntaxe\nPour lister les enregistrement de table1, même s’il n’y a pas de correspondance avec table2, il \nconvient d’effectuer une requête SQL utilisant la syntaxe suivante.\nSELECT *\nFROM table1\nLEFT JOIN table2 ON table1.id = table2.fk_id\nLa requête peux aussi s’écrire de la façon suivante  :\nSELECT *\nFROM table1\nLEFT OUTER JOIN table2 ON table1.id = table2.fk_id\nCette requête est particulièrement intéressante pour récupérer les informations de table1 tout en \nrécupérant les données associées, même s’il n’y a pas de correspondance avec table2. A savoir, s’il \nn’y a pas de correspondance les colonnes de table2 vaudront toutes NULL.\nExemple\nImaginons une application contenant des utilisateurs et des commandes pour chacun de ces \nutilisateurs. La base de données de cette application contient une table pour les utilisateurs et \nsauvegarde leurs achats dans une seconde table. Les 2 tables sont reliées grâce à la colonne \nutilisateur_id de la table des commandes. Cela permet d’associer une commande à un utilisateur.\nTable utilisateur  :\nidprenomnom email ville\n1AiméeMarechal aime.marechal@example.com Paris\n2EsméeLefort esmee.lefort@example.com Lyon\n3MarinePrevost m.prevost@example.com Lille\n4LucRolland lucrolland@example.com Marseille\nTable commande  :\n64/89 sql.sh\nutilisateur_id date_achat num_facture prix_total\n1 2013­01­23 A00103 203.14\n1 2013­02­14 A00104 124.00\n2 2013­02­17 A00105 149.45\n2 2013­02­21 A00106 235.35\n5 2013­03­02 A00107 47.58\nPour lister tous les utilisateurs avec leurs commandes et afficher également les utilisateurs qui n’ont \npas effectuées d’achats, il est possible d’utiliser la requête suivante  :\nSELECT *\nFROM utilisateur\nLEFT JOIN commande ON utilisateur.id = commande.utilisateur_id\nRésultats :\nidprenomnomdate_achat num_facture prix_total\n1AiméeMarechal2013­01­23 A00103 203.14\n1AiméeMarechal2013­02­14 A00104 124.00\n2EsméeLefort2013­02­17 A00105 149.45\n2EsméeLefort2013­02­21 A00106 235.35\n3MarinePrevostNULL NULL NULL\n4LucRollandNULL NULL NULL\nLes dernières lignes montrent des utilisateurs qui n’ont effectuée aucune commande. La ligne \nretourne la valeur NULL pour les colonnes concernant les achats qu’ils n’ont pas effectués.\nFiltrer sur la valeur NULL\nAttention, la valeur NULL n’est pas une chaîne de caractère. Pour filtrer sur ces caractères il faut \nutiliser la commande IS NULL. Par exemple, pour lister les utilisateurs qui n’ont pas effectués \nd’achats  il est possible d’utiliser la requête suivante.\nSELECT id, prenom, nom, utilisateur_id\nFROM utilisateur\nLEFT JOIN commande ON utilisateur.id = commande.utilisateur_id\nWHERE utilisateur_id IS NULL\nRésultats :\nid prenom nom utilisateur_id\n3 Marine Prevost NULL\n4 Luc Rolland NULL\n65/89 sql.sh\nSQL RIGHT JOIN\nEn SQL, la commande RIGHT JOIN (ou RIGHT OUTER JOIN) est un type de jointure entre 2 tables \nqui permet de retourner tous les enregistrements de la table de droite (right = droite) même s’il n’y a \npas de correspondance avec la table de gauche. S’il y a un enregistrement de la table de droite qui \nne trouve pas de correspondance dans la table de gauche, alors les colonnes de la table de gauche \nauront NULL pour valeur.\nSyntaxe\nL’utilisation de cette commande SQL s’effectue de la façon suivante  :\nSELECT *\nFROM table1\nRIGHT JOIN table2 ON table1.id = table2.fk_id\nLa syntaxe de cette requête SQL peux aussi s’écrire de la façon suivante  :\nSELECT *\nFROM table1\nRIGHT OUTER JOIN table2 ON table1.id = table2.fk_id\nCette syntaxe stipule qu’il faut lister toutes les lignes du tableau table2 (tableau de droite) et afficher \nles données associées du tableau table1 s’il y a une correspondance entre ID de table1 et FK_ID de \ntable2. S’il n’y a pas de correspondance, l’enregistrement de table2 sera affiché et les colonnes de \ntable1 vaudront toutes NULL.\nExemple\nPrenons l’exemple d’une base de données qui contient des utilisateurs et un historique d’achat de \nces utilisateurs. Cette 2 tables sont reliées entre grâce à la colonne utilisateur_id de la table des \ncommandes. Cela permet de savoir à quel utilisateur est associé un achat.\nTable utilisateur  :\nidprenomnomemail villeactif\n1AiméeMarechalaime.marechal@example.com Paris1\n2EsméeLefortesmee.lefort@example.com Lyon0\n3MarinePrevostm.prevost@example.com Lille1\n4LucRollandlucrolland@example.com Marseille1\nTable commande  :\n66/89 sql.sh\nutilisateur_id date_achat num_facture prix_total\n1 2013­01­23 A00103 203.14\n1 2013­02­14 A00104 124.00\n2 2013­02­17 A00105 149.45\n3 2013­02­21 A00106 235.35\n5 2013­03­02 A00107 47.58\nPour afficher toutes les commandes avec le nom de l’utilisateur correspondant il est normalement \nd’habitude d’utiliser INNER JOIN en SQL. Malheureusement, si l’utilisateur a été supprimé de la \ntable, alors ça ne retourne pas l’achat. L’utilisation de RIGHT JOIN permet de retourner tous les \nachats et d’afficher le nom de l’utilisateur s’il existe. Pour cela il convient d’utiliser cette requête  :\nSELECT id, prenom, nom, utilisateur_id, date_achat, num_facture\nFROM utilisateur\nRIGHT JOIN commande ON utilisateur.id = commande.utilisateur_id\nRésultats :\nidprenomnomutilisateur_id date_achat num_facture\n1AiméeMarechal1 2013­01­23 A00103\n1AiméeMarechal1 2013­02­14 A00104\n2EsméeLefort2 2013­02­17 A00105\n3MarinePrevost3 2013­02­21 A00106\nNULLNULLNULL5 2013­03­02 A00107\nCe résultat montre que la facture A00107 est liée à l’utilisateur numéro 5. Or, cet utilisateur n’existe \npas ou n’existe plus. Grâce à RIGHT JOIN, l’achat est tout de même affiché mais les informations \nliées à l’utilisateur sont remplacé par NULL.\n67/89 sql.sh\nSQL FULL JOIN\nDans le langage SQL, la commande FULL JOIN (ou FULL OUTER JOIN) permet de faire une \njointure entre 2 tables. L’utilisation de cette commande permet de combiner les résultats des 2 tables,\nles associer entre eux grâce à une condition et remplir avec des valeurs NULL si la condition n’est \npas respectée.\nSyntaxe\nPour retourner les enregistrements de table1 et table2, il convient d’utiliser une requête SQL avec \nune syntaxe telle que celle-ci  :\nSELECT *\nFROM table1\nFULL JOIN table2 ON table1.id = table2.fk_id\nCette requête peut aussi être conçu de cette façon  :\nSELECT *\nFROM table1\nFULL OUTER JOIN table2 ON table1.id = table2.fk_id\nLa condition présentée ici consiste à lier les tables sur un identifiant, mais la condition peut être \ndéfinie sur d’autres champs.\nExemple\nPrenons l’exemple d’une base de données qui contient une table utilisateur ainsi qu’une table \ncommande qui contient toutes les ventes.\nTable utilisateur  :\nidprenomnomemail villeactif\n1AiméeMarechalaime.marechal@example.com Paris1\n2EsméeLefortesmee.lefort@example.com Lyon0\n3MarinePrevostm.prevost@example.com Lille1\n4LucRollandlucrolland@example.com Marseille1\nTable commande  :\nutilisateur_id date_achat num_facture prix_total\n1 2013­01­23 A00103 203.14\n1 2013­02­14 A00104 124.00\n2 2013­02­17 A00105 149.45\n3 2013­02­21 A00106 235.35\n5 2013­03­02 A00107 47.58\n68/89 sql.sh\nIl est possible d’utiliser FULL JOIN pour lister tous les utilisateurs ayant effectué ou non une vente, et\nde lister toutes les ventes qui sont associées ou non à un utilisateur. La requête SQL est la suivante  :\nSELECT id, prenom, nom, utilisateur_id, date_achat, num_facture\nFROM utilisateur\nFULL JOIN commande ON utilisateur.id = commande.utilisateur_id\nRésultat :\nidprenomnomutilisateur_id date_achat num_facture\n1AiméeMarechal1 2013­01­23 A00103\n1AiméeMarechal1 2013­02­14 A00104\n2EsméeLefort2 2013­02­17 A00105\n3MarinePrevost3 2013­02­21 A00106\n4LucRollandNULL NULL NULL\nNULLNULL 5 2013­03­02 A00107\nCe résultat affiche bien l’utilisateur numéro 4 qui n’a effectué aucun achat. Le résultat retourne \négalement la facture A00107 qui est associée à un utilisateur qui n’existe pas (ou qui n’existe plus). \nDans les cas où il n’y a pas de correspondance avec l’autre table, les valeurs des colonnes valent \nNULL.\n69/89 sql.sh\nSQL SELF JOIN\nEn SQL, un SELF JOIN correspond à une jointure d’une table avec elle-même. Ce type de requête \nn’est pas si commun mais très pratique dans le cas où une table lie des informations avec des \nenregistrements de la même table.\nSyntaxe\nPour effectuer un SELF JOIN, la syntaxe de la requête SQL est la suivante  :\nSELECT `t1`.`nom_colonne1`, `t1`.`nom_colonne2`, `t2`.`nom_colonne1`, \n`t2`.`nom_colonne2`\nFROM `table` as `t1`\nLEFT OUTER JOIN `table` as `t2` ON `t2`.`fk_id` = `t1`.`id`\nIci la jointure est effectuée avec un LEFT JOIN, mais il est aussi possible de l’effectuer avec d’autres \ntypes de jointures.\nExemple\nUn exemple potentiel pourrait être une application d’un intranet d’entreprise qui possède la table des \nemployés avec la hiérarchie entre eux. Les employés peuvent être dirigé par un supérieur direct qui \nse trouve lui-même dans la table.\nTable utilisateur  :\nidprenomnomemail manager_id\n1SebastienMartins.martin@example.com NULL\n2GustaveDuboisg.dubois@example.com NULL\n3GeorgetteLeroyg.leroy@example.com 1\n4GregoryRouxg.roux@example.com 2\nLes enregistrements de la table ci-dessus montre bien des employés. Les premiers employés n’ont \npas de supérieur, tandis que les employés n°3 et n°4 ont respectivement pour supérieur l’employé \nn°1 et l’employé n°2.\nIl est possible de lister sur une même ligne les employés avec leurs supérieurs direct, grâce à une \nrequête telle que celle-ci  :\nSELECT `u1`.`u_id`, `u1`.`u_nom`, `u2`.`u_id`, `u2`.`u_nom`\nFROM `utilisateur` as `u1`\nLEFT OUTER JOIN `utilisateur` as `u2` ON `u2`.`u_manager_id` = `u1`.`u_id`\nRésultat :\n70/89 sql.sh\nu1_idu1_prenomu1_nomu1_email u1_manager_id u2_prenomu2_nom\n1SebastienMartins.martin@example.com NULL NULLNULL\n2GustaveDuboisg.dubois@example.com NULL NULLNULL\n3GeorgetteLeroyg.leroy@example.com 1 SebastienMartin\n4GregoryRouxg.roux@example.com 2 GustaveDubois\n71/89 sql.sh\nSQL NATURAL JOIN\nDans le langage SQL, la commande NATURAL JOIN permet de faire une jointure naturelle entre 2 \ntables. Cette jointure s’effectue à la condition qu’il y ai des colonnes du même nom et de même type \ndans les 2 tables. Le résultat d’une jointure naturelle est la création d’un tableau avec autant de \nlignes qu’il y a de paires correspondant à l’association des colonnes de même nom.\nA noter : puisqu’il faut le même nom de colonne sur les 2 tables, cela empêche d’utiliser certaines \nrègles de nommages pour le nom des colonnes. Il n’est par exemple pas possible de préfixer le nom \ndes colonnes sous peine d’avoir malheureusement 2 nom de colonnes différents.\nSyntaxe\nLa jointure naturelle de 2 tables peut s’effectuer facilement, comme le montre la requête SQL \nsuivante :\nSELECT *\nFROM table1\nNATURAL JOIN table2\nL’avantage d’un NATURAL JOIN c’est qu’il n’y a pas besoin d’utiliser la clause ON.\nExemple\nUne utilisation classique d’une telle jointure pourrait être l’utilisation dans une application qui utilise \nune table utilisateur et une table pays. Si la table utilisateur contient une colonne pour l’identifiant du \npays, il sera possible d’effectuer une jointure naturelle.\nTable « utilisateur »  :\nuser_id user_prenom user_ville pays_id\n1 Jérémie Paris 1\n2 Damien Lyon 2\n3 Sophie Marseille NULL\n4 Yann Lille 9999\n5 Léa Paris 1\nTable « pays » :\npays_id pays_nom\n1 France\n2 Canada\n3 Belgique\n4 Suisse\nPour avoir la liste de tous les utilisateurs avec le pays correspondant, il est possible d’effectuer une \n72/89 sql.sh\nrequête SQL similaire à celle-ci  :\nSELECT *\nFROM utilisateur\nNATURAL JOIN pays\nCette requête retournera le résultat suivant  :\npays_id user_id user_prenom user_ville pays_nom\n1 1 JérémieParis France\n2 2 Damien Lyon Canada\nNULL 3 Sophie Marseille NULL\n9999 4 Yann Lille NULL\n1 5 Léa Paris France\nCet exemple montre qu’il y a bien eu une jointure entre les 2 tables grâce à la colonne « pays_id » \nqui se trouve dans l’une et l’autre des tables.\n73/89 sql.sh\nSQL Sous-requête\nDans le langage SQL une sous-requête (aussi appelé « requête imbriquée » ou « requête en \ncascade ») consiste à exécuter une requête à l’intérieur d’une autre requête. Une requête imbriquée \nest souvent utilisée au sein d’une clause WHERE ou de HAVING pou remplacer une ou plusieurs \nconstante.\nSyntaxe\nIl y a plusieurs façons d’utiliser les sous-requêtes. De cette façon il y a plusieurs syntaxes \nenvisageables pour utiliser des requêtes dans des requêtes.\nRequête imbriquée qui retourne un seul résultat\nL’exemple ci-dessous est une exemple typique d’une sous-requête qui retourne un seul résultat à la \nrequête principale.\nSELECT *\nFROM `table`\nWHERE `nom_colonne` = (\n    SELECT `valeur`\n    FROM `table2`\n    LIMIT 1\n  )\nCet exemple montre une requête interne (celle sur « table2″) qui renvoi une seule valeur. La requête \nexterne quant à elle, va chercher les résultat de « table » et filtre les résultats à partir de la valeur \nretournée par la requête interne.\nA noter : il est possible d’utiliser n’importe quel opérateur d’égalité tel que =, >, <, >=, <= ou <>.\nRequête imbriquée qui retourne une colonne\nUne requête imbriquée peut également retournée une colonne entière. Dès lors, la requête externe \npeut utiliser la commande IN pour filtrer les lignes qui possèdent une des valeurs retournées par la \nrequête interne. L’exemple ci-dessous met en évidence un tel cas de figure  :\nSELECT *\nFROM `table`\nWHERE `nom_colonne` IN (\n    SELECT `colonne`\n    FROM `table2`\n    WHERE `cle_etrangere` = 36\n  )\nExemple\nLa suite de cet article présente des exemples concrets utilisant les sous-requêtes.\n74/89 sql.sh\nImaginons un site web qui permet de poser des questions et d’y répondre. Un tel site possède une \nbase de données avec une table pour les questions et une autre pour les réponses.\nTable « question »  :\nq_idq_date_ajoutq_titre q_contenu\n12013­03­24 \n12:54:32Comment r éparer un\nordinateur?Bonjour, j'ai mon ordinateur de cass é, comment puis­je \nprocéder pour le r éparer?\n22013­03­26 \n19:27:41Comment changer \nun pneu?Quel est la meilleur m éthode pour changer un pneu \nfacilement ?\n32013­04­18 \n20:09:56Que faire si un \nappareil est cass é?Est­il pr éférable de r éparer les appareils  électriques ou \nd'en acheter de nouveaux?\n42013­04­22 \n17:14:27Comment faire \nnettoyer un clavier \nd'ordinateur?Bonjour, sous mon clavier d'ordinateur il y a beaucoup \nde poussi ère, comment faut­il proc éder pour le nettoyer?\nMerci.\nTable « reponse »  :\nr_idr_fk_question_id r_date_ajout r_contenu\n11 2013­03­27 \n07:44:32Bonjour. Pouvez­vous expliquer ce qui ne fonctionne pas \navec votre ordinateur? Merci.\n21 2013­03­28 \n19:27:11Bonsoir, le plus simple consiste  à faire appel  à un \nprofessionnel pour r éparer un ordinateur. Cordialement,\n32 2013­05­09 \n22:10:09Des conseils son disponible sur internet sur ce sujet.\n43 2013­05­24 \n09:47:12Bonjour.  Ça dépend de vous, de votre budget et de vos \npréférence vis­ à­vis de l' écologie. Cordialement,\nRequête imbriquée qui retourne un seul résultat\nAvec une telle application, il est peut-être utile de connaître la question liée à la dernière réponse \najoutée sur l’application. Cela peut être effectué via la requête SQL suivante  :\nSELECT *\nFROM `question`\nWHERE q_id = (\n    SELECT r_fk_question_id\n    FROM `reponse`\n    ORDER BY r_date_ajout DESC\n    LIMIT 1\n  )\nUne telle requête va retourner la ligne suivante  :\nq_idq_date_ajoutq_titre q_contenu\n32013­04­18 \n20:09:56Que faire si un \nappareil est cass é?Est­il pr éférable de r éparer les appareils  électriques ou \nd'en acheter de nouveaux?\n75/89 sql.sh\nCe résultat démontre que la question liée à la dernière réponse sur le forum est bien trouvée à partir \nde ce résultat.\nRequête imbriquée qui retourne une colonne\nImaginons maintenant que l’ont souhaite obtenir les questions liées à toutes les réponses comprises \nentre 2 dates. Ces questions peuvent être récupérée par la requête SQL suivante  :\nSELECT *\nFROM `question`\nWHERE q_id IN (\n    SELECT r_fk_question_id\n    FROM `reponse`\n    WHERE r_date_ajout BETWEEN '2013-01-01' AND '2013-12-31'\n  )\nRésultats :\nq_idq_date_ajoutq_titre q_contenu\n12013­03­24 \n12:54:32Comment r éparer un\nordinateur?Bonjour, j'ai mon ordinateur de cass é, comment puis­je \nprocéder pour le r éparer?\n22013­03­26 \n19:27:41Comment changer \nun pneu?Quel est la meilleur m éthode pour changer un pneu \nfacilement ?\n32013­04­18 \n20:09:56Que faire si un \nappareil est cass é?Est­il pr éférable de r éparer les appareils  électriques ou \nd'en acheter de nouveaux?\nUne telle requête permet donc de récupérer les questions qui ont eu des réponses entre 2 dates. \nC’est pratique dans notre cas pour éviter d’obtenir des réponses qui n’ont pas eu de réponses du tout\nou pas de nouvelles réponses depuis longtemps.\n76/89 sql.sh\nSQL EXISTS\nDans le langage SQL, la commande EXISTS s’utilise dans une clause conditionnelle pour savoir s’il y\na une présence ou non de lignes lors de l’utilisation d’une sous-requête.\nA noter : cette commande n’est pas à confondre avec la clause IN. La commande EXISTS vérifie si \nla sous-requête retourne un résultat ou non, tandis que IN vérifie la concordance d’une à plusieurs \ndonnées.\nSyntaxe\nL’utilisation basique de la commande EXISTS consiste à vérifier si une sous-requête retourne un \nrésultat ou non, en utilisant EXISTS dans la clause conditionnelle. La requête externe s’exécutera \nuniquement si la requête interne retourne au moins un résultat.\nSELECT nom_colonne1\nFROM `table1`\nWHERE EXISTS (\n    SELECT nom_colonne2\n    FROM `table2`\n    WHERE nom_colonne3 = 10\n  )\nDans l’exemple ci-dessus, s’il y a au moins une ligne dans table2 dont nom_colonne3 contient la \nvaleur 10, alors la sous-requête retournera au moins un résultat. Dès lors, la condition sera vérifiée et\nla requête principale retournera les résultats de la colonne nom_colonne1 de table1.\nExemple\nDans le but de montrer un exemple concret d’application, imaginons un système composé d’une \ntable qui contient des commandes et d’une table contenant des produits.\nTable commande  :\nc_id c_date_achat c_produit_id c_quantite_produit\n1 2014­01­08 2 1\n2 2014­01­24 3 2\n3 2014­02­14 8 1\n4 2014­03­23 10 1\nTable produit :\n77/89 sql.sh\np_id p_nom p_date_ajout p_prix\n2 Ordinateur 2013­11­17 799.9\n3 Clavier 2013­11­27 49.9\n4 Souris 2013­12­04 15\n5 Ecran 2013­12­15 250\nIl est possible d’effectuer une requête SQL qui affiche les commandes pour lesquels il y a \neffectivement un produit. Cette requête peut être interprétée de la façon suivante  :\nSELECT *\nFROM commande\nWHERE EXISTS (\n    SELECT * \n    FROM produit \n    WHERE c_produit_id = p_id\n)\nRésultat :\nc_id c_date_achat c_produit_id c_quantite_produit\n1 2014­01­08 2 1\n2 2014­01­24 3 2\nLe résultat démontre bien que seul les commandes n°1 et n°2 ont un produit qui se trouve dans la \ntable produit (cf. la condition c_produit_id = p_id). Cette requête est intéressante sachant qu’elle \nn’influence pas le résultat de la requête principale, contrairement à l’utilisation d’une jointure qui va \nconcaténer les colonnes des 2 tables jointes.\n78/89 sql.sh\nSQL ALL\nDans le langage SQL, la commande ALL permet de comparer une valeur dans l’ensemble de valeurs\nd’une sous-requête. En d’autres mots, cette commande permet de s’assurer qu’une condition est « \négale », « différente », « supérieure », « inférieure », « supérieure ou égale » ou « inférieure ou égale\n» pour tous les résultats retourné par une sous-requête.\nSyntaxe\nCette commande s’utilise dans une clause conditionnelle entre l’opérateur de condition et la sous-\nrequête. L’exemple ci-dessous montre un exemple basique  :\nSELECT *\nFROM table1\nWHERE condition > ALL (\n    SELECT *\n    FROM table2\n    WHERE condition2\n)\nA savoir : les opérateur conditionnels peuvent être les suivants : =, <, >, <>, !=, <=, >=, !> ou !<.\nExemple\nImaginons une requête similaire à la syntaxe de base présentée précédemment  :\nSELECT colonne1\nFROM table1\nWHERE colonne1 > ALL (\n    SELECT colonne1\n    FROM table2\n)\nAvec cette requête, si nous supposons que dans table1 il y a un résultat avec la valeur 10, voici les \ndifférents résultats de la conditions selon le contenu de table2  :\n•La condition est vrai (cf. TRUE) si table2 contient {-5,0,+5} car toutes les valeurs sont \ninférieure à 10\n•La condition est fausse (cf. FALSE) si table2 contient {12,6,NULL,-100} car au moins une \nvaleur est inférieure à 10\n•La condition est non connue (cf. UNKNOW) si table2 est vide\n79/89 sql.sh\nSQL ANY / SOME\nDans le langage SQL, la commande ANY (ou SOME) permet de comparer une valeur avec le résultat\nd’une sous-requête. Il est ainsi possible de vérifier si une valeur est « égale », « différente », « \nsupérieur », « supérieur ou égale », « inférieur » ou « inférieur ou égale » pour au moins une des \nvaleurs de la sous-requête.\nA noter : le mot-clé SOME est un alias de ANY, l’un et l’autre des termes peut être utilisé.\nSyntaxe\nCette commande s’utilise dans une clause conditionnelle juste après un opérateur conditionnel et \njuste avant une sous-requête. L’exemple ci-dessous démontre une utilisation basique de ANY dans \nune requête SQL  :\nSELECT *\nFROM table1\nWHERE condition > ANY (\n    SELECT *\n    FROM table2\n    WHERE condition2\n)\nCette requête peut se traduire de la façon suivante : sélectionner toutes les colonnes de table1, où la\ncondition est supérieure à n’importe quel résultat de la sous-requête.\nA savoir : les opérateur conditionnels peuvent être les suivants  : =, <, >, <>, !=,<=, >=, !> ou !<.\nExemple\nEn se basant sur l’exemple relativement simple présenté ci-dessus, il est possible d’effectuer une \nrequête concrète qui utilise la commande ANY  :\nSELECT colonne1\nFROM table1\nWHERE colonne1 > ANY (\n    SELECT colonne1\n    FROM table2\n)\nSupposons que la table1 possède un seul résultat dans lequel colonne1 est égal à 10.\n•La condition est vrai (cf. TRUE) si table2 contient {21,14,7} car il y a au moins une valeur \ninférieure à 10\n•La condition est fausse (cf. FALSE) si table2 contient {20,10} car aucune valeur est strictement\ninférieure à 10\n•La condition est non connue (cf. UNKNOW) si table2 est vide\n80/89 sql.sh\nAstuce\nLa commande IN est équivalent à l’opérateur = suivi de ANY.\n81/89 sql.sh\nIndex SQL\nEn SQL, les index sont des ressources très utiles qui permettent d’accéder plus rapidement aux \ndonnées. Cette page explique le fonctionnement des index et leurs intérêts pour accroître les \nperformances de lectures des données.\nAnalogie pour comprendre les index en SQL\nUn index, dans le domaine bibliographique, permet de lister les mots-clés importants abordés dans \nun ouvrage et d’indiquer les pages où le mot est mentionné. Ainsi, un lecteur qui recherche une \nthématique spécifique peut se baser sur cet index pour trouver les pages qui abordent le sujet. Ainsi \nun index est une ressource non indispensable, mais c’est un un gain de temps terrible pour \nl’utilisateur qui accède facilement à l’information recherchée.\nIndex en SQL\nUn index, dans une base de données se base sur le même principe qu’un index dans un livre. Avec \nun index placé sur une ou plusieurs colonnes le système d’une base de données peut rechercher les \ndonnées d’abord sur l’index et s’il trouve ce qu’il cherche il saura plus rapidement où se trouve les \nenregistrements concernés.\nCes petites ressources ont toutefois leurs inconvénients car cela occupe de l’espace supplémentaire \ndans la base de données. Par ailleurs, l’insertion de données est plus long car les index sont mis à \njour à chaque fois que des données sont insérées.\nGénéralement un index pourra être utilisé dans les requêtes utilisant les clauses WHERE, GROUP \nBY ou ORDER BY. Lorsqu’une base de données possède un grand nombre d’enregistrements \n(exemple: plusieurs milliers ou plusieurs millions de lignes)  un index permet de gagner un temps \nprécieux pour la lecture de données.\n82/89 sql.sh\nSQL CREATE INDEX\nEn SQL, la commande CREATE INDEX permet de créer un index. L’index est utile pour accélérer \nl’exécution d’une requête SQL qui lit des données et ainsi améliorer les performances d’une \napplication utilisant une base de données.\nSyntaxe\nCréer un index ordinaire\nLa syntaxe basique pour créer un index est la suivante  :\nCREATE INDEX `index_nom` ON `table`;\nIl est également possible de créer un index sur une seule colonne en précisant la colonne sur \nlaquelle doit s’appliquer l’index  :\nCREATE INDEX `index_nom` ON `table` (`colonne1`);\nL’exemple ci-dessus va donc insérer l’index intitulé « index_nom » sur la table nommée « table » \nuniquement sur la colonne « colonne1″. Pour insérer un index sur plusieurs colonnes il est possible \nd’utiliser la syntaxe suivante  :\nCREATE INDEX `index_nom` ON `table` (`colonne1`, `colonne2`);\nL’exemple ci-dessus permet d’insérer un index les 2 colonnes : colonne1 et colonne2.\nCréer un index unique\nUn index unique permet de spécifier qu’une ou plusieurs colonnes doivent contenir des valeurs \nuniques à chaque enregistrement. Le système de base de données retournera une erreur si une \nrequête tente d’insérer des données qui feront doublons sur la clé d’unicité. Pour insérer un tel index \nil suffit d’exécuter une requête SQL respectant la syntaxe suivante  :\nCREATE UNIQUE INDEX `index_nom` ON `table` (`colonne1`);\nDans cet exemple un index unique sera créé sur la colonne nommée colonne1. Cela signifie qu’il ne \npeut pas y avoir plusieurs fois la même valeur sur 2 enregistrements distincts contenus dans cette \ntable.\nIl est également possible de créer un index d’unicité sur 2 colonnes, en respectant la syntaxe \nsuivante :\nCREATE UNIQUE INDEX `index_nom` ON `table` (`colonne1`, `colonne2`);\nConvention de nommage\nIl n’existe pas de convention de nommage spécifique sur le nom des index, juste des suggestions de \nquelques développeurs et administrateurs de bases de données. Voici une liste de suggestions de \npréfixes à utiliser pour nommer un index  :\n83/89 sql.sh\n•Préfixe « PK_ » pour Primary Key (traduction : clé primaire)\n•Préfixe « FK_ » pour Foreign Key (traduction : clé étrangère)\n•Préfixe « UK_ » pour Unique Key (traduction : clé unique)\n•Préfixe « UX_ » pour Unique Index (traduction : index unique)\n•Préfixe « IX_ » pour chaque autre IndeX\n84/89 sql.sh\nSQL EXPLAIN\nDans le langage SQL, l’instruction EXPLAIN est à utiliser juste avant un SELECT et permet d’afficher\nle plan d’exécution d’une requête SQL. Cela permet de savoir de quelle manière le Système de \nGestion de Base de Données (SGBD) va exécuter la requête et s’il va utiliser des index et lesquels.\nEn utilisant cette commande la requête ne renverra pas les résultats du SELECT mais plutôt une \nanalyse de cette requête.\nA noter : le résultat de cette instruction est différent selon les SGBD, tel que MySQL ou PostgreSQL.\nPar ailleurs, le nom de cette instruction diffère pour certains SGBD :\n•MySQL : EXPLAIN\n•PostgreSQL : EXPLAIN\n•Oracle : EXPLAIN PLAN\n•SQLite : EXPLAIN QUERY PLAN\n•SQL Server :\nSET SHOWPLAN_ALL : informations estimées d’une requête SQL, affiché au format textuel \ndétaillé\nSET SHOWPLAN_TEXT : informations estimées d’une requête SQL, affiché au format textuel \nsimple\nSET SHOWPLAN_XML : informations estimées d’une requête SQL, affiché au format XML\nSET STATISTICS PROFILE : statistiques sur l’exécution d’une requête SQL, affiché au format \ntextuel\nSET STATISTICS XML : statistiques sur l’exécution d’une requête SQL, affiché au format XML\n•Firebird : SET PLANONLY ON; puis l’exécution de la requête SQL à analyser\nSyntaxe\nLa syntaxe ci-dessous représente une requête SQL utilisant la commande EXPLAIN pour MySQL ou \nPostgreSQL :\nEXPLAIN SELECT *\nFROM `user`\nORDER BY `id` DESC\nRappel : dans cet exemple, la requête retournera des informations sur le plan d’exécution, mais \nn’affichera pas les « vrai » résultats de la requête.\nExemple\nPour expliquer concrètement le fonctionnement de l’instruction EXPLAIN nous allons prendre une \ntable des fuseaux horaires en PHP. Cette table peut être créé à partir de la requête SQL suivante  :\nCREATE TABLE IF NOT EXISTS `timezones` (\n `timezone_id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n `timezone_groupe_fr` varchar(50) DEFAULT NULL,\n `timezone_groupe_en` varchar(50) DEFAULT NULL,\n `timezone_detail` varchar(100) DEFAULT NULL,\n PRIMARY KEY (`timezone_id`)\n85/89 sql.sh\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=698;\nLa requête ci-dessous permet de mieux comprendre la structure et les index de cette table.\nImaginons que l’ont souhaite compter le nombre de fuseaux horaires par groupe, pour cela il est \npossible d’utiliser la requête SQL suivante :\nSELECT timezone_groupe_fr, COUNT(timezone_detail) AS total_timezone\nFROM `timezones` \nGROUP BY timezone_groupe_fr\nORDER BY timezone_groupe_fr ASC\nAnalyse de la requête SQL\nNous allons voir dans notre exemple comment MySQL va exécuter cette requête. Pour cela, il faut \nutiliser l’instruction EXPLAIN  :\nEXPLAIN SELECT timezone_groupe_fr, COUNT(timezone_detail) AS total_timezone\nFROM `timezones` \nGROUP BY timezone_groupe_fr\nORDER BY timezone_groupe_fr ASC\nLe retour de cette requête SQL est le suivant  :\nRequête SQL avec EXPLAIN sans index\nDans cet exemple on constate les champs suivants  :\n•id : identifiant de SELECT\n•select_type : type de cause SELECT (exemple : SIMPLE, PRIMARY, UNION, DEPENDENT \nUNION, SUBQUERY, DEPENDENT SUBSELECT ou DERIVED)\n•table : table à laquelle la ligne fait référence\n•type : le type de jointure utilisé (exemple : system, const, eq_ref, ref, ref_or_null, \nindex_merge, unique_subquery, index_subquery, range, index ou ALL)\n•possible_keys : liste des index que MySQL pourrait utiliser pour accélérer l’exécution de la \nrequête. Dans notre exemple, aucun index n’est disponible pour accélérer l’exécution de la \nrequête SQL\n•key : cette colonne présente les index que MySQL a décidé d’utiliser pour l’exécution de la \nrequête\n•key_len : indique la taille de la clé qui sera utilisée. S’il n’y a pas de clé, cette colonne renvois \nNULL\n•ref : indique quel colonne (ou constante) sont utilisés avec les lignes de la table\n•rows : estimation du nombre de ligne que MySQL va devoir analyser examiner pour exécuter \nla requête\n•Extra : information additionnelle sur la façon dont MySQL va résoudre la requête. Si cette \ncolonne retourne des résultats, c’est qu’il y a potentiellement des index à utiliser pour \n86/89 sql.sh\n\noptimiser les performances de la requête SQL. Le message « using temporary » permet de \nsavoir que MySQL va devoir créer une table temporaire pour exécuter la requête. Le message\n« using filesort » indique quant à lui que MySQL va devoir faire un autre passage pour \nretourner les lignes dans le bon ordre\nAjout d’un index\nIl est possible d’ajouter un index sur la colonne « timezone_groupe_fr » à la table qui n’en avait pas.\nALTER TABLE `timezones` ADD INDEX ( `timezone_groupe_fr` );\nL’ajout de cet index va changer la façon dont MySQL peut exécuter une requête SQL. En effectuant \nla même requête que tout à l’heure, les résultats seront différent.\nRequête SQL avec EXPLAIN avec index\nDans ce résultat il est possible de constater que MySQL va utiliser un l’index « \nindex_timezone_groupe_fr » et qu’il n’y a plus aucune information complémentaire d’indiquée dans la\ncolonne « Extra ».\n87/89 sql.sh\n\nCommentaires en SQL\nIl peut être intéressant d’insérer des commentaires dans les requêtes SQL pour mieux s’y retrouver \nlorsqu’il y a de grosses requêtes complexes. Il y a plusieurs façon de faire des commentaires dans le\nlangage SQL, qui dépendent notamment du Système de Gestion de Base de Données utilisées \n(SGBD) et de sa version.\nCommentaire double tiret : –\nLe double tiret permet de faire un commentaire jusqu’à la fin de la ligne.\nExemple\nSELECT *    -- tout sélectionner\nFROM table1 -- dans la table \"table1\"\nCompatibilité\n•Depuis la version 3.23.3 de MySQL\n•PostgreSQL\n•Oracle\n•SQLite\nCommentaire dièse : #\nLe symbole dièse permet de faire un commentaire jusqu’à la fin de la ligne.\nExemple\nSELECT *    # tout sélectionner\nFROM table1 # dans la table \"table1\"\nCompatibilité\n•MySQL\nCommentaire multi-ligne : /* et */\nLe commentaire multi-ligne à l’avantage de pouvoir indiquer où commence et où se termine le \ncommentaire. Il est donc possible de l’utiliser en plein milieu d’une requête SQL sans problème.\nExemple\nSELECT *    /* tout sélectionner */\nFROM table1 /* dans la table \"table1\" */\nWHERE 1 = /* exemple en milieu de requete */ 1\nCompatibilité\n•MySQL\n•PostgreSQL\n•Oracle\n88/89 sql.sh\n•SQL Server\n•SQLite\nBug potentiel pour les commentaires sur une ligne\nAttention, dans certains contextes, si vous utilisez un système qui va supprimer les retours à la ligne, \nvotre requête sera uniquement sur une ligne. Dans une telle situation, un commentaire effectué avec \n« – » dans une requête peut donc créer un bug.\nRequête SQL sur plusieurs lignes  :\nSELECT *    -- tout sélectionner\nFROM table1 -- dans la table \"table1\"\nMême requête SQL sur une ligne  :\nSELECT * -- tout sélectionner FROM table1 -- dans la table \"table1\"\nEn conséquent il faut se méfier de librairies externes qui peuvent ré-écrire les requêtes SQL ou alors \ntout simplement se méfier de copier/coller.\n89/89 sql.sh",
  "file_type": "document",
  "original_path": "data/uploads\\cours-sql-sh-.pdf"
}