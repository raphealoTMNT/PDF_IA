{
  "filename": "module_cours SQL.pdf",
  "extraction_date": "2025-09-02T01:16:09.396610",
  "statistics": {
    "word_count": 4877,
    "character_count": 35285,
    "line_count": 1068
  },
  "top_keywords": [
    [
      "trigger",
      61
    ],
    [
      "transaction",
      60
    ],
    [
      "lire",
      31
    ],
    [
      "exécution",
      29
    ],
    [
      "article",
      29
    ],
    [
      "table",
      27
    ],
    [
      "peut",
      26
    ],
    [
      "données",
      26
    ],
    [
      "ecrire",
      25
    ],
    [
      "pour",
      24
    ]
  ],
  "extracted_data": {
    "emails": [],
    "urls": [],
    "dates": [
      "08/12/2009"
    ]
  },
  "content_preview": "08/12/2009\n1\nContrainte d’intégrité\nContrainte d'intégrité statique\n–respectée pour chacun desétats delaBD\n–mécanisme déclaratif\nPRIMARY KEY, UNIQUE, NOT NULL, DOMAIN, FOREIGN KEY, CHECK,\nASSERTION\n–procédural\nTRIGGER (SQL :1999 )‏\nContrainte d'intégrité dynamique\n–contrainte surchangements d'états (unchangement ->unchangement ->etc..)‏\n–référence auxétats successifs delabase\n–TRIGGER\nContrainte colonne\nTypes SQL\nINTEGER\nCHAR\n...\nNOT NULL\nCHECK\nCREATE DOMAIN ( SQL, pas disponible pour Ora...",
  "full_content": "08/12/2009\n1\nContrainte d’intégrité\nContrainte d'intégrité statique\n–respectée pour chacun desétats delaBD\n–mécanisme déclaratif\nPRIMARY KEY, UNIQUE, NOT NULL, DOMAIN, FOREIGN KEY, CHECK,\nASSERTION\n–procédural\nTRIGGER (SQL :1999 )‏\nContrainte d'intégrité dynamique\n–contrainte surchangements d'états (unchangement ->unchangement ->etc..)‏\n–référence auxétats successifs delabase\n–TRIGGER\nContrainte colonne\nTypes SQL\nINTEGER\nCHAR\n...\nNOT NULL\nCHECK\nCREATE DOMAIN ( SQL, pas disponible pour Oracle )‏NOT NULL\nsalaireEmp INTEGER NOT NULL\nPar défaut : NULL autorisé\nCHECK\nDéfinition de domaine pour un attribut\nPar intension (conditions nécessaire et suffisante pour appartenir à \nl’ensemble )\nsalaireEmp INTEGER NOT NULL\nCHECK(salaireEmp > 1200 AND salaireEmp < 10000)\nPar extension ( liste exhaustive des valeurs de l’ensemble )\ncolor CHAR(1)\nCHECK (color IN ('R', 'G', ‘B’))\n5Cléprimaire (PRIMARY KEY) ‏\nColonnes clésprimaires : NOT NULL et Indexées\nIdClient INTEGER PRIMARY KEY\nPRIMARY KEY ( IdClient , idProduit , dateCommande )\n6\n08/12/2009\n2UNIQUE\n-occurrence unique dans la table de chaque valeur de la colonne \n(ou des colonnes)\n-colonne(s) indexée(s)\n-clé candidate\nidEmp INTEGER,\njob VARCHAR( 64),\nidDept INTEGER,\nPRIMARY KEY (idEmp),\nUNIQUE (job,idDept ),\n7Contrainte d'intégrité référentielle (FOREIGN KEY ... REFERENCES ... ) ‏\nCREATE TABLE emp(\n...\nidDeptINTEGER,\nFOREIGN KEY ( idDept) REFERENCES \nDept(idDept),\n...\nidDept de emp fait référence à la cléprimaireidDept de \nla table dept\nLa table dept doit d’abord êtrecréée\n8\nGestion de la contrainte d'intégrité référentielle\nTentative de mise à jour de la cléprimaire\nOptions\nNO ACTION : pas de mot cléOracle , comportement par défaut\nON DELETE CASCADE : Oracle , tout n -uplet référençant la ligne supprimée est\naussi supprimée\nON DELETE SET NULL : Oracle , valeur de l'attribut misà null\nSET DEFAULT : pas disponible surOracle\nON UPDATE \n9\nCREATE TABLE Commande  \n(noCommande  INTEGER   NOT NULL,  \n dateCommande  DATE   NOT NULL,  \n noClient   INTEGER  NOT NULL,  \n PRIMARY KEY (noCommande),  \n FOREIGN KEY (noClient) REFERENCES Client(noClient)  \n) \nDELETE FROM Client WHERE noClient = 10CHECK intra -ligne\nCHECK (age > 18 and  sal> 0) ?\nCHECK ( ( sal+ NVL(prime,0)) > 1500) ?\nPlusieurs colonnes de la même ligne peuvent êtreutilisées\nsimultanément dans unecontrainte CHECK \n10\nCheck inter -ligne d'une même table\nCompare le n -uplet inséré à plusieurs lignes de la table\nCHECK (sal> SELECT MIN(prime) FROM emp))?\nVérifié uniquement pour la ligne touchée\nLa contrainte peut êtreviolée (mise à jour)  \nPas supporté par Oracle\n11CHECK inter -tables\nConcerne plusieurs tables\nCHECK (age >= \n(SELECT ageMinimumEmployé FROM conventionEntreprise\nWHERE année=2008 ) )?\nVérifié uniquement pour la ligne touchée\nLa contrainte peut êtreviolée\nPas supporté par Oracle\n12\n08/12/2009\n3Nom de contrainte (clause CONSTRAINT) ‏\nCONSTRAINT contNoClient\nCHECK(IdClient > 0 AND IdClient < 100000)\nFacilite l'identification de la contrainte non respectée à \nl’exécution\nFacilite la supression , désactivation /activation de \ncontrainte\n13Modification contrainte\n14ALTER TABLE table<constraint_clause >,...\n[{ENABLE|DISABLE} ALL TRIGGERS];\n<constraint_clause >:\nADD CONSTRAINT  ...\nDROP [CONSTRAINT <constraint_name > [CASCADE]] | [PRIMARY KEY|UNIQUE]\n[ENABLE|DISABLE] [CONSTRAINT <constraint_name >\nMODIFY [CONSTRAINT <constraint_name >] |  [PRIMARY KEY|UNIQUE] \n<constrnt_state >\nRENAME CONSTRAINT <constraint_name > TO <constraint_name >\n<constrnt_state >:   \n[[NOT] DEFERRABLE] [INITIALLY {IMMEDIATE|DEFERRED}]\nENABLE|DISABLE ]  [VALIDATE|NOVALIDATE]\nVALIDATE | NOVALIDATE :  vérifié ounon surla table existante\nENABLE NOVALIDATE: vérifié surles nouvelles insertions mais pas surles données existantes\nDEFERRABLE: contrainte déférée , la contrainte n'est vérifiée qu'au moment de la validation des \nmodification (INITIALLY indique le comportement par défaut déférée oupas)‏\nDéclencheur (TRIGGER) ‏\n-Procédure exécutée au niveau serveur\n-BD active\n-Permet le maintien de contraintes d’intégrité\n-statiques : alternatives aux mécanismes déclaratifs type CHECK par exemple , préférer les \nmécanismes déclaratif s'ilestpossible de les utiliser\n-dynamiques\n-Permet le maintien d'éléments dérivés\n-colonne dérivée (contenue d'une colonne calculée à partir d'une ouplusieurs autres colonnes )‏\n-tables dérivée (copie de tables pour base répartie , table d'archivage , ...)‏\n-sécurité (ex: refus de modification), audit des opérations , \n-Généralement , un déclencheur estassocié à un événement surunetable\n-Sous ORACLE, un déclencheur (trigger) peut êtreassocié à pratiquement tout événement de la \nbase (DDL, startup , logon, ...) ‏\nTRIGGER: Procédure déclenchée ‏\n-Utilisé pour spécifier des contraintes plus complexes queles contraintes statiques telles que:\n–Contraintes portant surplusieurs tables\n–Contraintes nécessitant l’utilisation de sous -requêtes\n-Permet d'utiliser des traitement procéduraux : \nécriture de  procédures PL/SQL, JAVA, ...\n-Déclenché par un événement particulier :\n–Le trigger estgénéralement associé à unetable précise ,\n–Il estalors déclenché en réaction à un événement surcette table: INSERT, UPDATE ouDELETE\n–Il estpossible de spécifier des conditions supplémentaires : clause WHEN\n–Possible déclenchement en cascade: un trigger peut déclencher d’autres triggers en cascade\nAttention au cycle de déclencheur : \ntrigger A déclenche trigger B qui déclencher trigger A qui ....\n-Résultat du trigger\nLe trigger se termine correctement s’ilne soulève pas d’exception et siles modifications effectuées\nne violent pas d’autres contraintes (autre triggers oucontraintes statiques )‏\nSi le trigger estinterrompu , toutes les opérations effectuées sont annulées (rollback implicite )‏TRIGGER: Rappel syntaxe\nCREATE [OR REPLACE] TRIGGER nom -trigger    \nBEFORE | AFTER\nINSERT OR UPDATE [OF column] OR DELETE ON nom -table\n[FOR EACH ROW [WHEN (condition)]]\nbloc d’instructions pl/sql\n–INSERT OR UPDATE [OF column] OR DELETE ON nom -table\nprécise le oules événements provoquant l'exécution du trigger \n–BEFORE | AFTER \nspécifie l'exécution de la procédure comme étant avant (BEFORE) ouaprès (AFTER) l’exécution de l’événement\ndéclencheur\nBEFORE : vérification de l'insertion\nAFTER : copie ouarchivage des opérations\n–[FOR EACH ROW ]  \nindique quele trigger estexécuté pour  chaque ligne modifiée /insérée /supprimée\nsicette clause estomis , le trigger estexécuté uneseul foispour chaque commande UPDATE, INSERT, DELETE, \nquelque soitle nombre de lignes modifiées , insérées ousupprimées .\n–[WHEN (condition)]\nconditions optionnelles permettant de restreindre le déclenchement du trigger \n!!! Ne peut contenir de requêtes\n(exemple : WHEN emp.sal > 5000)\n08/12/2009\n4TRIGGER: référence aux attributs des n -uplets modifiés\nDans le code PL/SQL associé à un trigger de niveau ligne, on peut accéder aux valeurs des \nattributs de la ligne modifiée , avant et après la modification:\n=> utilisation des variables : \n–:old ( sauf dans WHEN => old)\n–:new ( sauf dans WHEN => new)\n–Possibilité d'utiliser d'autres noms\n(clause REFERENCING NEW AS nouveauNom\nOLD AS nouveauNom )\n•‏Pour un trigger surINSERT\nles valeurs des attributs du n-uplet inséré sont dans\n:new.<nom attribut >\n•‏Pour un trigger surUPDATE\nles valeurs de l'ancien n-uplet sont dans :old.<nom attribut >\nles valeurs du n-uplet après modification sont dans :new.<nom attribut >\n•‏Pour un trigger surDELETE\nles valeurs des attributs du n-uplet supprimé sont dans\n:old.<nom attribut >  TRIGGER: ligne /instruction\nDéclencheur de ligne (spécifié par FOR EACH ROW),\nExécutés une fois pour chaque ligne affectée par l’événement spécifié .\nPermetd’accéder aux valeurs des lignes affectées avant (:old) et après (:new) l’opération .\nSi le triggers estprécisé comme étant déclenché avant l’événement (before) les valeurs du n -\nuplet peuvent être modifiées avant leur insertion dans la base de données (par ex  \n:new.attribut := :new.attribut + 1).\nIl estpossible de spécifier des conditions de déclenchement (WHEN) pouvant porter sur\nles valeurs des anciens /nouveaux n -uplet\nDéclencheur d’instruction (par défaut )‏\nExécuté une seule fois avant ouaprès la totalité de l’événement , indépendamment du \nnombre de lignes affectés\nRestrictions: ne permet pas d’accéder oude modifier les valeurs des lignes affectées avant ou\naprès l’événement (:old.nomcol et :new.nomcol ) nide spécifier des conditions WHEN\nTRIGGER: remarques\n•   Mutation : tant queles modifications (INSERT, UPDATE ouDELETE) d’une\ntable ne sont pas terminées (modifications totalement terminées et validées ), \ncelle -ciestditeen cours de mutation.\nUn trigger ne peut lire oumodifier une table en cours de mutation .\n=> un trigger AFTER un bloc d’instruction (pas de clause FOR EACH ROW), \npeut modifier la table associée à l’événement déclencheur .\n•   Validation : un déclencheur ne peut niexécuter d’instruction COMMIT ou\nROLLBACK, niappeler de fonction , procédure ousous -programme de package \ninvoquant cesinstructions.TRIGGER: bloc d'instruction\nBloc PL/SQL standard\nDECLARE\nDéclaration de variables et constantes avec leurtype\nBEGIN\nBloc d’instructions PL/SQL\nEND\nLe bloc d’instructions PL/SQL peut contenir :\n–des blocs spécifiant des actions différentes fonction de l’événement déclencheur\n-IF INSERTING THEN bloc d’instructions pl/sqlEND IF\n-IF UPDATING THEN bloc d’instructions pl/sqlEND IF\n-IF DELETING THEN bloc d’instructions pl/sqlEND IF\n–des Instructions SQL \n SELECT, INSERT, UPDATE, DELETE, ... mais pas de COMMIT et ROLLBACK\n–Instructions de contrôle de flux (IF, LOOP, WHILE, FOR) ‏\n–Générer des exceptions\n raise_application_error (code_erreur,message )‏\ncode_erreur compris entre -20000 et -20999 (sinon code d’erreur oracle)\n–Faire appel à des procédures et fonctions PL/SQL\nTRIGGER: Activation / désactivation / suppression\nDésactivation du trigger :\nALTER TRIGGER < nomTrigger > DISABLE ;\nActivation de déclencheur :\nALTER TRIGGER < nomTrigger > ENABLE ;\nSuppression de déclencheur :\nDROP TRIGGER < nomTrigger > ;Exemple TRIGGER : \nmaintien d'une contrainte d'intégrité dynamique\nEmpêcher uneaugmentation du prix d'un circuit de plus de 10% du prix \nactuel\nException Oracle: \nRAISE_APPLICATION_ERROR(code, message) ‏\n-> ROLLBACK implicite\nCREATE TRIGGER circuitRestreindre AugmentationPrix  \nBEFORE UPDATE OF prix Inscription  ON Circuit \nREFERENCING  \n OLD AS row Avant \n NEW AS row Apres \nFOR EACH ROW  \nWHEN(   rowApres.prixInscription  >  \n        rowAvant .prixInscription  *1.1) \nBEGIN \n -- souleverUneExcep tion; \n RAISE_APPLICATION_ERROR( -20200, \n         'Augmentati on prix circuit trop importante ') ; \nEND ; \n \n \n \n \n \n \n \n \n  \n08/12/2009\n5Borner l'augmentation de prix\nModifier la valeur de l’attribut prix‏d’un‏n -uplet\navant son insertion dans la table\nCREATE TRIGGER circuitBornerAugmentationPrix  \nBEFORE UPDATE OF prix Inscription  ON Circuit \nREFERENCING  \n OLD AS row Avant \n NEW AS row Apres \nFOR EACH ROW  \nWHEN( rowApres.prixInscription  >  \n      rowAvant .Inscription *1.1) \nBEGIN \n :rowApres.prixInscription  :=  \n        :rowAvant.prixInscription  * 1.1; \nEND; \n \n \n \n \n \n \n \n \n  Exemple TRIGGER: contrainte d'intégrité statique\nNbPlaceDisponible d'un circuit toujours compris entre \n0 et 100\nCHECK préférable\nCREATE TRIGGER PlaceCircuit Verifier \nBEFORE INSERT OR UPDATE OF nbPlaceDisponible  \n    ON Circuit \nFOR EACH ROW  \nWHEN (:new.nbPlaceDisponible  <=0) OR \n     (:new.nbPlaceDisponible  > 100) \nBEGIN \n -- souleverUneException ; \nEND \nExemple TRIGGER: vérification multi -tables\nLors d'une nouvelle livraison , la quantité à livrer ne peut\ndépasser la quantité en stock disponible\nCREATE TRIGGER verifierQuantit eEnStock \nBEFORE INSERT ON Livraison  \n     FOR EACH ROW  \nDECLARE \n QuantStock_v INTEGER;  \nBEGIN \n SELECT  quantitéEnStock  INTO QuantStock_v  \n FROM  Article \n WHERE  IdArticle =  :new.IdArticle;  \n \n IF (:new .quantiteLivre e > QuantStock_v ) \n -- souleverUneException;  \n END IF ; \nEND Exemple TRIGGER: limitation de modification\nLa relation Livraison contient les attributs idLivraison , idCommande , idArticle et quantiteLivraison\nSécurité : on n'autorise les modifications uniquement surl'attribut quantitelivraison\nToutes les autres modifications provoquent uneexception\nCREATE TRIGGER Emp echerModif Livraison  \nBEFORE UPDATE OF IdLivraison, IdCommande, Id Article  \n       ON Livraison  \nBEGIN \n -- souleverUneException;  \nEND \nExemple trigger: colonnes liées\nLe nombre d’article en stock estajusté en fonction des livraisons reçues /envoyées\nCREATE TRIGGER AI_AjusterQuantitéEnStock  \nAFTER INSERT ON Livraison  \nFOR EACH ROW  \nBEGIN \n UPDATE Article  \n SET quantit eEnStock = quantit eEnStock - \n  :new.quantit eLivree \n WHERE IdArticle =  :new.IdArticle;  \nEND \nCREATE TRIGGER AU _AjusterQuantite Stock \nAFTER UPDATE OF quantite Livree ON Livraison  \nFOR EACH ROW  \nBEGIN \n UPDATE Article  \n SET quantit eEnStock = quantit eEnStock - \n  ( :new.quantit eLivree- :old.quantit eLivree) \n WHERE Id Article =  :old.IdArticle;  \nEND TRIGGER: Ordre d'exécution\nOrdre d’exécution des TRIGGER ?\n-BEFORE avant AFTER,...\n-entre TRIGGER de même type ?\nforcer un ordre en les combinant\nCombiner plusieurs TRIGGER: \n-vérifier quel estl’événement déclencheur\n-pour ORACLE, tester IF INSERTING, DELETING, \nUPDATING\nAttention à l’ordre d’exécution des déclencheurs !!!\n08/12/2009\n6\nExécuter les TRIGGER BEFORE STATEMENT\nPour chaque ligne touchée par l'opération\nExécuter les TRIGGER BEFORE ROW\nExécuter l'opération\nExécuter les TRIGGER AFTER ROW\nFin pour\nExécuter les TRIGGER AFTER STATEMENTTRIGGER: Ordre d'exécution global TRIGGER: limites\n-peuvent être complexes à coder\n-pas de respect de standard:\ncontraintes particulières aux langages de codage\n-pas de mise à jours surla table affectée\nSQL> CREATE OR REPLACE TRIGGER BUArticleBornerAugPrix  \n  2  BEFORE UPDATE OF prixUnitaire ON Article  \n  3  REFERENCING  \n  4        OLD AS ligneAvant  \n  5        NEW AS ligneAprès  \n  6  FOR EACH ROW  \n  7  WHEN ( ligneAprès .prixUnitaire > ligneAvant .prixUnitaire*1. 1) \n  8  BEGIN  \n  9        :ligneAprès .prixUnitaire := :ligneAvant .prixUnitaire*1.1;  \n 10  END;  \n 11  / \n \nDéclencheur créé.  \n \nTRIGGER: exemple de déclenchement\nSQL> -- Test du TRIGGER BUArticleBornerAugPrix  \nSQL> SELECT * FROM Article WHERE Id Article = 10  \n  2  / \n \nIDARTICLE DESCRIPTION          PRIXUNITAIRE QUANTITÉENSTOCK  \n---------  --------------------  ------------  ---------------  \n       10 Boule de cèdre               10,99              10  \n \nSQL> UPDATE   Article \n  2  SET      prixUnitaire = 15.99  \n  3  WHERE  IdArticle = 10  \n  4  /  \n \n1 ligne mise à jour.  \n \nSQL> SELECT * FROM Article WHERE Id Article = 10  \n  2  / \n \nIDARTICLE DESCRIPTION          PRIXUNITAIRE QUANTITÉENSTOCK  \n---------  --------------------  ------------  ---------------  \n       10 Boule de cèdre               12,09              10  \n \nTrigger INSTEAD OF pour Vue non modifiable ‏\nSQL> SELECT * FROM Article WHERE Id Article = 10  \n  2  / \n \n IDARTICLE DESCRIPTION          PRIXUNITAIRE QUANTITÉENSTOCK  \n----------  --------------------  ------------  ---------------  \n        10 Boule de cèdre             10,99              20  \n \nSQL> CREATE VIEW  ArticlePrixPlusTaxe AS  \n  2   SELECT  Id Article, description, prixUnitaire * 1.15 AS prixPlusTaxe  \n  3   FROM  Article  \n  4  / \n \nView created.  \n \nSQL> UPDATE ArticlePrixPlusTaxe  \n  2  SET prixPlusTaxe = 23  \n  3  WHERE Id Article = 10  \n  4  / \nSET prixPlusTaxe = 23  \n    * \nERROR at line 2:  \nORA-01733: virtual column not allowed here  \nSQL> CREATE OR REPLACE TRIGGER InsteadUpdate  \n  2  INSTEAD OF UPDATE ON ArticlePrixPlusTaxe  \n  3  REFERENCING  \n  4   OLD AS ligneAvant  \n  5   NEW AS ligneAprès  \n  6  FOR EACH ROW  \n  7  BEGIN  \n  8   UPDATE Article  \n  9   SET  \n 10    IdArticle = :ligneAprès.Id Article, \n 11   description = :ligneAprès.description,  \n 12    prixUnitaire = :ligneAprès.prixPlusTaxe / 1.15  \n 13   WHERE Id Article = :ligneAvant.noArticle;  \n 14  END;  \n 15  / \n \nTrigger created.  \n \nSQL> UPDATE ArticlePrixPlusTaxe  \n  2  SET prixPlusTaxe = 23  \n  3  WHERE IdArticle = 10  \n  4  / \n \n1 row updated.  \n \nSQL> SELECT * FROM Article WHERE Id Article = 10  \n  2  / \n \n IDARTICLE DESCRIPTION          PRIXUNITAIRE QUANTITÉENSTOCK  \n----------  --------------------  ------------  ---------------  \n        10 Boule de cèdre                20              20  \n08/12/2009\n7\nimport java.sql.*;  \nimport java.io.*;  \npublic class RoutineServeur extends Object {  \n \n  public static int getQuantiteEnStock  (int noArticle) throws SQLException {  \n      // Retourne -1 si l'article n'existe pas  \n      PreparedStatement unEnoncéSQL = null;  \n      int quantitéEnStock = -1; \n      try { \n        Connection uneConnection =  \n          DriverManager.getConnection(\" jdbc:default:connection: \"); \n        unEnoncéSQL = uneConnection.prepareStatement  \n        (\"SELECT quant itéEnStock FROM Article WHERE id Article = ? \"); \n        unEnoncéSQL.setInt(1,no Article);  \n        ResultSet résultatSelect = unEnoncéSQL.executeQuery();  \n        if (résultatSelect.next ()){  \n           quantitéEnStock = résultatSelect.getInt(1);  \n        } \n      } \n      catch (SQLException e) {Syst em.err.println(e.getMessage());}  \n      finally{unEnoncéSQL.close();}  \n      return quantitéEnStock;  \n  } \n \n  public static void setQuantiteEnStock  (int noArticle, int quantitéEnStock) throws \nSQLException {  \n      PreparedStatement unEnoncéSQL = null;  \n      try { \n        Connection uneConnection =  \n          DriverManager.getConnection(\" jdbc:default:connection: \"); \n        unEnoncéSQL = uneConnection.prepareStatement  \n        (\"UPDATE Article SET quantitéEnStock = ? WHERE id Article = ? \");  \n        unEnoncéSQL.setIn t(1,quantitéEnStock);  \n        unEnoncéSQL.setInt(2,no Article);  \n        unEnoncéSQL.executeUpdate();  \n      } \n      catch (SQLException e) {System.err.println(e.getMessage());}  \n      finally{unEnoncéSQL.close();}  \n  } \n} Procédures stokées en Java\nCharger le code dans la base:\nPublier sous forme de routine stockée :\nAppeler la fonction en SQL:\nPossibilité de définir un déclencheur utilisant uneprocédure /fonction écrit\nen Java\nloadjava -user Scott/Tiger RoutineServeur.class  \nSQL> CREATE OR REPLACE FUNCTION getQuantiteEnStock(noArticle NUMBER)\n  2  RETURN NUMBER\n  3  AS LANGUAGE JAVA\n  4  NAME ' RoutineServeur.getQuantiteEnStock (int) return int';\n  5  /\nFunction created.\nSQL> select getQuantiteEnStock(10) from dual ;\nGETQUANTITEENSTOCK(10)\n----------------------\n                    20Déploiement Oracle\nArchitecture des Application Web\nNiveau Logique (architecture trois tier) \nCouche Présentation\nCouche Métier /Application\nCouche Accès aux données\nNiveau Physique \nClient\nServeur Web\nServeur d'application\nServeur de données\nCouche PrésentationArchitecture trois tier\nCouche Métier\nCouche donnée persistanteAutorise l'utilisateur final à interagir avec \nl'application\nEffectue les calculs (partie fonctionnelle de \nl'application) ‏\nIntégration des systèmes\nConservation des données\nDonnées utilisées pour générer la présentation\nDonnées collectées par l'applicationPartie visible de l'application (ex: page \nHTML), contenu misà disposition du client3 -Tier architecture\nPHP script\nServeur Web \n(Apache, IIS) ‏Browser\n(IE, FireFox , \nOpera)‏\nBureau \n(PC or MAC) ‏Base de données\nServeur Base de \ndonnées\n(Oracle, PostGres , \nmySQL , ...)‏SQL\nHTTP \nHTMLDonnées\nCouche Présentation Couche Application Couche donnéesCouche Présentation \n08/12/2009\n8<!DOCTYPE HTML PUBLIC \" -//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n<body>\n<h1>Region list</h 1>\n<?php\n$link = pg_Connect (\"host=localhost user=login dbname=login\");\n$result = pg_query (\"SELECT * FROM regions \", $link) or \ndie(\"ERROR: Request failed \");\nif (pg_numrows ($result) == 0)‏\nprint(\"<h2>Sorry, no region, db is empty.</h 2><br>\");\nelse\nwhile ($row = pg_fetch_array ($result)) ‏\n{\nprint(\"<a href=\\\"BrowseCategories.php?region =\".\n$row[\"id\"].\" \\\">\".$row[\"name\"].\" </a><br>\\n\"); }\npg_free_result ($result);\npg_close ($link);\n?>\n</body>\n</html>Exemple PHP\nConcurrence des accès\nun SGBD est multi -utilisateurs\nune même donnée peut être manipulée par \nplusieurs utilisateurs à la fois\nproblèmes d'accès concurrents (perte de mise \nà jour, lecture incohérente, …)\ncomment garantir la cohérence des données ?\ncontraintes de temps réel\n45Transaction\nUne transaction estune séquence d'opérations\nquiaccèdent oumodifient lecontenu d'une base\ndedonnées .\nGranularité desopérations delecture/modification de\nlabase :table, n-uplet ,donnée, …\nUne transaction permet depasser d’un état\ncohérent delabase àunautre étatcohérent\nDurant la transaction\nPossible état incohérentDébut de la transaction\nEtat cohérent de la BDFin de la transaction\nEtat cohérent de la BD\n46\nTransaction\nUne transaction peut êtrevalidée ouannulée\nLedébut d'une transaction peut être implicite ou\nexplicite\nLafind'une transaction peut être implicite ou\nexplicite\nContraintes sur les transactions:\nVitesse d’exécution\nSécurité\n47Transaction\nCommandes de transaction\nDébut de transaction implicite\nDébut d’une session\nUn début de transaction explicite est définie par :\nCOMMIT (fin de la transaction précédente)\nBEGIN_TRANSACTION (SQL standard, pas Oracle)\nUne fin explicite est définie par :\nROLLBACK (annulation) \nCOMMIT (validation)\nUne finimplicite estdéfinie par:\nExécution d'une commande du langage de définition de données\nFin d’une session\n48\n08/12/2009\n9Exemple de transaction\n--livraison de 10 exemplaires du produit 113\n--les stocks sont mis à jour\nCOMMIT;\nINSERT INTO \nlivraison (idProduit , quantité, idClient )\nVALUES (113, 12, 1125); \nUPDATE produit SET quantité=quantité -12 \nWHERE idProduit = 113;\nCOMMIT COMMENT ‘Virement effectué’; --Ou ROLLBACK \n49Transaction : propriétés ACID\nAtomicité :Une transaction estindivisible .Elle est\nsoit complètement exécutée soit pas dutout (unité\natomique detraitement)\nCohérence :une transaction doit effectuer une\ntransition d’un état cohérent delabase àunautre état\ncohérent (par ex:pas deviolation decontrainte\nd’intégrité) .Lacohérence peut être non respectée\npendant l'exécution d'une transaction .Encasd’échec\ndelatransaction, labase doit retourner dans l’état\ncohérent initial\n50\nTransaction : propriétés ACID\nIsolation : le résultat d’un ensemble de \ntransactions concurrentes et validées correspond à \nune exécution successive des mêmes transactions \n(pas d’inférence entre les transactions)\nDurabilité : après la fin d'une transaction, les mises \nà jour sont définitives même en cas de problèmes \nmatériels (mécanisme de reprise en cas de panne) \n51Etats des données avant COMMIT ouROLLBACK\nComportement standard:\nL’état précédent de la base peut êtrerécupéré ,\nL’utilisateur courant peut voirle résultat de sesmises à \njour de données ,\nLes autres utilisateurs ne peuvent généralement pas voir\nles mises à jour effectuées par l’utilisateur courant,\nCertaines données peuvent êtreverrouillées ,\nLes autres utilisateurs ne peuvent modifier les données\nverrouillées .\n52\nEtat après le COMMIT\nLes modifications de la base sont permanentes ,\nL’etat précédent de la base estdéfinitivement perdu ,\nTous les utilisateurs peuvent voirle résultat des \nopérations de DML,\nLes verrous sont relachés ,\nTous les points de sauvegarde sont effacés .\n53Transaction\nValidation detransaction partielle\nOnpeut découper unetransaction encréant despoints\nd'arrêts (savepoint ).\nSAVEPOINT S 1;\nCes points d'arrêts permettent d’annuler seulement\nunepartie delatransaction .Lacommande ROLLBACK\npermet deretourner àunpoint d’arrêts :\nROLLBACK TO S 1;\n54\n08/12/2009\n10Contrôle de la concurrence\nObjectif: synchroniser les transactions concurrentes de façon \nà maintenir la cohérence de la BD tout en minimisant les \nrestrictions d’accès.\nPrincipes:\nExécution simultanée des transactions\nOpération 1 de la transaction T 1, opération 1 de la transaction \nT2, opération 2 de la transaction T 1, …\npermet d’améliorer la performance du SGBD\nL’exécution simultanée de transactions concurrentes doit \nêtre équivalent à une exécution non simultanée (propriété \nIsolation)\n55Contrôle de la concurrence\nOpérations élémentaires d’accès à la base de données\nLire(X)\nLit la granule X, qui sera généralement stockée dans \nune variable (par convention la variable sera aussi \nnommée X)\nEcrire (X)\nEcrit la valeur de la variable X dans la granule X\n56\nExemple de transactions concurrentes\nTransaction T 1\nLire(X);\nX = X –500;\nEcrire(X);\nLire(Y);\nY = Y + 500;\nEcrire(Y);\nAccède aux granules X et Y\n57Transaction T2\nLire(X);\nX = X + 1000;\nEcrire(X);\nAccède à la granule XExemple d’exécution simultanée\nTransaction T 1\nLire(X);\nX = X –500;\nEcrire(X);\nLire(Y);\nY = Y + 500;\nEcrire(Y);\n58Transaction T 2\nLire(X);\nX = X + 1000;\nEcrire(X);X = 2000\nY = 0\nX = 2500\nY = 500\nContrôle de concurrence\nTransaction T 1\nLire(X);\nX = X –500;\nEcrire(X);\nLire(Y);\nY = Y + 500;\nEcrire(Y);\n59Transaction T 2\nLire(X);\nX = X + 1000;\nEcrire(X);La mise à jour de la granule X \npar la transaction T 1 est perdueNécessité de contrôler les transaction pour éviter les \nincohérence: ici perte de mise à jour X = 2000\nY = 0\nX = 3000\nY = 500Introduction d’incohérence\nTransaction T 1\nLire(X);\nX = 2 * X;\nEcrire(X);\nLire(Y);\nY = 2 * Y;\nEcrire(Y);\n60Transaction T 2\nLire(X);\nX = X + 1;\nEcrire(X);\nLire(Y);\nY = Y + 1;\nEcrire(Y);Contrainte:   X = YX = 100\nY = 100\nX = Y\nX = 201\nY = 202\nX != Y\n08/12/2009\n11Mise à jour temporaire ( dirty read )\nTransaction T 1\nLire(X);\nX = X + 500;\nEcrire(X);\nROLLBACK;\n61Transaction T 2\nLire(X);\nX = X + 1000;\nEcrire(X);T2 a lu une valeur temporaire \nde X et s’en est servi pour \neffectuer une mise à jourLecture non répétable\nTransaction T 1\nLire(X);\nX = X –500;\nEcrire(Y);\nCOMMIT;\n62Transaction T 2\nS = 0;\nLire(X);\nS= S + X;\nLire(X);\nS = S + X;\nLa valeur de X lu par T 2 à la fin \nde la transaction n’est pas la \nmême que celle lu au début (elle \npeut même avoir été supprimée)\nLecture fantôme\nTransaction T 1\nINSERT INTO P 1 VALUES ( 500000); \n63Transaction T 2\nS = 0;\nLire(X); // Select max(X) fromP1;\nS = S + X;\nLe contenu de la table P1 a été \nmodifié. La valeur précédemment \nlue n’est plus le maximum de la \nvaleur X de la table P1Degrés d’isolation SQL -92\nOn peut préciser si l’on souhaite éviter ou non les cas suivants:\nLecture sale : Une transaction lit des données écrites par une \ntransaction concurrente mais non validée\nLecture non reproductible : Une transaction lit de nouveau des \ndonnées qu’elle a lues précédemment et trouve que les données \nont été modifiées par une autre transaction (qui a validé depuis \nla lecture initiale)\nLecture fantôme : Une transaction ré -exécute une requête \nrenvoyant un ensemble de lignes satisfaisant une condition de \nrecherche et trouve que l’ensemble des lignes satisfaisant la \ncondition a changé à cause d’une transaction récemment validée\n64\nExécution\nExécution: ordonnancement des opérations d’un ensemble de transaction\nExemple : \n3  transactions  T1,  T2, et T3\n3  granules  X, Yet Z\nT1: Lire(X),  Ecrire(X)\nT2: Ecrire(X), Ecrire(Y), Ecrire(Z)\nT3: Lire(X), Lire(Y), Lire(Z)\nExemple d’exécution:\nK = E2(X), L1(X), L3(X), E1(X), E2(Y), L3(Y), E2(Z), L3(Z)\n65Exécution en série\nExécution sérielle: exécution sans entrelacement \nd’opérations de différentes transactions. Equivalent à une \nexécution successive par un unique utilisateur des \ndifférentes transactions.\nExemple:\nK = L1(X), E1(X), E2(X), E2(Y), E2(Z),  L3(X), L3(Y), L3(Z)\n66T1 T2 T3\n08/12/2009\n12Exécutions correctement synchronisées\nDeux exécutions sont équivalentes sielles ontles \nmêmes transactions, l’ordre des opérations des \ntransactions estle même et qu’elles produisent les \nmêmes effets surla base\nSérialisabilité\nLes exécutions concurrentes sont correctes siet \nseulement sileur résultat estéquivalent à celui d'une\nexécution sérielle (non simultanée )\nCritères couramment accepté (casparticulier les bases de \ndonnées distribués )\n67Exécutions équivalentes\nT1: Lire(X),   Ecrire(X)\nT2: Ecrire(X), Ecrire(Y), Ecrire(Z)\nT3: Lire(X),   Lire(Y),   Lire(Z)\nK1= E2(X), L1(X), L3(X), E1(X), E2(Y), L3(Y), E2(Z), L3(Z) \nK2= E2(X), L3(X), L1(X), E1(X), E2(Y), L3(Y), E2(Z), L3(Z) \nK3= E2(X), L1(X), L3(X), E1(X), L3(Y), E2(Y), E2(Z), L3(Z) \nK1et K2sont 2 exécutions équivalentes.\nK2et K3ne sont pas équivalentes.\nKs= E2(X), E2(Y), E2(Z), L3(X), L3(Y), L3(Z), L1(X), E1(X) \n= T2, T3, T1\nK1et K2sont équivalent à Ksqui est une exécution en série. K1et K2sont sérialisable .\n68\nGraphe de précédence\nLe graphe (orienté) de précédence Gk= {S,A} pour une \nexécution K est défini tel que :\nS = ensemble des transactions de l’exécution K\nIl existe un arc entre ( Ti,Tj) si\nTilit/écrit la granule X avant une écriture dans X de Tj\nTiécrit une granule X avant une lecture de X de Tj\nOn dit que Tiprécéde Tj\n69Graphe de précédence\nK2 = E2(X), L3(X), L1(X), E1(X), E2(Y), L3(Y), E2(Z), L3(Z) \nK3 = E2(X), L1(X), L3(X),E1(X),L3(Y), E2(Y),E2(Z), L3(Z) \n70T1 T2\nT3x\nxxYZT1 T2\nT3xxYZx\nGraphe de précédence de K2 Graphe de précédence de K3\nOn‏peut‏prouver‏qu’une‏exécution‏est‏ sérialisable si et seulement si \nle graphe de précédence ne contient aucun cycle.\nK3contient‏un‏cycle,‏donc‏l’exécution‏n’est‏pas‏ sérialisable .\nDegrés d'isolation\nSérialisabilité totale coûte cher\nElle n'est pas nécessaires pour toutes transactions\nLes SGBD et SQL -92 offrent dèslorsdifférents niveaux\nd'isolation de transactions\nà utiliser avec des précautions\n71\nIsolation \nLevel\nDirty \nRead\nNonrepeatable \nRead\nPhantom \nRead\nRead \nuncommitted\nY\n Y\n Y\nRead committed\n N\n Y\n Y\nRepeatable read\n N\n N\n Y\nSerializable\n N\n N\n NDegrés d’isolation SQL -92\n08/12/2009\n13Oracle isolation levels\nRead committed\n Chaque requête ne voitqueles données\nvalidées (isolation level d’Oracle par \ndéfaut )\nSerializable\n Voitles données tellesqu’elles étaient au \ndébut de la transaction. Une transaction \nvoitaussi sespropres modifications.\nRead -only\n La transaction voitles données telles\nqu’elles étaient au début de la transaction. \nToutes commandes DML estinterdites .Commande SQL (Oracle):\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED; \nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE; \nSET TRANSACTION READ ONLY;Oracle isolation levels\nContrôle de concurrence\nLe contrôle de concurrence permet de s’assurer que seul des \nexécutions sérialisables soient générées.\n2 types de techniques existent pour garantir la sérialisation des \nopérations:\n-Techniques optimistes: détection des conflits et annulation de leur \neffet si possible (permutation d’opérations). Sinon annulation de \ntransactions.\nValable uniquement si les conflits sont rares. Il est alors acceptable \nde réexécuter occasionnellement certaines transactions.\n-Techniques pessimiste: empêcher l’apparition des conflits de mise \nà jour en verrouillant les objets de la base.\nOn suppose dans ce cas que les conflits sont fréquents et qu’il faut \nles traiter le plus rapidement possible.\n75Contrôle de concurrence\nLes techniques de contrôle de concurrence pessimistes \nsont les plus souvent utilisées.\nElles consistent à poser des verrous sur les objets de la \nbase.\n76\nVerrou\nUnverrou estune variable d'état associée àunobjet Xde\nlabase etindiquant son état visàvisdesopérations de\nlecture/écriture\nVerrou binaire:\n2 états :\nverrouillé (pose de verrou): l’accès à un objet est bloqué dès qu’il est lu ou écrit par une \ntransaction \nlibre:  le verrou sur un objet est libéré à la fin de la transaction\nVerrou ternaire :\n3 états :\nverrou partagé (\" shared lock\"): plusieurs transactions peuvent lire l’objet \nverrou exclusif (\"exclusive lock\"): réserve l’objet en écriture pour la transaction qui pose ce \nverrou\nlibre. \n77Un verrou peut toujours être posé sur une donnée non \nverrouillée, la donnée est alors verrouillée\nPlusieurs verrous en lecture peuvent être posés sur une \ndonnée déjà verrouillée en lecture\nSi une donnée est verrouillée en écriture, aucun autre \nverrou ne peut être posé tant que ce verrou n’a pas été \nsupprimé\nDeux verrous sont dits compatibles si deux transactions qui \naccèdent à la même donnée peuvent obtenir les verrous sur \ncette donnée au même moment.\n08/12/2009\n14Verrouillage de ressources\nUn verrou peut intervenir à différents niveau de la base:\nsur la base données,\nsur les tables,\nsur les n -uplets ,\nsur les données.\n79Verrouillage à deux phases \nChaque transaction verrouille l’objet avant de l’utiliser\nQuand une demande de verrou est en conflit avec un \nverrou posé par une autre transaction en cours, la \ntransaction qui demande doit attendre\nQuand une transaction libère son premier verrou, elle \nne peut plus demander d’autres verrous\nToute exécution obtenue par un verrouillage à deux \nphases est sérialisable\n80\nProblème avec le verrouillage: interblocage\nVerrou mortel\n81T1T2\nT3Résolution du verrou mortel\nPrévention\ndéfinir des critères de priorité de sorte à ce que le \nproblème ne se pose pas\nexemple : priorité aux transactions les plus anciennes\nDétection\ngérer le graphe des attentes\nlancer un algorithme de détection de circuits dès qu’une \ntransaction attend trop longtemps\nchoisir une victime qui brise le circuit\nAméliorations du verrouillage\nRelâchement des verrous en lecture après opération\n-non garantie de la reproductibilité des lectures\n+ verrous conservés moins longtemps\nAccès à la version précédente lors d'une lecture \nbloquante\n-nécessité de conserver une version (journaux)\n+ une lecture n'est jamais bloquanteOracle durée des verrous\nTous les verrous acquis durant unetransaction reste actif\ntous le temp de la transaction.\nLes verrous sont relachés lorsd’un commit ourollback\n84\n08/12/2009\n15Oracle DML Locks\nLes opérations de manipulation de données peuvent\nacquerir un verrou à deux niveaux : ligne outable.\n85Table Locks\nRS: row share\nLes autres transactions peuvent\nmodifier la table mais pas la verrouiller\nen mode exclusif\nRX: row exclusive\nComme row share mais la table ne peut\npas êtreverrouiller en share\nS: share\nAccès concurrents autorisés surla table \nmais pas les modifications\nSRX: share row exclusive\nLes accès sont autorisés surla table mais\npas les modifications oude la verrouiller\nen share\nX: exclusive\nSeuls les accès à la table sont autorisés\n* Attends siuneautre transaction a déjà \nposé le verrou\nOrdonnancement par estampillage\nOn affecte \nà chaque transaction t une estampille unique TS(t) dans un \ndomaine ordonné.\nà chaque granule g \nune étiquette de lecture EL(g)\nune étiquette d’écriture EE(g)\nqui contient l’estampille de la dernière transaction la plus \njeune (max(TS(t))) qui a lu (respectivement) écrit g.Ordonnancement par estampillage\nLa transaction t veut lire g :\nSi TS(t) ≥EE(g),la lecture est acceptée  et \nEL(g) := max(EL(g), TS(t))\nSinon la lecture est refusée et T est relancée avec une nouvelle \nestampille (plus grande que tous les autres)\nLa transaction t veut écrire g :\nSi TS(t) ≥max(EE(g), EL(g)),l’écriture est acceptée et \nEE(g) := TS(t)\nSinon l’écriture est refusée et T est relancée avec une nouvelle \nestampille (plus grande que tous les autres).\n88\nBilan Estampillage\nApproche optimiste\ncoût assez faible\ndétecte et guérit les problèmes\nGuérison difficile\ncatastrophique en cas de nombreux \nconflits\ngère mal les pics d’accès",
  "file_type": "document",
  "original_path": "data/uploads\\module_cours SQL.pdf"
}