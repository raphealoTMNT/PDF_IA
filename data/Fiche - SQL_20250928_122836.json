{
  "filename": "Fiche - SQL.pdf",
  "extraction_date": "2025-09-28T12:28:36.742914",
  "statistics": {
    "word_count": 3005,
    "character_count": 18563,
    "line_count": 386
  },
  "top_keywords": [
    [
      "produit",
      41
    ],
    [
      "champ1",
      30
    ],
    [
      "dans",
      28
    ],
    [
      "where",
      24
    ],
    [
      "lignes",
      24
    ],
    [
      "select",
      19
    ],
    [
      "requête",
      19
    ],
    [
      "category",
      19
    ],
    [
      "requêtes",
      18
    ],
    [
      "from",
      17
    ]
  ],
  "extracted_data": {
    "emails": [],
    "urls": [],
    "dates": [
      "01/12/2015"
    ]
  },
  "content_preview": "BTS CGO 2A  P10 - Organisation du Système d’Information s Fiche SQL  \n \n \n1/6 Rédigé par  : Jimmy Paquereau  \n \nFiche de révision s - SQL \n \n \n \n1. Les clauses SQL  \n \nLes mots -clefs SELECT , FROM , WHERE , GROUP  BY, HAVING  et ORDER  BY sont appelés des clauses . \n \nImportant  ! Dans tout ce qui suit, n’oubliez pas de préfixer les champs par le nom de la table ( exemple  : \nNomTable.NomChamp) lorsqu’il y a ambiguïté, à savoir lorsque votre requête conduit à la présence de deux \nchamps portant...",
  "full_content": "BTS CGO 2A  P10 - Organisation du Système d’Information s Fiche SQL  \n \n \n1/6 Rédigé par  : Jimmy Paquereau  \n \nFiche de révision s - SQL \n \n \n \n1. Les clauses SQL  \n \nLes mots -clefs SELECT , FROM , WHERE , GROUP  BY, HAVING  et ORDER  BY sont appelés des clauses . \n \nImportant  ! Dans tout ce qui suit, n’oubliez pas de préfixer les champs par le nom de la table ( exemple  : \nNomTable.NomChamp) lorsqu’il y a ambiguïté, à savoir lorsque votre requête conduit à la présence de deux \nchamps portant le même nom.  \n \n \nSELECT *   \nPermet d’affiche r tous les champs disponibles de toutes les tables «  sélectionnées  »  \n \nSELECT champ1, champ2, …,champN   \nSELECT champ1 AS Alias1, champ2 AS Alias2, …,champN  AS AliasN  \nPermet d’afficher 1 ou plusieurs champs parmi les champs disponibles.  \n \n \n \nFROM UneTable1, UneTable2, …, UneTableN  \nFROM UneTable1  AS Alias1 , UneTable2  AS Alias2 , …, UneTableN  AS AliasN  \nPermet de préciser les tables à utiliser.  \n \n \n \nWHERE Conditions  \nPermet de préciser les lignes à conserver ou retirées de la «  sélection  » (de la projection). Les conditions sont des \nexpressions booléennes (voir fiche sur l’algorithmique) portant sur les champs  (les colonnes) des lignes.  On parle de \nrestriction . \n \n \n \nGROUP BY UneTable. champ1, UneTable. champ2 , UneTable.champN  \nPermet de regrouper des lignes les unes avec les autres.  \n1ère remarque  : conséquence, il est impossible de regrouper deux lignes selon une colonne champX  si ces deux lignes \nn’ont pas la même valeur dans la colonne champX  (à méditer  !).  \n2ème remarque  : GROUP BY s’utilise avec des agrégats , i.e. des fonctions effectuant un calcul sur chaque groupe de \nlignes  : COUNT(*), COUNT(unChamp), COUNT(DISTINCT unCham), AVG(unChamp), SUM(unCham). Par exemple, \nCOUNT(*) , pour chaque groupe, le nombre de lignes regr oupées.  \n3ème remarque  : en règle générale, les champs (hors agrégats) figurant dans la clause SELECT doivent figurer dans la \nclause GROUP BY.  \n \n \n \nGROUP BY UneTable. champ1, UneTable. champ2 , UneTable.champN  \nPermet de regrouper des lignes les unes avec les autres.  \n1ère remarque  : conséquence, il est impossible de regrouper deux lignes selon une colonne champX  si ces deux lignes \nn’ont pas la même valeur dans la colonne champX  (à méditer  !).  \n2ème remarque  : GRO UP BY s’utilise avec des agrégats , i.e. des fonctions effectuant un calcul sur chaque groupe de \nlignes  : COUNT(*) , COUNT(unChamp) , COUNT(DISTINCT unCham) , AVG(unChamp) , SUM(unCham p), MIN(unChamp) , \nMAX(unChamp) . Par exemple, COUNT(*) ,  pour chaque groupe, le nombre de lignes regroupées.  \n3ème remarque  : en règle générale, les champs (hors agrégats) figurant dans la clause SELECT doivent figurer dans la \nclause GROUP BY.  \n4ème remarque  : une fois la clause GROUP BY exécutée, à un regroupeme nt correspond une unique ligne. Autrement dit, \ngars à ne pas mettre n’importe quoi dans la clause HAVING. Les champs ne figurant pas dans la clause SELECT ne \npeuvent en règle général e plus être utilisés tels quels.  \n \n \n \nBTS CGO 2A  P10 - Organisation du Système d’Information s Fiche SQL  \n \n \n2/6  \nHAVING conditions  \nPermet d’effectuer une restriction à la manière d’un WHERE, mais une fois la clause GROUP BY exécutée.  \n1ère remarque  : les conditions  figurant dans la clause HAVING  portent en générales sur les agrégats.  N’hésitez pas à \nutiliser l’alias précisé dans la clause SELECT (si vous en avez précisé un bien sûr).   \nExemple  : COUNT(*) > 5.  \n2ème remarque  : il est absolument hors de question de voir apparaître des conditions comportant des agrégats dans la \nclause WHER E ! En effet, c’est impossible, lorsque le WHERE est exécuté, les agrégats n’ont pas encore été calculés, la \nclause GROUP BY s’exécutant après la clause WHERE.  \n  \n \n \nORDER BY champ1,  champ2 ASC, champ3 DESC, …  \nPermet de trier les lignes (résultat de la requête) en fonction des champs. Le ASC ( ascendant )  permet de trier par ordre \ncroissant, DESC ( descendant ) par ordre décroissant. Ne rien mettre équivaut à trier par ordre croissant (ASC).  \n  \n \n \nLIMIT nombreLignes OFFSET premiereLigne  \nPermet de ne retourner  qu’une partie des lignes, à savoir permet de retourner «  nombreLignes  » lignes à partir de la \nligne «  premiereLigne  ». Attention  ! La première ligne est la ligne 0.  \n  \n \n2. Opérateurs et fonctions  \n \nLes opérateurs et fonctions sont volontiers utili sés dans la clause WHERE (mais pas nécessairement).  \n \nLes opérateurs logique s (attention au priorité de calcul, voir fiche algorithmiques)  : \nCondition1 AND  Condition2  \nCondition1 OR Condition2  \nNOT  Condition1      \n \nLes opérateurs de comparaison  (non exhaustif)  : \nChamp1 = Champ2  \nChamp1 <> Champ2    Notation SQL de ≠ (différent de)  \nChamp1 > Champ2  et   Respectivement <  \nChamp1 >= Champ2   Respectivement <=  \nChamp1 IS NULL  et Champ IS NOT  NULL          Teste si la valeur du champ est nulle  (resp. non nul le) \nChamp1 LIKE  ‘’CH%’’   Champ1 LIKE  ‘’%CHE’’       Teste si la valeur du champ commence par ‘’CH’’ (resp. se termine par ‘’CHE’’)  \nChamp1 BETWEEN  … AND  … \nChamp1 BETWEEN  #JJ/MM/AAAA# AND #JJ/MM/AAAA#   Si Champ1 est une date  \nChamp1 IN (‘’Valeur1’’, ‘’Valeur2’’, …)          Teste si Champ1 est égal à l’une des valeurs dans la liste  \nChamp1 IN ( SELECT  … FROM  … WHERE  … )       Idem, mais la liste est retournée par une requête  \n \nLes fonctions  (non exhaustif, propre à chaque SGBD)  : \nYEAR( Champ1)     Retourne l’année correspondant à la date Champ1  \nMONTH(Champ1)   Retourne l’année correspondant à la date Champ1  \nDAY(Champ1), MINUTE(Champ1), HOUR(Champ1), SECOND(Champ1)  \nNOW ou NOW()   Retourne la date courante (date actuelle, aujourd’hui)  \n \nLes fonctions SQL, multiples en pratique (voire, on peut en créer), peuvent très bien être utilisées dans la \nclause WHERE avec les opérateurs de comparaison usuel =, >=, BETWEEN…  \nExemple  : YEAR(Champ1) BETWEEN 2010 AND 2016).  \n \n3. Sous -requêtes  \n \nRien de très original, une sous -requête est une requête dans une requête. Dès que l’on utilise des sous -\nrequêtes, il est vivement conseillé d’utiliser des ALIAS dès que requête et sous -requêtes utilisent les mêmes \ntables, voire s’utilisent mutuellement.   \n \nBTS CGO 2A  P10 - Organisation du Système d’Information s Fiche SQL  \n \n \n3/6 Dans nomb re de cas, on peut éviter les sous -requêtes. On les utilise essentiellement pour récupérer des \nstatistiques.  \n \nExemple  : je veux récupérer la moyenne générale , au semestre 1 de cette année , des élèves de la classe n°7. Il \nme faut calculer la moyenne général e de chaque élève (sous -requête) puis calculer la moyenne de ces \nmoyennes (à méditer). Cela pourrait donner une requête s’apparentant à la suivant e : \n \nSELECT  AVG (Moyenne)  \nFROM  (  \n SELECT  AVG (Note * Coefficient) AS Moyenne  \n FROM  Notes, Etudiant  \n WHERE  Notes. NumEtudiant = Etudiant.NumEtudiant  \n AND  Notes.Semestre = 1 \n AND  Notes.Year = YEAR(NOW())   Allez, Un brin de folie  ! \n AND  Etudiant.NumClasse = 7  \n GROUP  BY Notes.NumEtudiant    Remarquez l’obligation de préfixer par Notes.  \n) \n \nAutre exemple  : on veut connaître l’élève ou les élèves (s’il y a des exæquos ) qui a  ou ont  eu la meilleure note \nde l’année  2016 . Ici, l’idée, c’est d’une part de chercher la meilleure note de l’année 2016, d’autre part de \nchercher celui ou ceux qui l’ a ou l’ ont eue. \n \nSELECT  DISTINCT  Etudiant.Prenom, Etudiant.Nom   Remarquez la nécessité d’ajouter DISTINCT  \nFROM  Notes  AS N1, Etudiant           afin d’éviter un doublon  (duplicata, i.e. 2x le même  \nWHERE  N1.NumEtudiant = Etudiant.NumEtudiant        étudiant *) \nAND N1.Year = 2016  \nAND  N1.Note = (  \n SELECT  Max(N2.Note)  \n FROM  Notes As N2      L’alias lève ici tout ambiguïté (dans le doute…)  \n WHERE  N2.Year = 2016  \n) \n \n* Il peut y avoir deux fois le même étudiant dans le cas où la meilleure note de l’année est par exemple 18 et \noù un même  étudiant a obtenu deux fois 18 au cours de l’année.  \n \n4. Jointures  \n \nOn a vu des exemples ci -dessus. Il s’agit de jointures dites SQL1, à savoir des «  pseudo -jointure s ». Ces \n« pseudo -jointures  » procèdent comme suit  : \n- en résumé, il s’agit d’un produit car tésien suivi d’une restriction. Explicitons.  \n- un produit cartésien consiste à mettre en tête -à-tête tous les éléments d’un ensemble (les lignes d’une \ntable)  avec tous les éléments d’un ensemble (les lignes de la même table ou d’une autre table).  \n- la res triction évoquée consiste à ne conserver que les lignes qui vont bien ensemble, à savoir celles pour \nlesquelles Table1.clefEtrangere = Table2.clefPrimaire .  \n \nIllustration  : on se donne deux tables, Product( Num , Label, #Category) et Category( Num , Label)  \nRem arquez qu’on a appelé Category la clef étrangère de Product pointant sur Category.Num  ! \n \nProduct   Category  \nNum  Label  Category   Num  Label  \n1 Produit 1  1  1 Categorie 1  \n2 Produit 2  1  2 Categorie 2  \n3 Produit 3  2    \n \nBTS CGO 2A  P10 - Organisation du Système d’Information s Fiche SQL  \n \n \n4/6 Produit cartésien de Product et Category (c’est -à-dire FROM Product, Category)  : \n \nProduct. Num  Product. Label  Product. Category  Category. Num  Category. Label  \n1 Produit 1  1 1 Categorie 1  \n1 Produit 1  1 2 Categorie 2  \n2 Produit 2 1 1 Categorie 1  \n2 Produit 2 1 2 Categorie 2  \n3 Produit 3 2 1 Categorie 1  \n3 Produit 3 2 2 Categorie 2  \n \nNombre de lignes  = Nombre de «  Product  » x Nombre de «  Category  » \nCe qu’on note mathématiquement  :  Card(Product x Category) = Card(Product) x Card(Category)  \n \nFinalement, après restriction (WHERE Product.Category  = Category.Num), on obtient le résultat d’une \njointure , à savoir qu’il ne reste que les lignes ou l’égalité susvisée est vérifiée (lignes ayant deux cases \nsévèrement encadrées ci -dessus  et ci -dessous ) : \n \nProduct.Num  Product.Label  Product.Category  Category.Num  Category.Label  \n1 Produit 1  1 1 Categorie 1  \n2 Produit 2 1 1 Categorie 1  \n3 Produit 3 2 2 Categorie 2  \n \n5. Opérateurs ensemblistes  \n \nLes opérateurs ensemblistes sont  : UNION, EXCEPT et INTERSECT. Il permette de «  mettre en relation  » \nplusieurs requêtes.  On retiendra que  : les deux requêtes doivent retourner un résultat de même nature  : \nmême nombre de colonnes et même type de colonnes  ! \n \n  \nUNION      \n= 1 Produit 1  \n1 Produit 1  3 Produit 3  2 Produit 2  \n2 Produit 2  4 Produit 4 3 Produit 3  \n    4 Produit 4 \n \n1 Produit 1  \nEXCEPT         \n=   \n2 Produit 2  1 Produit 1  2 Produit 2  \n3 Produit 3  3 Produit 3 4 Produit 4  \n4 Produit 4     \n \n1 Produit 1  \nINTERSECT    \n=   \n2 Produit 2  1 Produit 1  1 Produit 1  \n3 Produit 3  3 Produit 3 3 Produit 3 \n4 Produit 4     \n \n6. Requêtes paramétrées  \n \nLes requêtes paramétrées, qu’est -ce ? Tout d’abord, c’est du «  made in Microsoft Access  », puisque ça \nn’existe nulle part ailleurs. Cela consiste à poser une question à un utilisateur exécutant une requête Access,  \nplus exactement, cela revient à lui demander de saisir une valeur et à utiliser la valeur qu’il a saisie, \ntypiquement pour effectuer une comparaison.  \n \nExemple  : on veut afficher une fiche client (sous -entendu, les données d’un Client, contenue dans la tab le \nClient, et dont l’utilisateur nous précisera le numéro).  \n \nBTS CGO 2A  P10 - Organisation du Système d’Information s Fiche SQL  \n \n \n5/6 SELECT  * \nFROM  Client  \nWHERE  Client.NumClient = [Saisir un n° client  :] \n \nIci, la «  question  » posée est «  Saisir un n° client  ». A l’exécution de la requête, une boîte de dialogue (petite \nfenêtre) apparaît. Celle -ci contient le message «  Saisir un n° client  ». L’utilisateur saisi t un numéro X \nquelconque. Notre condition devient alors Client.NumClient = X (avec X la valeur saisie).  \n \n7. Quelques c onseils  \n \n- Gardez bien en tête l’ordre dans lequel s’exécute une requête  : \n  FROM > WHERE > GROUP BY > HAVING > SELECT  \n \n- Gardez bien en tête l’ordre dans lequel s’écrit une requête  : \n  SELECT … FROM … WHERE … GROUP BY … HAVING … ORDER BY …  \n \n- A chaque fois, afin de rédiger une «  requête SELECT  » procédez comme suit  : \na : je me demande où sont mes informations. Autrement dit, je me demande quelles sont les tables dont j’ai \nbesoin. Je commence à rédiger ma clause FROM  ;   \nb : je me demande comment relier mes tables entre elles (jointures). J’ajoute, le cas é chéant, les tables \nmanquantes à la clause FROM  ; \nc : j’ajoute immédiatement les jointures sans réfléchir (jointures ou «  pseudo -jointure  »), à savoir \ntable1.clefPrimaire = table2.clefEtrangere AND …  \nd : j’ajoute les restriction manquantes, à savoir, je me demande  : dois -je éliminer des lignes  ? \ne : ça y est  ! Je peux m’occuper du reste.  \n \n- Bien vérifier que la question, le problème posé, ne puissent pas se décomposer en plusieurs problème s. Si \ntel est le cas, penser à rédiger une requête par problème et, le  cas échéant, utiliser une sous -requête.  \n \n- Si l’on cherche «  le nombre de  » ou «  combien y a -t-il … », il y a du «  SELECT COUNT(…)  » dans l’air.  \n \n- Si l’on cherche «  la moyenne de  » ou quelque chose «  en moyenne  », il y a du «  SELECT AVG(…)  » dans l’air.  \n \n8. Requêtes INSERT  INTO , UPDATE, DELETE  FROM  et autres  \n \nCREATE  TABLE  : ce sont les requêtes permettant la création de tables.  \nALTER  TABLE  : ce sont les requêtes permettant la modification de tables existantes.  \nCREATE  VIEW  : ce sont des requêtes permettant  de créer des vues, à savoir des requêtes se comportant \ncomme des tables.  \nCREATE  FUNCTION  : sans doute les plus intéressantes, ce sont les «  requêtes  » permettant de créer des \nprocédures stockées et de dépasser le cadre du SQL (Transact -SQL et PL -SQL).  \nCREATE TRIGGER  : sans doute les plus intéressantes avec CREATE FUNCTION, ce sont les «  requêtes  » \npermettant de veiller au respect de contrainte d’intégrité complexes telles que les contraintes d’associations .  \nGRANT  : requêtes permettant de conférer des droi ts aux utilisateurs d’une base de données.  \nCREATE INDEX, CREATE CONSTRAINT, DROP TABLE….  \n \n \nINSERT INTO UneTable VALUES  (‘Une chaîne’, 1.555, #01/12/2015, 3, …)  ; \nINSERT  INTO  UneTable (champ1, champ2, …, champN) VALUES  (valeur1, valeur2, …, valeurN)  ; \nINSERT  INTO  UneTable (champ1, champ2, …, champN) VALUES  (valeur1, valeur2, …, valeurN), (valeur1, valeur2, …, \nvaleurN), …, (valeur1, valeur2, …, valeurN)  ; \n \nRequête permettant d’insérer une  ou plusieurs  ligne s dans une table. Bien noter que, si vous ne précisez pas les champs \n(champ1, champ2, …), vous êtes sensés les utiliser tous  et dans le bon ordre  ! Il vaut parfois mieux écrire un peu… \nConseil  : dans le doute, écrivez -les. \n \n \n \n \nBTS CGO 2A  P10 - Organisation du Système d’Information s Fiche SQL  \n \n \n6/6  \n \nUPDATE  UneTable  \nSET UnChamp  = UneValeur  \nWHERE  Conditions  \n  \nUPDATE  UneTable  \nSET UnChamp1 = UneValeur1,  \n        UnChamp2 = UneValeur2  \nWHERE  Conditions  \n  \nUPDATE  UneTable  \nSET UnChamp1 = UnChamp1 * 2,  \nWHERE  Conditions  \n \nRequête permettant de modifier une ou plusieurs colonnes d’une ou plusieurs lignes d’une table.  Bien noter qu’on peut  : \n- modifier plusieurs colonnes d’un seul tenant  ; \n- modifier un champ en fonction de lui -même ou encore d’un autre.  \n \n \n \nDELETE FROM  UneTable  \nWHERE  Conditions  \n  \nDELETE UneTable1.*  \nFROM  UneTable1, UneTable2  \nWHERE  jointure  \nAND  conditions  \n \n \nRequête permettant de supprimer une ou plusieurs lignes. Bien retenir que, même si, beaucoup de SGBD ne prennent \npas en compte ce genre de DELETE, et même si quasiment personne ne fait des DELETE comme  ça en pratique , vous \ndevez savoir faire un de DELETE comme celui ci -dessus, à droite.  \n \n \n9. Culturel  \n \nSGBD  (Système de Gestion de Base de Données)  : un SGBD est un logiciel permettant d’assurer le stockage et \nl’interrogation de données. Le SQL est le langage d’interrogation de données utilisé en pratique pour \ninterroger des SGBDR (Système de Gestion de Base de Données Relationnelles).  On notera qu e, dans les cas \nsimples, u n SGBD peut être localisé sur un serveur unique. Il y a des cas plus complexes  :  \n- un SGBD peut être réparti sur plusieurs serveurs  ; \n- un SGBD peut être répliqué (base de données dupliquées de manière non triviale sur plusieurs serveurs)  ; \n- etc. \nLes cas évoqués ci -dessus induisent de nombreuses problématiques techniques, dont certai nes font à ce jour \nencore l’objet de travaux de recherche.  \nOn notera également qu’il existe un autre type de SGBD très en vogue, en particulier lorsque le nombre \nd’utilisateurs devient grand (des milliers, voire des millions).  Ces SGBD sont les SGBD nosql . Comme leur no m \nl’indique, ces SGBD ne s’interroge nt pas en SQL.  \n \nBASE S DE DONNEES ET MATHEMATIQUE  : tables, SQL, opérateurs ensemblistes… Derrière nombre de \nconcept que nous avons étudiés se cachent des concepts plus génériques, plus théoriques. Tous ces  concepts \ndérivent entre autre de branches mathématiques  : la théorie des ensembles et l’algèbre relationnel (d’où le \nterme de «  base de données relationnelle  »). Les règles à respecter pour avoir des bases de données  \nrelationnelles  « fiables  » ont égaleme nt été théorisées au travers en outre des formes normales  de Boyce -\nCodd.  \n \nSQL (Structured Query Language)  : le SQL n’est pas à proprement parler un langage de programmation. On le \nclasse parmi les L4G (langages de 4ème génération), à savoir des langage s de programmation à usage \nspécifique, en l’occurrence un langage d’interrogation de données.   \n \nNATURAL JOIN  : vraie jointure (SQL2), elle produit le même résultat que celle vous connaissez. Elle est \nessentiellement bien plus rapide et sa syntaxe épurée (T able1 NATURAL JOIN Table2, c’est tout)  ! Ne croyez \nsurtout pas que la puissance actuell e des ordinateurs nous permette  de tout le temps d’utilise r des requêtes \ntelles que celles que vous connaissez (avec WHERE). Sur des gros volumes de données, cela peut ê tre \nprohibitif/rédhibitoire . Certain es requêtes , dont le résultat est  produit  en quelques secondes avec NATURAL \nJOIN, mettrai ent des heures voire des années à être exécutée s avec une «  pseudo -jointure  ». \n \nINNER JOIN  : vraie jointure (SQL2), mais non nature lle, elle permet entre autre de produire le même résultat \nque les jointures avec WHERE.  Sa syntaxe est plus lourde que celle du NATURAL JOIN et moins intuitive que \ncelle des jointures avec WHERE. Il est plus lent que le NATURAL JOIN mais nettement plus rapide qu’une \njointure avec WHERE.",
  "file_type": "document",
  "original_path": "data/uploads\\Fiche - SQL.pdf"
}