{
  "filename": "module_Programmer en langage C  Cours et exercices corrigés - 5ème Edition.pdf",
  "extraction_date": "2025-09-28T13:29:48.263921",
  "statistics": {
    "word_count": 88989,
    "character_count": 506944,
    "line_count": 6489
  },
  "top_keywords": [
    [
      "dans",
      739
    ],
    [
      "fonction",
      405
    ],
    [
      "valeur",
      398
    ],
    [
      "type",
      382
    ],
    [
      "nous",
      382
    ],
    [
      "printf",
      356
    ],
    [
      "pour",
      347
    ],
    [
      "langage",
      298
    ],
    [
      "page",
      283
    ],
    [
      "2009",
      279
    ]
  ],
  "extracted_data": {
    "emails": [],
    "urls": [],
    "dates": [
      "12/05/09"
    ]
  },
  "content_preview": "Cet ouvrage est destiné aux étudiants débutants en langage C, mais ayant déjà quelques notions de programmation\nacquises par la pratique – même sommaire – d'un autre langage.\nLes notions fondamentales (types de données, opérateurs, instructions de contrôle, fonctions, tableaux…) sont exposées\navec un grand soin pédagogique, le lecteur étant conduit progressivement vers la maîtrise de concepts plus avancéscomme les pointeurs ou la gestion dynamique de la mémoire. \nChaque notion importante est ill...",
  "full_content": "Cet ouvrage est destiné aux étudiants débutants en langage C, mais ayant déjà quelques notions de programmation\nacquises par la pratique – même sommaire – d'un autre langage.\nLes notions fondamentales (types de données, opérateurs, instructions de contrôle, fonctions, tableaux…) sont exposées\navec un grand soin pédagogique, le lecteur étant conduit progressivement vers la maîtrise de concepts plus avancéscomme les pointeurs ou la gestion dynamique de la mémoire. \nChaque notion importante est illustrée d’exemples de programmes complets, accompagnés de résultats d’exécution. \nDe nombreux exercices, dont la solution est fournie en fin d’ouvrage, vous permettront de tester vos connaissances fraîchement acquises et de les approfondir.\nCette cinquième édition inclut les nouveautés de la dernière version de la norme ISO du langage (C99). \nÀ qui s’adresse ce livre ?\n•Aux étudiants de BTS, d’IUT, de licence ou d’écoles d’ingénieur.\n•Aux autodidactes ou professionnels de tous horizons souhaitant s’initier à la programmation en C.\n•Aux enseignants et formateurs à la recherche d’une méthode pédagogique et d’un support de cours structuré pour \nenseigner le C à des débutants.\nAu sommaire\nIntroduction au langage C • Les types de base du C • Les opérateurs et les expressions • Les entrées-sorties : printf, scanf\n• Les instructions de contrôle : if, switch, do…while, while, for… • La programmation modulaire et les fonctions •\nVariables locales et variables globales • Les tableaux et les pointeurs • Les chaînes de caractères • Les structures • Les\nfichiers • Gestion dynamique de la mémoire : fonctions malloc, free, calloc, realloc • Le préprocesseur • Les possibilités\ndu langage proches de la machine : opérateurs de manipulation de bits, champs de bits, unions • Les principales fonctions\nde la bibliothèque standard ( stdio.h, ctype.h, math.h, stdlib.h ) • Corrigé des exercices.\n9782212125467Code éditeur : G12546 • ISBN : 978-2-212-12546-7\nProgrammer en langage CC. Delannoy\nClaude Delannoy\nIngénieur informaticien au CNRS, Claude Delannoy possède une grande pratique de la formationcontinue et de l'enseignement supérieur. Réputés pour la qualité de leur démarche pédagogique,ses ouvrages sur les langages et la programmation totalisent plus de 250 000 exemplairesvendus.\nClaude Delannoy5eédition5eédition\nProgrammerenlangageC\nCours et exercices corrigésProgrammerenlangageC\nCours et exercices corrigés\n19,90 €250 000 ouvrages vendus250 000 ouvrages vendusdel 2009_C  12/05/09  9:51  Page 1\n���������������\n��������������������\n���������������������������\nAUX EDITIONS EYROLLES\nDu même auteurC. D\ne l a n n o y . – Exercices en langage C. \nN°11105, 1997, 260 pages.C. D\ne l a n n o y . – Langage C. \nN°12445, 2e édition, 2008, 936 pages.\nC. De l a n n o y . – C++ pour les programmeurs C. \nN°12231, 2007, 620 pages.C. D\ne l a n n o y . – Apprendre le C++. \nN°12135, 2007, 760 pages.C. D\ne l a n n o y . – Exercices en langage C++. \nN°12201, 3e édition 2007, 336 pages.\nC. De l a n n o y . – Programmer en Java. Java 5 et 6. \nN°12232, 5e édition, 2007, 800 pages + CD-Rom.\nC. De l a n n o y . – Exercices en Java. \nN°11989, 2e édition, 2006, 340 pages.\nAutres ouvrages C. B\nl a e s s . – Programmation système en C sous Linux. \nN°11601, 2e édition 2005, 964 pages.\nP. R o q u e s . – UML 2 par la pratique. \nN°12322, 6e édition, 2008, 368 pages.\nT. Z i aDé. – Programmation Python. \nN°12483, 2e édition, 2009, 586 pages.\nJ. en g e l s . – PHP 5 : cours et exercices.\nN°12486, 2e édition, 2009, 638 pages.\nE. Da sPeT et C. Pi eR Re  de g e y e R. – PHP 5 avancé. \nN°12369, 5e édition, 2008, 844 pages.\nC. P oR Te n e u v e . – Bien développer pour le Web 2.0. \nBonnes pratiques Ajax - Prototype, Script.aculo.us, accessibilité, JavaScript, DOM, XHTML/CSS. \nN°12391, 2e édition, 2008, 674 pages.\nC. so uTo u, o. T e sTe. – SQL pour Oracle.  \nN°12299, 3e édition 2008, 554 pages.\nC. so uTo u. – Apprendre SQL avec MySQL. \nN°11915, 2006, 418 pages.\nA. BRi l l a n T. – XML : cours et exercices.\nN°12151, 2007, 282 pages.\n���������������\n��������������������\n���������������������������\n10e tirage 2004 5e édition 2009\nÉDITIONS EYROLLES\n61, bd Saint-Germain\n75240 Paris Cedex 05\nwww.editions-eyrolles.com\nLe code de la propriété intellectuelle du 1er juillet 1992 interdit en effet expressément la photocopie à \nusage collectif sans autorisation des ayants droit. Or, cette pratique s’est généralisée notamment dans les \nétablissements d’enseignement, provoquant une baisse brutale des achats de livres, au point que la possibilité même pour les auteurs de créer des œuvres nouvelles et de les faire éditer correctement est aujourd’hui menacée.En application de la loi du 11 mars 1957, il est interdit de reproduire intégralement ou partiellement le \nprésent ouvrage, sur quelque support que ce soit, sans autorisation de l’éditeur ou du Centre Français d’Exploitation du Droit de Copie, 20, rue des Grands-Augustins, 75006 Paris.© Groupe Eyrolles, 1992-2009, ISBN : 978-2-212-12546-7\n \n© Éditions Eyrolles \nV \nTable des matières \nTable des matières . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . V\nAvant-propos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 \n1  \nGénéralités sur le langage C  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 \n1 Présentation par l’exemple de quelques instructions du langage C \n . . . . . . . . . . 3\n1.1 Un exemple de programme en langage C  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.2 Structure d’un programme en langage C  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 Déclarations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.4 Pour écrire des informations : la fonction  \nprintf \n  . . . . . . . . . . . . . . . . . . . . . . . . 6\n1.5 Pour faire une répétition : l’instruction  \nfor \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.6 Pour lire des informations : la fonction  \nscanf \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.7 Pour faire des choix : l’instruction  \nif \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.8 Les directives à destination du préprocesseur  . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n1.9 Un second exemple de programme  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 \n2 Quelques règles d’écriture \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.1 Les identiﬁcateurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122.2 Les mots-clés  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.3 Les séparateurs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132.4 Le format libre . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n2.5 Les commentaires  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 \n3 Création d’un programme en langage C \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n3.1 L ’édition du programme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n3.2 La compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153.3 L ’édition de liens  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n3.4 Les ﬁchiers en-tête . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 \n2 \nLes types de base du langage C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 \n1 La notion de type \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 \n2 Les types entiers \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n2.1 Leur représentation en mémoire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n2.2 Les différents types d’entiers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192.3 Notation des constantes entières . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 \n3 Les types ﬂottants \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n3.1 Les différents types et leur représentation en mémoire  . . . . . . . . . . . . . . . . . . . 203.2 Notation des constantes ﬂottantes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 \nDelannoy Livre.book  Page V  Mercredi, 6. mai 2009  4:25 16\n \nProgrammer en langage C Table des matières \nVI \n© Éditions Eyrolles \n4 Les types caractères \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n4.1 La notion de caractère en langage C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n4.2 Notation des constantes caractères . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 \n5 Initialisation et constantes \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 \n3 \nLes opérateurs et les expressions en langage C . . . . . . . . . . . . . . . . . . . . . . . . 25 \n1 L ’originalité des notions d’opérateur et d’expression en langage C \n . . . . . . . . . . 25 \n2 Les opérateurs arithmétiques en C \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n2.1 Présentation des opérateurs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272.2 Les priorités relatives des opérateurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 \n3 Les conversions implicites pouvant intervenir dans un calcul d’expression \n  . . 29\n3.1 Notion d’expression mixte  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293.2 Les conversions d’ajustement de type  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293.3 Les promotions numériques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303.4 Le cas du type  \nchar \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 \n4 Les opérateurs relationnels \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 \n5 Les opérateurs logiques \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 \n6 L ’opérateur d’affectation ordinaire \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n6.1 Notion de lvalue  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386.2 L ’opérateur d’affectation possède une associativité de droite à gauche . . . . . . . 386.3 L ’affectation peut entraîner une conversion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 \n7 Les opérateurs d’incrémentation et de décrémentation \n . . . . . . . . . . . . . . . . . . . . 39\n7.1 Leur rôle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 397.2 Leurs priorités . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407.3 Leur intérêt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 \n8 Les opérateurs d’affectation élargie \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 \n9 Les conversions forcées par une affectation \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 \n10 L ’opérateur de cast \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 \n11 L ’opérateur conditionnel \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 \n12 L ’opérateur séquentiel \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 \n13 L ’opérateur  \nsizeof \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 \n14 Récapitulatif des priorités de tous les opérateurs \n  . . . . . . . . . . . . . . . . . . . . . . . . 48 \nExercices \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 \n4 \nLes entrées-sorties conversationnelles  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51 \n1 Les possibilités de la fonction  \nprintf \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52\n1.1 Les principaux codes de conversion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521.2 Action sur le gabarit d’afﬁchage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521.3 Actions sur la précision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531.4 La syntaxe de  \nprintf \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\n1.5 En cas d’erreur de programmation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551.6 La macro  \nputchar \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 \nDelannoy Livre.book  Page VI  Mercredi, 6. mai 2009  4:25 16\n  .  .  .   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 6 Autres types introduits par la norme C99\n \n© Éditions Eyrolles \nVII \nTable des matières Programmer en langage C \n2  Les possibilités de la fonction  \nscanf \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n2.1 Les principaux codes de conversion de  \nscanf \n  . . . . . . . . . . . . . . . . . . . . . . . . . . 57\n2.2 Premières notions de tampon et de séparateurs  . . . . . . . . . . . . . . . . . . . . . . . . 57\n2.3 Les premières règles utilisées par  \nscanf \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57\n2.4 Imposition d’un gabarit maximal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 582.5 Rôle d’un espace dans le format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 592.6 Cas où un caractère invalide apparaît dans une donnée  . . . . . . . . . . . . . . . . . . 592.7 Arrêt prématuré de  \nscanf \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60\n2.8 La syntaxe de  \nscanf \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n2.9 Problèmes de synchronisation entre l’écran et le clavier  . . . . . . . . . . . . . . . . . . 612.10 En cas d’erreur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 622.11 La macro  \ngetchar \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 \nExercices \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 \n5 \nLes instructions de contrôle  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 \n1 L ’instruction  \nif \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n1.1 Blocs d’instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 681.2 Syntaxe de l’instruction  \nif \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n1.3 Exemples  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 691.4 Imbrication des instructions  \nif \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 \n2 Instruction  \nswitch \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\n2.1 Exemples d’introduction de l’instruction  \nswitch \n  . . . . . . . . . . . . . . . . . . . . . . . . . 72\n2.2 Syntaxe de l’instruction  \nswitch \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 \n3 L ’instruction  \ndo… while \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77\n3.1 Exemple d’introduction de l’instruction  \ndo... while \n . . . . . . . . . . . . . . . . . . . . . . 78\n3.2 Syntaxe de l’instruction  \ndo... while \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79\n3.3 Exemples  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 \n4 L ’instruction  \nwhile \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80\n4.1 Exemple d’introduction de l’instruction  \nwhile \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\n4.2 Syntaxe de l’instruction  \nwhile \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81 \n5 L ’instruction  \nfor \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\n5.1 Exemple d’introduction de l’instruction  \nfor \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\n5.2 Syntaxe de l’instruction  \nfor \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 \n6 Les instructions de branchement inconditionnel :  \nbreak \n,  \ncontinue \n et  \ngoto \n . . . 86\n6.1 L ’instruction  \nbreak \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86\n6.2 L ’instruction  \ncontinue \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\n6.3 L ’instruction  \ngoto \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 \nExercices \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90 \n6 \nLa programmation modulaire et les fonctions  . . . . . . . . . . . . . . . . . . . . . . . . . . 93 \n1 La fonction : la seule sorte de module existant en C \n  . . . . . . . . . . . . . . . . . . . . . . 94 \n2 Exemple de déﬁnition et d’utilisation d’une fonction en C \n . . . . . . . . . . . . . . . . . . 95 \nDelannoy Livre.book  Page VII  Mercredi, 6. mai 2009  4:25 16\n \nProgrammer en langage C Table des matières \nVIII \n© Éditions Eyrolles \n3 Quelques règles \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97\n3.1 Arguments muets et arguments effectifs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97\n3.2 L ’instruction  \nreturn \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n3.3 Cas des fonctions sans valeur de retour ou sans arguments . . . . . . . . . . . . . . . 993.4 Les anciennes formes de l’en-tête des fonctions . . . . . . . . . . . . . . . . . . . . . . . . 100 \n4 Les fonctions et leurs déclarations \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.1 Les différentes façons de déclarer (ou de ne pas déclarer) une fonction . . . . . . 1014.2 Où placer la déclaration d’une fonction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1024.3 À quoi sert la déclaration d’une fonction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 \n5 Retour sur les ﬁchiers en-tête \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 \n6 En C, les arguments sont transmis par valeur \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 \n7 Les variables globales \n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\n7.1 Exemple d’utilisation de variables globales  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1067.2 La portée des variables globales  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1067.3 La classe d’allocation des variables globales . . . . . . . . . . . . . . . . . . . . . . . . . . . 107 \n8 Les variables locales \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107\n8.1 La portée des variables locales  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1088.2 Les variables locales automatiques  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1088.3 Les variables locales statiques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1098.4 Le cas des fonctions récursives  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110 \n9 La compilation séparée et ses conséquences \n  . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\n9.1 La portée d’une variable globale - la déclaration extern . . . . . . . . . . . . . . . . . . . 1119.2 Les variables globales et l’édition de liens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1129.3 Les variables globales cachées - la déclaration static  . . . . . . . . . . . . . . . . . . . . 112 \n10 Les différents types de variables, leur portée et leur classe d’allocation . . . . . . 113\n10.1 La portée des variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11310.2 Les classes d’allocation des variables  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11310.3 Tableau récapitulatif  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n11 Initialisation des variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\n11.1 Les variables de classe statique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11511.2 Les variables de classe automatique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\n12 Les arguments variables en nombre   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\n12.1 Premier exemple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11612.2 Second exemple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\nExercices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n7 Les tableaux et les pointeurs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\n1 Les tableaux à un indice   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\n1.1 Exemple d’utilisation d’un tableau en C  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1211.2 Quelques règles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123\n2 Les tableaux à plusieurs indices   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\n2.1 Leur déclaration  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1242.2 Arrangement en mémoire des tableaux à plusieurs indices . . . . . . . . . . . . . . . . 124Delannoy Livre.book  Page VIII  Mercredi, 6. mai 2009  4:25 16\n© Éditions Eyrolles IXTable des matières Programmer en langage C\n3 Initialisation des tableaux   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n3.1 Initialisation de tableaux à un indice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n3.2 Initialisation de tableaux à plusieurs indices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126\n4 Notion de pointeur – Les opérateurs * et &   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1274.2 Quelques exemples  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1284.3 Incrémentation de pointeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n5 Comment simuler une transmission par adresse avec un pointeur   . . . . . . . . . . 130\n6 Un nom de tableau est un pointeur constant  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\n6.1 Cas des tableaux à un indice  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1326.2 Cas des tableaux à plusieurs indices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133\n7 Les opérateurs réalisables sur des pointeurs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n7.1 La comparaison de pointeurs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1347.2 La soustraction de pointeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1357.3 Les affectations de pointeurs et le pointeur nul  . . . . . . . . . . . . . . . . . . . . . . . . . 1357.4 Les conversions de pointeurs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1357.5 Les pointeurs génériques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n8 Les tableaux transmis en argument   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\n8.1 Cas des tableaux à un indice  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1378.2 Cas des tableaux à plusieurs indices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\n9 Utilisation de pointeurs sur des fonctions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141\n9.1 Paramétrage d’appel de fonctions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1419.2 Fonctions transmises en argument . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\n  Exercices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n8 Les chaînes de caractères . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145\n1 Représentation des chaînes   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\n1.1 La convention adoptée  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1461.2 Cas des chaînes constantes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1461.3 Initialisation de tableaux de caractères . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1471.4 Initialisation de tableaux de pointeurs sur des chaînes  . . . . . . . . . . . . . . . . . . . 148\n2 Pour lire et écrire des chaînes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149\n3 Pour ﬁabiliser la lecture au clavier : le couple \ngets  sscanf  . . . . . . . . . . . . . . . . . 151\n4 Généralités sur les fonctions portant sur des chaînes  . . . . . . . . . . . . . . . . . . . . . 153\n4.1 Ces fonctions travaillent toujours sur des adresses  . . . . . . . . . . . . . . . . . . . . . . 1534.2 La fonction \nstrlen  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153\n4.3 Le cas des fonctions de concaténation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\n5 Les fonctions de concaténation de chaînes   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\n5.1 La fonction strcat  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\n5.2 La fonction strncat  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155\n6 Les fonctions de comparaison de chaînes   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156\n7 Les fonctions de copie de chaînes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n8 Les fonctions de recherche dans une chaîne   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158Delannoy Livre.book  Page IX  Mercredi, 6. mai 2009  4:25 16\nProgrammer en langage C Table des matières\nX © Éditions Eyrolles9 Les fonctions de conversion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158\n9.1 Conversion d’une chaîne en valeurs numériques . . . . . . . . . . . . . . . . . . . . . . . . 158\n9.2 Conversion de valeurs numériques en chaîne . . . . . . . . . . . . . . . . . . . . . . . . . . 159\n10 Quelques précautions à prendre avec les chaînes . . . . . . . . . . . . . . . . . . . . . . . . 159\n10.1 Une chaîne possède une vraie ﬁn, mais pas de vrai début  . . . . . . . . . . . . . . . . 15910.2 Les risques de modiﬁcation des chaînes constantes . . . . . . . . . . . . . . . . . . . . . 160\n11 Les arguments transmis à la fonction main  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161\n11.1 Comment passer des arguments à un programme  . . . . . . . . . . . . . . . . . . . . . . 16111.2 Comment récupérer ces arguments dans la fonction \nmain  . . . . . . . . . . . . . . . . 162\nExercices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164\n9 Les structures et les énumérations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165\n1 Déclaration d’une structure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166\n2 Utilisation d’une structure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167\n2.1 Utilisation des champs d’une structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1672.2 Utilisation globale d’une structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1672.3 Initialisations de structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168\n3 Pour simpliﬁer la déclaration de types : déﬁnir des synonymes avec \ntypedef  . 169\n3.1 Exemples d’utilisation de typedef   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169\n3.2 Application aux structures  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169\n4 Imbrication de structures   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170\n4.1 Structure comportant des tableaux  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1704.2 Tableaux de structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1714.3 Structures comportant d’autres structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172\n5 À propos de la portée du modèle de structure   . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\n6 Transmission d’une structure en argument d’une fonction  . . . . . . . . . . . . . . . . . 174\n6.1 Transmission de la valeur d’une structure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1746.2 Transmission de l’adresse d’une structure : l’opérateur -> . . . . . . . . . . . . . . . . . 175\n7 Transmission d’une structure en valeur de retour d’une fonction   . . . . . . . . . . . 177\n8 Les énumérations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177\n8.1 Exemples introductifs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1778.2 Propriétés du type énumération . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\nExercices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180\n10 Les ﬁchiers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181\n1 Création séquentielle d’un ﬁchier  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\n2 Liste séquentielle d’un ﬁchier  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184\n3 L ’accès direct   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n3.1 Accès direct en lecture sur un ﬁchier existant  . . . . . . . . . . . . . . . . . . . . . . . . . . 1863.2 Les possibilités de l’accès direct  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1873.3 En cas d’erreur . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\n4 Les entrées-sorties formatées et les ﬁchiers de texte   . . . . . . . . . . . . . . . . . . . . . 189\n5 Les différentes possibilités d’ouverture d’un ﬁchier   . . . . . . . . . . . . . . . . . . . . . . 191Delannoy Livre.book  Page X  Mercredi, 6. mai 2009  4:25 16\n© Éditions Eyrolles XITable des matières Programmer en langage C\n6 Les ﬁchiers prédéﬁnis   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192\nExercices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193\n11 La gestion dynamique de la mémoire  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n1 Les outils de base de la gestion dynamique : malloc  et free  . . . . . . . . . . . . . . . 196\n1.1 La fonction malloc  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196\n1.2 La fonction free  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n2 D’autres outils de gestion dynamique : calloc  et realloc  . . . . . . . . . . . . . . . . . 199\n2.1 La fonction calloc  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199\n2.2 La fonction realloc  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n3 Exemple d’application de la gestion dynamique : création d’une liste chaînée  . 200\nExercice  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203\n12 Le préprocesseur  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205\n1 La directive #include  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205\n2 La directive #define  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206\n2.1 Déﬁnition de symboles  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206\n2.2 Déﬁnition de macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208\n3 La compilation conditionnelle  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n3.1 Incorporation liée à l’existence de symboles  . . . . . . . . . . . . . . . . . . . . . . . . . . . 2113.2 Incorporation liée à la valeur d’une expression . . . . . . . . . . . . . . . . . . . . . . . . . . 212\n13 Les possibilités du langage C proches de la machine  . . . . . . . . . . . . . . . . . . . . 215\n1 Compléments sur les types d’entiers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216\n1.1 Rappels concernant la représentation des nombres entiers en binaire  . . . . . . . 2161.2 Prise en compte d’un attribut de signe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2171.3 Extension des règles de conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2171.4 La notation octale ou hexadécimale des constantes  . . . . . . . . . . . . . . . . . . . . . 217\n2 Compléments sur les types de caractères  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n2.1 Prise en compte d’un attribut de signe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2182.2 Extension des règles de conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219\n3 Les opérateurs de manipulation de bits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220\n3.1 Présentation des opérateurs de manipulation de bits . . . . . . . . . . . . . . . . . . . . . 2203.2 Les opérateurs bit à bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2203.3 Les opérateurs de décalage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2213.4 Exemples d’utilisation des opérateurs de bits . . . . . . . . . . . . . . . . . . . . . . . . . . . 222\n4 Les champs de bits   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222\n5 Les unions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224Delannoy Livre.book  Page XI  Mercredi, 6. mai 2009  4:25 16\nProgrammer en langage C Table des matières\nXII © Éditions EyrollesAnnexe Les principales fonctions de la bibliothèque standard . . . . . . . . . . . . . . . . 227\n1 Entrées-sorties (stdio.h)   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228\n1.1 Gestion des ﬁchiers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228\n1.2 Écriture formatée  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228\nLes codes de format utilisables avec ces trois fonctions  . . . . . . . . . . . . . . . . . . 229\n1.3 Lecture formatée  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231\nRègles communes à ces fonctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232Les codes de format utilisés par ces fonctions . . . . . . . . . . . . . . . . . . . . . . . . . . 233\n1.4 Entrées-sorties de caractères  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2341.5 Entrées-sorties sans formatage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2361.6 Action sur le pointeur de ﬁchier  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2361.7 Gestion des erreurs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\n2 Tests de caractères et conversions majuscules-minuscules (ctype.h)   . . . . . . . 237\n3 Manipulation de chaînes (string.h)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238\n4 Fonctions mathématiques (math.h)   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239\n5 Utilitaires (stdlib.h)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\nCorrection des exercices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243\nChapitre 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243Chapitre 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244Chapitre 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244Chapitre 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248Chapitre 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250Chapitre 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252Chapitre 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254Chapitre 10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256Chapitre 11 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\nIndex  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261Delannoy Livre.book  Page XII  Mercredi, 6. mai 2009  4:25 16\n© Éditions Eyrolles 1Avant-propos\nLe langage C a été créé en 1972 par Denis Ritchie avec un objectif relativement limité : écrire\nun système d’exploitation (UNIX). Mais ses qualités opérationnelles l’ont très vite fait adopterpar une large communauté de programmeurs.\nUne première déﬁnition de ce langage est apparue en 1978 avec l’ouvrage de Kernighan et\nRitchie The C programming language . Mais ce langage a continué d’évoluer après cette date à\ntravers les différents compilateurs qui ont vu le jour. Son succès international a contribué à sanormalisation, d’abord par l’ANSI (American National Standard Institute), puis par l’ISO(International Standards Organization), plus récemment en 1993 par le CEN (Comité euro-péen de normalisation) et enﬁn, en 1994, par l’AFNOR. En fait, et fort heureusement, toutesces normes sont identiques, et l’usage veut qu’on parle de « C ANSI » ou de « C norme ANSI ».\nLa norme ANSI élargit, sans la contredire, la première déﬁnition de Kernighan et Ritchie.\nOutre la spéciﬁcation de la syntaxe du langage, elle a le mérite de fournir la description d’unensemble de fonctions qu’on doit trouver associées à tout compilateur C sous forme d’unebibliothèque standard. En revanche, compte tenu de son arrivée tardive, cette norme a cherchéà « préserver l’existant », en acceptant systématiquement les anciens programmes. Elle n’adonc pas pu supprimer certaines formulations quelque peu désuètes ou redondantes. Parexemple, la première déﬁnition de Kernighan et Ritchie prévoit qu’on déclare une fonction enprécisant uniquement le type de son résultat. La norme autorise qu’on la déclare sous formed’un « prototype » (qui précise en plus le type de ses arguments) mais ne l’impose pas. Noteztoutefois que le prototype deviendra obligatoire en C++.\nCet ouvrage a été conçu comme un cours de programmation en langage C. Suivant notre\ndémarche habituelle, héritée de notre expérience de l’enseignement, nous présentons toujoursles notions fondamentales sur un ou plusieurs exemples avant d’en donner plus formellementla portée générale. Souvent constitués de programmes complets, ces exemples permettent l’auto-expérimentation.\nLa plupart des chapitres de cet ouvrage proposent des exercices que nous vous conseillons de\nrésoudre d’abord sur papier, en comparant vos solutions avec celles fournies en ﬁn de volumeet en réﬂéchissant sur les différences de rédaction qui ne manqueront pas d’apparaître. Ils ser-viront à la fois à contrôler les connaissances acquises et à les appliquer à des situations variées.\nNous avons cherché à privilégier tout particulièrement la clarté et la progressivité de l’exposé.\nDans cet esprit, nous avons systématiquement évité les « références avant », ce qui, le caséchéant, autorise une étude séquentielle ; de même, les points les plus techniques ne sontexposés qu’une fois les bases du langage bien établies (une présentation prématurée serait perçuecomme un bruit de fond masquant le fondamental).\nD’une manière générale, notre ﬁl conducteur est ce qu’on pourrait appeler le « C moderne »,\nc’est-à-dire non pas la norme ANSI pure et dure, mais plutôt l’esprit de la norme dans ceDelannoy Livre.book  Page 1  Mercredi, 6. mai 2009  4:25 16\nProgrammer en langage C\n2 © Éditions Eyrollesqu’elle a de positif. Nous pensons ainsi forger chez le lecteur de bonnes habitudes de program-\nmation en C et, par la même occasion, nous lui facilitons son entrée future dans le monde duC++.\nEnﬁn, outre son caractère didactique, nous avons doté cet ouvrage d’une organisation appro-\npriée à une recherche rapide d’information :\n●ses chapitres sont fortement structurés : la table des matières, fort détaillée, offre de nom-breux points d’entrée,\n●au ﬁl du texte, des encadrés viennent récapituler la syntaxe des différentes instructions,\n●une annexe fournit la description des fonctions les plus usitées de la bibliothèque standard(il s’agit souvent d’une reprise d’informations déjà présentées dans le texte),\n●un index détaillé permet une recherche sur un point précis ; il comporte également, associéà chaque nom de fonction standard\n, le nom du ﬁchier en-tête (.h) correspondant.\nRemarque concernant cette nouvelle édition :\nL’ISO a publié en 1999, sous la référence ISO/IEC 9899:1999, une extension de la norme du\nlangage C, plus connue sous l’acronyme C99. Bien qu’ancienne, celle-ci est loin d’être implé-mentée dans sa totalité par tous les compilateurs. Dans cette nouvelle édition :\n●la mention C ANSI continue à désigner l’ancienne norme, souvent baptisée C89 ou C90 ;\n●lorsque cela s’est avéré justiﬁé, nous avons précisé les nouveautés introduites par la normeC99.Delannoy Livre.book  Page 2  Mercredi, 6. mai 2009  4:25 16\n \n© Éditions Eyrolles \n3 \nChapitre 1 \nGénéralités sur le langage C \nDans ce chapitre, nous vous proposons une première approche d’un programme en langage C,\nbasée sur deux exemples commentés. V ous y découvrirez (pour l’instant, de façon encoreinformelle) comment s’expriment les instructions de base (déclaration, affectation, lecture etécriture), ainsi que deux des structures fondamentales (boucle avec compteur, choix).\nNous dégagerons ensuite quelques règles générales concernant l’écriture d’un programme.\nEnﬁn, nous vous montrerons comment s’organise le développement d’un programme en vousrappelant ce que sont l’édition, la compilation, l’édition de liens et l’exécution.  \n1Présentation par l’exemple de quelques instructions  \ndu langage C \n1.1 Un exemple de programme en langage C \nV oici un exemple de programme en langage C, accompagné d’un exemple d’exécution. Avantd’en lire les explications qui suivent, essayez d’en percevoir plus ou moins le fonctionnement. \nDelannoy Livre.book  Page 3  Mercredi, 6. mai 2009  4:26 16\n \nProgrammer en langage C \n4 \n© Éditions Eyrolles \nNous reviendrons un peu plus loin sur le rôle des trois premières lignes. Pour l’instant, admettez\nsimplement que le symbole  \nNFOIS \n est équivalent à la valeur  \n5 \n. \n#include <stdio.h>\n#include <math.h>#define NFOIS 5 \nmain()\n{ int i ;    float x ;  float racx ;      \n  printf (\"Bonjour\\n\") ;\n  printf (\"Je vais vous calculer %d racines carrées\\n\", NFOIS) ;\n  for (i=0 ; i<NFOIS ; i++)\n    { printf (\"Donnez un nombre : \") ;      scanf (\"%f\", &x)  ;      if (x < 0.0)         printf (\"Le nombre %f ne possède pas de racine carrée\\n\", x) ;       else        { racx = sqrt (x) ;          printf (\"Le nombre %f a pour racine carrée : %f\\n\", x, racx) ;        }    }  printf (\"Travail terminé - Au revoir\") ;}\nBonjourJe vais vous calculer 5 racines carréesDonnez un nombre : 4Le nombre 4.000000 a pour racine carrée : 2.000000Donnez un nombre : 2Le nombre 2.000000 a pour racine carrée : 1.414214Donnez un nombre : -3Le nombre -3.000000 ne possède pas de racine carréeDonnez un nombre : 5.8Le nombre 5.800000 a pour racine carrée : 2.408319Donnez un nombre : 12.58Le nombre 12.580000 a pour racine carrée : 3.546829Travail terminé - Au revoir \nDelannoy Livre.book  Page 4  Mercredi, 6. mai 2009  4:26 16\n \n© Éditions Eyrolles \n5 \nchapitre n° 1 Généralités sur le langage C \n1.2 Structure d’un programme en langage C \nLa ligne : \nmain() \nse nomme un « en-tête ». Elle précise que ce qui sera décrit à sa suite est en fait le  \nprogramme\nprincipal \n ( \nmain \n). Lorsque nous aborderons l’écriture des fonctions en C, nous verrons que\ncelles-ci possèdent également un tel en-tête ; ainsi, en C, le programme principal apparaîtra en\nfait comme une fonction dont le nom ( \nmain \n) est imposé.\nLe programme (principal) proprement dit vient à la suite de cet en-tête. Il est délimité par lesaccolades «  \n{ \n » \n  \net «  \n} \n ». On dit que les instructions situées entre ces accolades forment un\n« bloc ». Ainsi peut-on dire que la fonction  \nmain \n est constituée d’un en-tête et d’un bloc ; il en\nira de même pour toute fonction C. Notez qu’un bloc peut lui-même contenir d’autres blocs(c’est le cas de notre exemple). En revanche, nous verrons qu’une fonction ne peut jamaiscontenir d’autres fonctions. \n1.3 Déclarations \nLes trois instructions : \n   int i ;  \n   float x ;   float racx ;  \nsont des « déclarations ».\nLa première précise que la variable nommée  \ni \n  \nest de type  \nint \n, c’est-à-dire qu’elle est desti-\nnée à contenir des nombres entiers (relatifs). Nous verrons qu’en C il existe plusieurs types\nd’entiers.\nLes deux autres déclarations précisent que les variables  \nx  \net  \nracx \n sont de type  \nfloat \n, c’est-\nà-dire qu’elles sont destinées à contenir des nombres ﬂottants (approximation de nombres\nréels). Là encore, nous verrons qu’en C il existe plusieurs types ﬂottants.\nEn C, comme dans la plupart des langages actuels,  \nles déclarations des types des variables\nsont obligatoires et doivent être regroupées au début du programme  \n(on devrait plutôt dire :\nau début de la fonction  \nmain \n). Il en ira de même pour toutes les variables déﬁnies dans une\nfonction ; on les appelle « variables locales » (en toute rigueur, les variables déﬁnies dans notre\nexemple sont des variables locales de la fonction  \nmain \n). Nous verrons également (dans le\nchapitre consacré aux fonctions) qu’on peut déﬁnir des variables en dehors de toute fonction ;on parlera alors de variables globales. \nS \nuivant la norme C99, une déclaration peut figurer à n’importe quel emplacement, pour peu \nqu’elle apparaisse avant que la variable correspondante ne soit utilisée. \nDelannoy Livre.book  Page 5  Mercredi, 6. mai 2009  4:26 16\n \nProgrammer en langage C \n6 \n© Éditions Eyrolles \n1.4 Pour écrire des informations : la fonction  \nprintf \nL ’instruction : \n   printf (\"Bonjour\\n\") ; \nappelle en fait une fonction prédéﬁnie (fournie avec le langage, et donc que vous n’avez pas à\nécrire vous-même) nommée  \nprintf \n. Ici, cette fonction reçoit un argument qui est : \n\"Bonjour\\n\" \nLes guillemets servent à délimiter une « chaîne de caractères » (suite de caractères). La nota-tion  \n\\n \n est conventionnelle : elle représente un caractère de ﬁn de ligne, c’est-à-dire un carac-\ntère qui, lorsqu’il est envoyé à l’écran, provoque le passage à la ligne suivante. Nous verronsque, de manière générale, le langage C prévoit une notation de ce type (\\ suivi d’un caractère)pour un certain nombre de caractères dits « de contrôle », c’est-à-dire ne possédant pas degraphisme particulier.\nNotez que, apparemment, bien que  \nprintf \n soit une fonction, nous n’utilisons pas sa valeur.\nNous aurons l’occasion de revenir sur ce point, propre au langage C. Pour l’instant, admettez\nque nous pouvons, en C, utiliser une fonction comme ce que d’autres langages nomment une« procédure » ou un « sous-programme ».\nL ’instruction suivante : \n   printf (\"Je vais vous calculer %d racines carrées\\n\", NFOIS) ; \nressemble à la précédente avec cette différence qu’ici la fonction  \nprintf \n  \nreçoit deux argu-\nments. Pour comprendre son fonctionnement, il faut savoir qu’en fait le premier argument de \nprintf \n est ce que l’on nomme un « format » ; il s’agit d’une sorte de guide qui précise com-\nment afﬁcher les informations qui sont fournies par les arguments suivants (le cas échéant).\nIci, on demande à  \nprintf \n d’afﬁcher suivant ce format : \n\"Je vais vous calculer %d racines carrées\\n\" \nla valeur de  \nNFOIS \n, c’est-à-dire,  la valeur  \n5 \n.\nCe format est, comme précédemment, une chaîne de caractères. Toutefois, vous constatez laprésence d’un caractère  \n% \n. Celui-ci signiﬁe que le caractère suivant est, non plus du texte à\nafﬁcher tel quel, mais un « code de format ». Ce dernier précise qu’il faut considérer la valeurreçue (en argument suivant, donc ici  \n5 \n) comme un entier et l’afﬁcher en décimal. Notez bien\nque tout ce qui, dans le format, n’est pas un code de format, est afﬁché tel quel ; il en va ainsidu texte «  \nracines carrées\\n \n  \n» \n.\nIl peut paraître surprenant d’avoir à spéciﬁer à nouveau dans le code format que  \nNFOIS(5) \n est\nun entier alors que l’on pourrait penser que le compilateur est bien capable de s’en apercevoir(quoiqu’il ne puisse pas deviner que nous voulons l’écrire en décimal et non pas, par exemple,en hexadécimal). Nous aurons l’occasion de revenir sur ce phénomène dont l’explication réside \nDelannoy Livre.book  Page 6  Mercredi, 6. mai 2009  4:26 16\n \n© Éditions Eyrolles \n7 \nchapitre n° 1 Généralités sur le langage C \nessentiellement dans le fait que  \nprintf \n est une fonction, autrement dit que les instructions\ncorrespondantes seront incorporées, non pas à la compilation, mais lors de l’édition de liens.\nCependant, dès maintenant,  \nsachez qu’il vous faudra toujours veiller à accorder le code de\nformat au type de la valeur correspondante \n. Si vous ne respectez pas cette règle, vous risquez\nfort d’afﬁcher des valeurs totalement fantaisistes. \n1.5 Pour faire une répétition : l’instruction  \nfor \nComme nous le verrons, en langage C, il existe plusieurs façons de réaliser une répétition (on\ndit aussi une « boucle »). Ici, nous avons utilisé l’instruction  \nfor \n  \n: \n   for (i=0 ; i<NFOIS ; i++) \nSon rôle est de répéter le bloc (délimité par des accolades «  \n{ \n » et «  \n} \n ») ﬁgurant à sa suite, en\nrespectant les consignes suivantes : \n● \navant de commencer cette répétition, réaliser : \ni = 0 \n● \navant chaque nouvelle exécution du bloc (tour de boucle), examiner la condition : \ni < NFOIS \nsi elle est satisfaite, exécuter le bloc indiqué, sinon passer à l’instruction suivant ce bloc : à laﬁn de chaque exécution du bloc, réaliser : \n i \n++ \nIl s’agit là d’une notation propre au langage C qui est équivalente à : \ni = i + 1 \nEn déﬁnitive, vous voyez qu’ici notre bloc sera répété cinq fois. \n1.6 Pour lire des informations : la fonction  \nscanf \nLa première instruction du bloc répété par l’instruction  \nfor \n afﬁche simplement le message\nDonnez un nombre: . Notez qu’ici nous n’avons pas prévu de changement de ligne à la ﬁn.\nLa seconde instruction du bloc :\nscanf (\"%f\", &x) ;\nest un appel de la fonction prédéﬁnie scanf  dont le rôle est de lire une information au clavier.\nComme printf , la fonction scanf  possède en premier argument un format exprimé sous\nforme d’une chaîne de caractères, ici :\n\"%f\"Delannoy Livre.book  Page 7  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n8 © Éditions Eyrollesce qui correspond à une valeur ﬂottante (plus tard, nous verrons précisément sous quelle forme\nelle peut être fournie ; l’exemple d’exécution du programme vous en donne déjà une bonneidée !). Notez bien qu’ici, contrairement à ce qui se produisait pour \nprintf , nous n’avons\naucune raison de trouver, dans ce format, d’autres caractères que ceux qui servent à déﬁnir uncode de format.\nComme nous pouvons nous y attendre, les arguments (ici, il n’y en a qu’un) précisent dans\nquelles variables on souhaite placer les valeurs lues. Il est fort probable que vous vous atten-diez à trouver simplement \nx et non pas &x.\nEn fait, la nature même du langage C fait qu’une telle notation reviendrait à transmettre à lafonction \nscanf  la valeur  de la variable x (laquelle, d’ailleurs, n’aurait pas encore reçu de\nvaleur précise). Or, manifestement, la fonction scanf  doit être en mesure de ranger la valeur\nqu’elle aura lue dans l’emplacement correspondant à cette variable, c’est-à-dire à son adresse.\nEffectivement, nous verrons que & est un opérateur signiﬁant adresse de .\nNotez bien que si, par mégarde, vous écrivez x au lieu de &x, le compilateur ne détectera pas\nd’erreur. Au moment de l’exécution, scanf prendra l’information reçue en deuxième argu-\nment (valeur de x) pour une adresse à laquelle elle rangera la valeur lue. Cela signiﬁe qu’on\nviendra tout simplement écraser un emplacement indéterminé de la mémoire ; les conséquen-ces pourront alors être quelconques.\n1.7 Pour faire des choix : l’instruction if\nLes lignes :\n  if (x < 0.0) \n     printf (\"Le nombre %f ne possède pas de racine carrée\\n\", x) ;   else     { racx = sqrt (x) ;       printf (\"Le nombre %f a pour racine carrée : %f\\n\", x, racx) ;     }\nconstituent une instruction de choix basée sur la condition x < 0.0 . Si cette condition est\nvraie, on exécute l’instruction suivante, c’est-à-dire :\n     printf (\"Le nombre %f ne possède pas de racine carrée\\n\", x) ;\nSi elle est fausse, on exécute l’instruction suivant le mot else , c’est-à-dire, ici, le bloc :\n    { racx = sqrt (x) ;      printf (\"Le nombre %f a pour racine carrée : %f\\n\", x, racx) ;    }\nNotez qu’il existe un mot else  mais pas de mot then . La syntaxe de l’instruction if\n(notamment g râce à la présence de parenthèses qui encadrent la condition) le rend inutile.Delannoy Livre.book  Page 8  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 9chapitre n° 1 Généralités sur le langage C\nLa fonction sqrt  fournit la valeur de la racine carrée d’une valeur ﬂottante qu’on lui transmet\nen argument.\nUne instruction telle que :\n   racx = sqrt (x) ;\nest une instruction classique d’affectation : elle donne à la variable racx  la valeur de l’expres-\nsion située à droite du signe égal. Nous verrons plus tard qu’en C l’affectation peut prendre des\nformes plus élaborées.\nNotez que C dispose de trois sortes d’instructions :\n• des instructions simples, terminées obligatoirement par un point-virgule,\n• des instructions de structuration telles que if ou for,\n• des blocs (délimités par { et }).Les deux dernières ont une définition « récursive » puisqu’elles peuvent contenir \n, à leur tour,\nn’importe laquelle des trois formes.Lorsque nous parlerons d’instruction, sans précisions supplémentaires, il pourra s’agir de\nn’importe laquelle des trois formes ci-dessus.\n1.8 Les directives à destination du préprocesseur\nLes trois premières lignes de notre programme :\n#include <stdio.h>\n#include <math.h>#define NFOIS 5 \nsont en fait un peu particulières. Il s’agit de directives qui seront prises en compte avant la tra-\nduction (compilation) du programme. Ces directives, contrairement au reste du programme,doivent être écrites à raison d’une par ligne et elles doivent obligatoirement commencer endébut de ligne. Leur emplacement au sein du programme n’est soumis à aucune contrainte(mais une directive ne s’applique qu’à la partie du programme qui lui succède). D’une manièregénérale, il est préférable de les placer au début, comme nous l’avons fait ici.\nLes deux premières directives demandent en fait d’introduire (avant compilation) des instruc-\ntions (en langage C) situées dans les ﬁchiers \nstdio.h  et math.h . Leur rôle ne sera complè-\ntement compréhensible qu’ultérieurement.\nPour l’instant, notez que, dès lors que vous faites appel à une fonction prédéﬁnie, il est nécessaire\nd’incorporer de tels ﬁchiers, nommés « ﬁchiers en-têtes », qui contiennent des déclarationsappropriées concernant cette fonction : \nstdio.h  pour printf  et scanf , math.h  pour sqrt .\nFréquemment, ces déclarations permettront au compilateur d’effectuer des contrôles sur le nombreet le type des arguments que vous mentionnerez dans l’appel de votre fonction.Delannoy Livre.book  Page 9  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n10 © Éditions EyrollesNotez qu’un même ﬁchier en-tête contient des déclarations relatives à plusieurs fonctions. En\ngénéral, il est indispensable d’incorporer stdio.h .\nLa troisième directive demande simplement de remplacer systématiquement, dans toute lasuite du programme, le symbole \nNFOIS  par 5. Autrement dit, le programme qui sera réellement\ncompilé comportera ces instrutions :\n   printf (\"Je vais vous calculer %d racines carrées\\n\", 5) ;\n        for (i=0 ; i<5 ; i++)\nNotez toutefois que le programme proposé est plus facile à adapter lorsque l’on emploie une\ndirective define . \nImportant : Dans notre exemple, la directive #define  servait à définir la valeur d’un symbole.\nNous verrons (dans le chapitre consacré au préprocesseur) que cette directive sert également\nà définir ce que l’on nomme une « macro ». Une macro s’utilise comme une fonction ; en parti-culier, elle peut posséder des arguments. Mais le préprocesseur remplacera chaque appel parla ou les instructions C correspondantes. Dans le cas d’une (vraie) fonction, une telle substi-tution n’existe pas ; au contraire, c’est l’éditeur de liens qui incorporera (une seule fois quel que\nsoit le nombre d’appels) les instructions machine correspondantes.\n1.9 Un second exemple de programme\nV oici un second exemple de programme destiné à vous montrer l’utilisation du type\n« caractère ». Il demande à l’utilisateur de choisir une opération parmi l’addition ou la multi-plication, puis de fournir deux nombres entiers ; il afﬁche alors le résultat correspondant.\n#include <stdio.h>\nmain(){   char op ;   int n1, n2 ;   printf (\"opération souhaitée (+ ou *) ? \") ;   scanf (\"%c\", &op) ;   printf (\"donnez 2 nombres entiers : \") ;   scanf (\"%d %d\", &n1, &n2) ;   if (op == '+') printf (\"leur somme  est : %d \", n1+n2) ;         else  printf (\"leur produit est : %d \", n1*n2) ;}Delannoy Livre.book  Page 10  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 11chapitre n° 1 Généralités sur le langage C\nIci, nous déclarons que la variable op est de type caractère ( char ). Une telle variable est\ndestinée à contenir un caractère quelconque (codé, bien sûr, sous forme binaire !). \nL ’instruction scanf  (\"%c\",  &op)  permet de lire un caractère au clavier et de le ranger dans\nop. Notez le code %c correspondant au type char  (n’oubliez pas le & devant op). L ’instruction\nif permet d’afﬁcher la somme ou le produit de deux nombres, suivant le caractère contenu\ndans op. Notez que :\n●la relation d’égalité se traduit par le signe == (et non = qui représente l’affectation et qui,\nici, comme nous le verrons plus tard, serait admis mais avec une autre signiﬁcation !).\n●la notation ’+’ représente une constante caractère. Notez bien que C n’utilise pas les\nmêmes délimiteurs pour les chaînes (il s’agit de \") et pour les caractères.\nRemarquez que, tel qu’il a été écrit, notre programme calcule le produit, dès lors que le caractèrefourni par l’utilisateur n’est pas +.  \nOn pourrait penser à inverser l’ordre des deux instructions de lecture en écrivant :\n   scanf (\"%d %d\", &n1, &n2) ;\n      ...   scanf (\"%c\", &op) ;\nToutefois, dans ce cas, une petite difficulté apparaîtrait : le caractère lu par le second appel de\nscanf serait toujours différent de + (ou de *). Il s’agirait en fait du caractère de fin de ligne \\n\n(fourni par la validation de la réponse précédente). Le mécanisme exact vous sera expliqué\ndans le chapitre relatif aux « entrées-sorties conversationnelles » ; pour l’instant, sachez quevous pouvez régler le problème en effectuant une lecture d’un caractère supplémentaire.\nAu lieu de :\n   scanf (\"%d\", &op) ;\non pourrait écrire :\n   op = getchar () ;\nCette instruction affecterait à la variable op le résultat fourni par la fonction getchar  (qui ne\nreçoit aucun argument - n’omettez toutefois pas les parenthèses !). \nD’une manière générale, il existe une fonction symétrique putchar  ; ainsi :\n   putchar (op) ;\naffiche le caractère contenu dans op.\nNotez que généralement getchar  et putchar  sont, non pas des vraies fonctions, mais des\nmacros dont la définition figure dans stdio.h .Delannoy Livre.book  Page 11  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n12 © Éditions Eyrolles2Quelques règles d’écriture\nCe paragraphe expose un certain nombre de règles générales intervenant dans l’écriture d’un\nprogramme en langage C. Nous y parlerons précisément de ce que l’on appelle les« identiﬁcateurs » et les « mots-clés », du format libre dans lequel on écrit les instructions,ainsi que de l’usage des séparateurs et des commentaires.\n2.1 Les identiﬁcateurs\nLes identiﬁcateurs servent à désigner les différents « objets » manipulés par le programme :variables, fonctions, etc. (Nous rencontrerons ultérieurement les autres objets manipulés par lelangage C : constantes, étiquettes de structure, d’union ou d’énumération, membres de struc-ture ou d’union, types, étiquettes d’instruction \nGOTO , macros). Comme dans la plupart des\nlangages, ils sont formés d’une suite de caractères choisis parmi les lettres  ou les chiffres , le\npremier d’entre eux étant nécessairement une lettre.\nEn ce qui concerne les lettres :\n●le caractère souligné (_) est considéré comme une lettre. Il peut donc apparaître au début\nd’un identiﬁcateur. V oici quelques identiﬁcateurs corrects :\n    lg_lig    valeur_5   _total   _89\n●les majuscules et les minuscules sont autorisées mais ne sont pas équivalentes. Ainsi, en C,les identiﬁcateurs ligne et Ligne désignent deux objets différents.\nEn ce qui concerne la longueur des identiﬁcateurs, la norme ANSI prévoit qu’au moins les31 premiers caractères soient « signiﬁcatifs » (autrement dit, deux identiﬁcateurs qui diffèrentpar leurs 31 premières lettres désigneront deux objets différents).\n2.2 Les mots-clés\nCertains « mots-clés » sont réservés par le langage à un usage bien déﬁni et ne peuvent pasêtre utilisés comme identiﬁcateurs. En voici la liste, classée par ordre alphabétique.\nLes mots-clés du langage C\nauto default float register struct volatile\nbreak do for return switch while\ncase double goto short typedefchar else if signed union\nconst enum int sizeof unsigned\ncontinue extern long static voidDelannoy Livre.book  Page 12  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 13chapitre n° 1 Généralités sur le langage C\n2.3 Les séparateurs\nDans notre langue écrite, les différents mots sont séparés par un espace, un signe de ponctuation\nou une ﬁn de ligne.\nIl en va quasiment de même en langage C dans lequel les règles vont donc paraître naturelles.\nAinsi, dans un programme, deux identiﬁcateurs successifs entre lesquels la syntaxe n’imposeaucun signe particulier (tel que : \n, = ; * ( ) [ ] { }) doivent impérativement être séparés soit\npar un espace, soit par une ﬁn de ligne. En revanche, dès que la syntaxe impose un séparateurquelconque, il n’est alors pas nécessaire de prévoir d’espaces supplémentaires (bien qu’enpratique cela améliore la lisibilité du programme).\nAinsi, vous devrez impérativement écrire :\nint x,y \net non :\nintx,y\nEn revanche, vous pourrez écrire indifféremment :\nint n,compte,total,p\nou plus lisiblement :\nint n, compte, total, p\n2.4 Le format libre\nLe langage C autorise une mise en page parfaitement libre. En particulier, une instruction\npeut s’étendre sur un nombre quelconque de lignes, et une même ligne peut comporter autantd’instructions que vous le souhaitez. Les ﬁns de ligne ne jouent pas de rôle particulier, si cen’est celui de séparateur, au même titre qu’un espace, sauf dans les « constantes chaînes » oùelles sont interdites ; de telles constantes doivent impérativement être écrites à l’intérieurd’une seule ligne. Un identiﬁcateur ne peut être coupé en deux par une ﬁn de ligne, ce quisemble évident.\nBien entendu, cette liberté de mise en page possède des contreparties. Notamment, le risque\nexiste, si l’on n’y prend garde, d’aboutir à des programmes peu lisibles.Delannoy Livre.book  Page 13  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n14 © Éditions EyrollesÀ titre d’exemple, voyez comment pourrait être (mal) présenté notre programme précédent :\n2.5 Les commentaires\nComme tout langage évolué, le langage C autorise la présence de commentaires dans vos pro-\ngrammes source. Il s’agit de textes explicatifs destinés aux lecteurs du programme et qui n’ontaucune incidence sur sa compilation.\nIls sont formés de caractères quelconques placés entre les symboles \n/*  et */. Ils peuvent\napparaître à tout endroit du programme où un espace est autorisé. En général, cependant, on se\nlimitera à des emplacements propices à une bonne lisibilité du programme.\nV oici quelques exemples de commentaires :\n/* programme de calcul de racines carrées */\n/* commentaire fantaisiste &ç§{<>} ?%!!!!!! *//* commentaire s’étendant \n   sur plusieurs lignes   de programme source    */\n/* ============================================\n   *    commentaire quelque peu esthétique    *   *    et encadré, pouvant servir,        *   *    par exemple, d’en-tête de programme   *   ============================================ */Exemple de programme mal présenté\n#include <stdio.h>\n#include <math.h>#define NFOIS 5 main() {  int i ;  float       x  ; float racx ; printf (\"Bonjour\\n\") ; printf     (\"Je vais vous calculer %d racines carrées\\n\", NFOIS) ;  for (i=     0 ; i<NFOIS ; i++) { printf (\"Donnez un nombre : \") ; scanf (\"%f\"     , &x) ;  if (x < 0.0)    printf (\"Le nombre %f ne possède pas de racine carrée\\n\", x) ;  else { racx = sqrt (x) ; printf (\"Le nombre %f a pour racine carrée : %f\\n\",       x, racx) ;  }     }   printf (\"Travail terminé - Au revoir\") ;}Delannoy Livre.book  Page 14  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 15chapitre n° 1 Généralités sur le langage C\nV oici un exemple de commentaires qui, situés au sein d’une instruction de déclaration,\npermettent de déﬁnir le rôle des différentes variables :\n   int i ;            /* compteur de boucle */\n   float x ;          /* nombre dont on veut la racine carrée */   float racx ;       /* racine carrée du nombre */\nLa norme C99 autorise une seconde forme de commentaire, dit « de fin de ligne », que l’on\nretrouve également en C++. Un tel commentaire est introduit par // et tout ce qui suit ces deux\ncaractères jusqu’à la fin de la ligne est considéré comme un commentaire. En voici un exemple :\n   printf (\"bonjour\\n\") ;   // formule de politesse  \n3Création d’un programme en langage C\nLa manière de développer et d’utiliser un programme en langage C dépend naturellement de\nl’environnement de programmation dans lequel vous travaillez. Nous vous fournissons iciquelques indications générales (s’appliquant à n’importe quel environnement) concernant ceque l’on pourrait appeler les grandes étapes de la création d’un programme, à savoir : éditiondu programme, compilation et édition de liens.\n3.1 L’édition du programme\nL ’édition du programme (on dit aussi parfois « saisie ») consiste à créer, à partir d’un clavier,tout ou partie du texte d’un programme qu’on nomme « programme source ». En général, cetexte sera conservé dans un ﬁchier que l’on nommera « ﬁchier source ».\nChaque système possède ses propres conventions de dénomination des ﬁchiers. En général, un\nﬁchier peut, en plus de son nom, être caractérisé par un groupe de caractères (au moins 3)qu’on appelle une « extension » (ou, parfois un « type ») ; la plupart du temps, en langage C,les ﬁchiers source porteront l’extension C.\n3.2 La compilation\nElle consiste à traduire le programme source (ou le contenu d’un ﬁchier source) en langagemachine, en faisant appel à un programme nommé compilateur. En langage C, compte tenu del’existence d’un préprocesseur, cette opération de compilation comporte en fait deux étapes :\n●traitement par le préprocesseur : ce dernier exécute simplement les directives qui le con-\ncernent (il les reconnaît au fait qu’elles commencent par un caractère #). Il produit, en\nrésultat, un programme source en langage C pur. Notez bien qu’il s’agit toujours d’un vraitexte, au même titre qu’un programme source : la plupart des environnements de program-mation vous permettent d’ailleurs, si vous le souhaitez, de connaître le résultat fourni parle préprocesseur.Delannoy Livre.book  Page 15  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n16 © Éditions Eyrolles●compilation  proprement dite, c’est-à-dire traduction en langage machine du texte en lan-\ngage C fourni par le préprocesseur.\nLe résultat de la compilation porte le nom de module objet.\n3.3 L’édition de liens\nLe module objet créé par le compilateur n’est pas directement exécutable. Il lui manque, au\nmoins, les différents modules objet correspondant aux fonctions prédéﬁnies (on dit aussi« fonctions standard ») utilisées par votre programme (comme \nprintf , scanf , sqrt ).\nC’est effectivement le rôle de l’éditeur de liens que d’aller rechercher dans la bibliothèquestandard les modules objet nécessaires. Notez que cette bibliothèque est une collection demodules objet organisée, suivant l’implémentation concernée, en un ou plusieurs ﬁchiers.\nLe résultat de l’édition de liens est ce que l’on nomme un programme exécutable, c’est-à-dire\nun ensemble autonome d’instructions en langage machine. Si ce programme exécutable estrangé dans un ﬁchier, il pourra ultérieurement être exécuté sans qu’il soit nécessaire de faireappel à un quelconque composant de l’environnement de programmation en C.\n3.4 Les ﬁchiers en-tête\nNous avons vu que, grâce à la directive #include , vous pouviez demander au préprocesseur\nd’introduire des instructions (en langage C) provenant de ce que l’on appelle des ﬁchiers « en-tête ». De tels ﬁchiers comportent, entre autres choses :\n●des déclarations relatives aux fonctions prédéﬁnies,\n●des déﬁnitions de macros prédéﬁnies.\nLorsqu’on écrit un programme, on ne fait pas toujours la différence entre fonction et macro, puis-que celles-ci s’utilisent de la même manière. Toutefois, les fonctions et les macros sont traitées defaçon totalement différente par l’ensemble « préprocesseur + compilateur + éditeur de liens ».\nEn effet, les appels de macros sont remplacés (par du C) par le préprocesseur, du moins si vous\navez incorporé le ﬁchier en-tête correspondant. Si vous ne l’avez pas fait, aucun remplacementne sera effectué, mais aucune erreur de compilation ne sera détectée : le compilateur croirasimplement avoir affaire à un appel de fonction ; ce n’est que l’éditeur de liens qui, ne la trouvantpas dans la bibliothèque standard, vous fournira un message.\nLes fonctions, quant à elles, sont incorporées par l’éditeur de liens. Cela reste vrai, même si\nvous omettez la directive \n#include  correspondante ; dans ce cas, simplement, le compila-\nteur n’aura pas disposé d’informations appropriées permettant d’effectuer des contrôlesd’arguments (nombre et type) et de mettre en place d’éventuelles conversions ; aucune erreurne sera signalée à la compilation ni à l’édition de liens ; les conséquences n’apparaîtront quelors de l’exécution : elles peuvent être invisibles dans le cas de fonctions comme \nprintf  ou,\nau contraire, conduire à des résultats erronés dans le cas de fonctions comme sqrt . Delannoy Livre.book  Page 16  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 17Chapitre 2\nLes types de base \ndu langage C\nLes types char , int et float  que nous avons déjà rencontrés sont souvent dits « scalaires »\nou « simples », car, à un instant donné, une variable d’un tel type contient une seule valeur. Ils\ns’opposent aux types « structurés » (on dit aussi « agrégés ») qui correspondent à des variablesqui, à un instant donné, contiennent plusieurs valeurs (de même type ou non). Ici, nous étudie-rons en détail ce que l’on appelle les types de base  du langage C ; il s’agit des types scalaires\nà partir desquels pourront être construits tous les autres, dits « types dérivés », qu’il s’agisse :\n●de types structurés comme les tableaux, les structures ou les unions,\n●d’autres types simples comme les pointeurs ou les énumérations.\nAuparavant, cependant, nous vous proposons de faire un bref rappel concernant la manièredont l’information est représentée dans un ordinateur et la notion de type qui en découle.\n1La notion de type\nLa mémoire centrale est un ensemble de positions binaires nommées bits. Les bits sont regroupésen octets (8 bits), et chaque octet est repéré par ce qu’on nomme son adresse.Delannoy Livre.book  Page 17  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n18 © Éditions EyrollesL ’ordinateur, compte tenu de sa technologie actuelle, ne sait représenter et traiter que des\ninformations exprimées sous forme binaire. Toute information, quelle que soit sa nature, devraêtre codée  sous cette forme. Dans ces conditions, on voit qu’il ne sufﬁt pas de connaître le contenu\nd’un emplacement de la mémoire (d’un ou de plusieurs octets) pour être en mesure de lui attribuerune signiﬁcation. Par exemple, si vous savez qu’un octet contient le « motif binaire » suivant : \n           01001101\nvous pouvez considérer que cela représente le nombre entier 77 (puisque le motif ci-dessus\ncorrespond à la représentation en base 2 de ce nombre). Mais pourquoi cela représenterait-ilun nombre ? En effet, toutes les informations (nombres entiers, nombres réels, nombres com-plexes, caractères, instructions de programme en langage machine, graphiques...) devront, aubout du compte, être codées en binaire.\nDans ces conditions, les huit bits ci-dessus peuvent peut-être représenter un caractère ; dans ce\ncas, si nous connaissons la convention employée sur la machine concernée pour représenter lescaractères, nous pouvons lui faire correspondre un caractère donné (par exemple M, dans lecas du code ASCII). Ils peuvent également représenter une partie d’une instruction machineou d’un nombre entier codé sur deux octets, ou d’un nombre réel codé sur 4 octets, ou...\nOn comprend donc qu’il n’est pas possible d’attribuer une signiﬁcation à une information\nbinaire tant que l’on ne connaît pas la manière dont elle a été codée. Qui plus est, en général,il ne sera même pas possible de « traiter » cette information. Par exemple, pour additionnerdeux informations, il faudra savoir quel codage a été employé aﬁn de pouvoir mettre en œuvreles bonnes instructions (en langage machine). Par exemple, on ne fait pas appel aux mêmescircuits électroniques pour additionner deux nombres codés sous forme « entière » et deuxnombres codés sous forme « ﬂottante ».\nD’une manière générale, la notion de type, telle qu’elle existe dans les langages évolués, sert à\nrégler (entre autres choses) les problèmes que nous venons d’évoquer.\nLes types de base du langage C se répartissent en trois grandes catégories en fonction de la\nnature des informations qu’ils permettent de représenter :\n●nombres entiers (mot-clé int),\n●nombres ﬂottants (mot-clé float  ou double ),\n●caractères (mot-clé char ) ; nous verrons qu’en fait char  apparaît (en C) comme un cas\nparticulier de int.\n2Les types entiers\n2.1 Leur représentation en mémoire\nLe mot-clé int correspond à la représentation de nombres entiers relatifs. Pour ce faire : un\nbit est réservé pour représenter le signe du nombre (en général 0 correspond à un nombreDelannoy Livre.book  Page 18  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 19chapitre n° 2 Les types de base du langage C\npositif) ; les autres bits servent à représenter la valeur absolue du nombre (en toute rigueur, on\nla représente sous la forme de ce que l’on nomme le « complément à deux ». Nous y revien-drons dans le chapitre 13).\n2.2 Les différents types d’entiers\nLe C prévoit que, sur une machine donnée, on puisse trouver jusqu’à trois tailles différentesd’entiers, désignées par les mots-clés suivants :\n●short  int (qu’on peut abréger en short ),\n●int (c’est celui que nous avons rencontré dans le chapitre précédent),\n●long  int (qu’on peut abréger en long ).\nChaque taille impose naturellement ses limites. Toutefois, ces dernières dépendent, non seule-ment du mot-clé considéré, mais également de la machine utilisée : tous les \nint n’ont pas la\nmême taille sur toutes les machines ! Fréquemment, deux des trois mots-clés correspondent àune même taille (par exemple, sur PC, \nshort  et int correspondent à 16 bits, tandis que long\ncorrespond à 32 bits).\nÀ titre indicatif, avec 16 bits, on représente des entiers s’étendant de -32 768 à 32 767 ; avec\n32 bits, on peut couvrir les valeurs allant de -2 147 483 648 à 2 147 483 647.\nEn toute rigueur, chacun des trois types ( short , int et long ) peut être nuancé par l’utilisation\ndu qualificatif unsigned  (non signé). Dans ce cas, il n’y a plus de bit réservé au signe et on ne\nreprésente plus que des nombres positifs. Son emploi est réservé à des situations particulières.\nNous y reviendrons dans le chapitre 13.\nLa norme C99 introduit le type long  long , ainsi que des types permettant de choisir :\n●soit la taille correspondante, par exemple int16  pour des entiers codés sur 16 bits ou\nint32  pour des entiers codés sur 32 bits ;\n●soit une taille minimale, par exemple int_least32_t  pour un entier d’au moins 32 bits.\n2.3 Notation des constantes entières\nLa façon la plus naturelle d’introduire une constante entière dans un programme est de l’écrire\nsimplement sous forme décimale, avec ou sans signe, comme dans ces exemples :\n            +533    48    -273\nIl est également possible d’utiliser une notation octale ou hexadécimale. Nous en reparleronsdans le chapitre 13.Delannoy Livre.book  Page 19  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n20 © Éditions Eyrolles3Les types ﬂottants\n3.1 Les différents types et leur représentation en mémoire\nLes types ﬂottants permettent de représenter, de manière approchée , une partie des nombres\nréels. Pour ce faire, ils s’inspirent de la notation scientiﬁque (ou exponentielle) bien connue\nqui consiste à écrire un nombre sous la forme 1.5 1022 ou 0.472 10-8 ; dans une telle notation,\non nomme « mantisses » les quantités telles que 1.5 ou 0.472  et « exposants » les quantités\ntelles que 22 ou -8.\nPlus précisément, un nombre réel sera représenté en ﬂottant en déterminant deux quantités M(mantisse) et E (exposant) telles que la valeur\nM . B \nE\nreprésente une approximation de ce nombre. La base B est généralement unique pour unemachine donnée (il s’agit souvent de 2 ou de 16) et elle ne ﬁgure pas explicitement dans lareprésentation machine du nombre.\nLe C prévoit trois types de ﬂottants correspondant à des tailles différentes : \nfloat , double\net long double . La connaissance des caractéristiques exactes du système de codage n’est\ngénéralement pas indispensable, sauf lorsque l’on doit faire une analyse ﬁne des erreurs de\ncalcul.  En revanche, il est important de noter que de telles représentations sont caractérisées\npar deux éléments :\n●la précision : lors du codage d’un nombre décimal quelconque dans un type ﬂottant, il est\nnécessaire de ne conserver qu’un nombre ﬁni de bits. Or la plupart des nombres s’expri-mant avec un nombre limité de décimales ne peuvent pas s’exprimer de façon exacte dansun tel codage. On est donc obligé de se limiter à une représentation approchée en faisant ceque l’on nomme une erreur de troncature. Quelle que soit la machine utilisée, on est assuréque cette erreur (relative) ne dépassera pas 10\n-6 pour le type float  et 10-10 pour le type\nlong double .\n●le domaine couvert , c’est-à-dire l’ensemble des nombres représentables à l’erreur de tron-\ncature près. Là encore, quelle que soit la machine utilisée, on est assuré qu’il s’étendra aumoins de 10\n-37 à 10+37.\n3.2 Notation des constantes ﬂottantes\nComme dans la plupart des langages, les constantes ﬂottantes peuvent s’écrire indifféremment\nsuivant l’une des deux notations :\n●décimale,\n●exponentielle.Delannoy Livre.book  Page 20  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 21chapitre n° 2 Les types de base du langage C\nLa notation décimale doit comporter obligatoirement un point (correspondant à notre virgule).\nLa partie entière ou la partie décimale peut être omise (mais, bien sûr, pas toutes les deux enmême temps !). En voici quelques exemples corrects :\n        12.43    -0.38     -.38     4.    .27\nEn revanche, la constante 47 serait considérée comme entière et non comme ﬂottante. Dans la\npratique, ce fait aura peu d’importance, si ce n’est au niveau du temps d’exécution, comptetenu des conversions automatiques qui seront mises en place par le compilateur (et dont nousparlerons dans le chapitre suivant).\nLa notation exponentielle utilise la lettre \ne (ou E) pour introduire un exposant entier (puis-\nsance de 10), avec ou sans signe. La mantisse peut être n’importe quel nombre décimal ou\nentier (le point peut être absent dès que l’on utilise un exposant). V oici quelques exemplescorrects (les exemples d’une même ligne étant équivalents) :\n          4.25E4              4.25e+4            42.5E3\n       54.27E-32            542.7E-33          5427e-34           48e13               48.e13           48.0E13\nPar défaut, toutes les constantes sont créées par le compilateur dans le type double . Il est tou-\ntefois possible d’imposer à une constante ﬂottante :\n●d’être du type float , en faisant suivre son écriture de la lettre F (ou f) : cela permet de\ngagner un peu de place mémoire, en contrepartie d’une éventuelle perte de précision (le\ngain en place et la perte en précision dépendant de la machine concernée).\n●d’être du type long  double , en faisant suivre son écriture de la lettre L (ou l) : cela permet\nde gagner éventuellement en précision, en contrepartie d’une perte de place mémoire (legain en précision et la perte en place dépendant de la machine concernée).\n4Les types caractères\n4.1 La notion de caractère en langage C\nComme la plupart des langages, C permet de manipuler des caractères codés en mémoire sur\nun octet. Bien entendu, le code employé, ainsi que l’ensemble des caractères représentables,dépend de l’environnement de programmation utilisé (c’est-à-dire à la fois de la machineconcernée et du compilateur employé). Néanmoins, on est toujours certain de disposer deslettres (majuscules et minuscules), des chiffres, des signes de ponctuation et des différentsséparateurs (en fait, tous ceux que l’on emploie pour écrire un programme !). En revanche, lescaractères nationaux (caractères accentués ou ç) ou les caractères semi-graphiques ne ﬁgurentpas dans tous les environnements.Delannoy Livre.book  Page 21  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n22 © Éditions EyrollesPar ailleurs, la notion de caractère en C dépasse celle de caractère imprimable, c’est-à-dire\nauquel est obligatoirement associé un graphisme (et qu’on peut donc imprimer ou afﬁcher surun écran). C’est ainsi qu’il existe certains caractères de changement de ligne, de tabulation,d’activation d’une alarme sonore (cloche),... Nous avons d’ailleurs déjà utilisé le premier(sous la forme \n\\n).\nDe tels caractères sont souvent nommés « caractères de contrôle ». Dans le code ASCII (res-\ntreint ou non), ils ont des codes compris entre 0 et 31.\n4.2 Notation des constantes caractères\nLes constantes de type « caractère », lorsqu’elles correspondent à des caractères imprimables,se notent de façon classique, en écrivant entre apostrophes (ou quotes) le caractère voulu,comme dans ces exemples :\n          'a'       'Y'       '+'      '$'\nCertains caractères non imprimables possèdent une représentation conventionnelle utilisantle caractère « \n\\ », nommé « antislash » (en anglais, il se nomme « back-slash », en français,\non le nomme aussi « barre inverse » ou « contre-slash »). Dans cette catégorie, on trouveégalement quelques caractères (\n\\, ’, \" et ?) qui, bien que disposant d’un graphisme, jouent\nun rôle particulier de délimiteur qui les empêche d’être notés de manière classique entredeux apostrophes. \nV oici la liste de ces caractères.\nCaractères disposant d’une notation spéciale\n NOTATION   CODE ASCII    ABRÉVIATION           SIGNIFICATION\n  EN C     (hexadécimal)   USUELLE\n   \\a          07            BEL      cloche ou bip (alert ou audible bell)\n   \\b          08            BS    Retour arrière (Backspace)\n   \\f          0C            FF      Saut de page (Form Feed)\n   \\n          0A            LF  Saut de ligne (Line Feed)\n   \\r          0D            CR Retour chariot (Carriage Return)\n   \\t          09            HT Tabulation horizontale (Horizontal Tab)\n   \\v          0B            VT Tabulation verticale (Vertical Tab)\n   \\\\          5C             \\   \\'          2C             '   \\\"          22             \"   \\?          3F             ?Delannoy Livre.book  Page 22  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 23chapitre n° 2 Les types de base du langage C\nDe plus, il est possible d’utiliser directement le code du caractère en l’exprimant, toujours à la\nsuite du caractère « antislash » :\n●soit sous forme octale ,\n●soit sous forme hexadécimale  précédée de x.\nV oici quelques exemples de notations équivalentes, dans le code ASCII : \n  'A'     '\\x41'   '\\101'\n  '\\r'    '\\x0d'   '\\15'    '\\015'  '\\a'    '\\x07'   '\\x7'    '\\07'    '\\007'\nEn fait, il existe plusieurs versions de code ASCII, mais toutes ont en commun la première moi-\ntié des codes (correspondant aux caractères qu’on trouve dans toutes les implémentations) ;\nles exemples cités ici appartiennent bien à cette partie commune. \nLe caractère \\, suivi d’un caractère autre que ceux du tableau ci-dessus ou d’un chiffre de 0 à\n7 est simplement ignoré. Ainsi, dans le cas où l’on a affaire au code ASCII, \\9 correspond au\ncaractère 9 (de code ASCII 57), tandis que \\7 correspond au caractère de code ASCII 7, c’est-\nà-dire la « cloche ».\nEn fait, la norme prévoit deux types : signed  char  et unsigned  char  (char  correspondant soit\nà l’un, soit à l’autre, suivant le compilateur utilisé). Là encore, nous y reviendrons dans le cha-pitre 13. Pour l’instant, sachez que cet attribut de signe n’agit pas sur la représentation d’uncaractère en mémoire. En revanche, il pourra avoir un rôle dans le cas où l’on s’intéresse à la\nvaleur numérique associée à un caractère.\n5Initialisation et constantes\n1. Nous avons déjà vu que la directive #define  permettait de donner une valeur à un sym-\nbole. Dans ce cas, le préprocesseur effectue le remplacement correspondant avant la\ncompilation.\n2. Par ailleurs, il est possible d’initialiser une variable lors de sa déclaration comme dans :\nint n = 15 ;\nIci, pour le compilateur, n est une  variable de type int dans laquelle il placera la valeur\n15 ; mais rien n’empêche que cette valeur initiale évolue lors de l’exécution du pro-\ngramme. Notez d’ailleurs que la déclaration précédente pourrait être remplacée par unedéclaration ordinaire (\nint n ), suivie un peu plus loin d’une affectation ( n=15 ) ; la seule\ndifférence résiderait dans l’instant où n recevrait la valeur 15.Delannoy Livre.book  Page 23  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n24 © Éditions Eyrolles3. En fait, il est possible de déclarer que la valeur d’une variable ne doit pas changer lors de\nl’exécution du programme. Par exemple, avec :\nconst int n = 20 ;\non déclare n de type int et de valeur (initiale) 20 mais, de surcroît, les éventuelles\ninstructions modiﬁant la valeur de n seront rejetées par le compilateur.\nOn pourrait penser qu’une déclaration (par const ) remplace avantageusement l’emploi\nde define . En fait, nous verrons que les choses ne sont pas aussi simples, car les varia-\nbles ainsi déclarées ne pourront pas intervenir dans ce qu’on appelle des « expressions\nconstantes » (notamment, elles ne pourront pas servir de dimension d’un tableau !).\n6Autres types introduits par la norme C99\nOutre les nouveaux types entiers dont nous avons parlé, la norme C99 introduit :\n●le type booléen, sous le nom bool  ; une variable de ce type ne peut prendre que l’une des\ndeux valeurs : vrai (noté true) et faux (noté false ) ;\n●des types complexes, sous les noms float  complex , double  complex  et long  double\ncomplex  ; la constante I correspond alors à la constante mathématique i (racine de –1).Delannoy Livre.book  Page 24  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 25Chapitre 3\nLes opérateurs et les \nexpressions en langage C\n1L’originalité des notions d’opérateur et d’expression en langage C\nLe langage C est certainement l’un des langages les plus fournis en opérateurs. Cette richesse\nse manifeste tout d’abord au niveau des opérateurs classiques ( arithmétiques , relationnels ,\nlogiques) ou moins classiques ( manipulations de bits ). Mais, de surcroît, le C dispose d’un\nimportant éventail d’opérateurs originaux d’affectation  et d’incrémentation .\nCe dernier aspect nécessite une explication. En effet, dans la  plupart des langages, on trouve,comme en C :\n●d’une part, des expressions  formées (entre autres) à l’aide d’opérateurs,\n●d’autre part, des instructions pouvant éventuellement faire intervenir des expressions,\ncomme, par exemple, l’instruction d’affectation :\ny = a * x +b ;\nou encore l’instruction d’afﬁchage :\nprintf (\"valeur %d\", n + 2*p) ; \ndans laquelle apparaît l’expression n + 2 * p .Delannoy Livre.book  Page 25  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n26 © Éditions EyrollesMais, généralement, dans les langages autres que C, l’expression possède une valeur mais ne\nréalise aucune action, en particulier aucune affectation d’une valeur à une variable. Au contraire,l’affectation y réalise une affectation d’une valeur à une variable mais ne possède pas de valeur.On a affaire à deux notions parfaitement disjointes. En langage C, il en va différemmentpuisque :\n●d’une part, les (nouveaux) opérateurs d’incrémentation pourront non seulement intervenirau sein d’une expression (laquelle, au bout du compte, possédera une valeur), mais égale-ment agir sur le contenu de variables. Ainsi, l’expression (car, comme nous le verrons, ils’agit bien d’une expression en C) :\n     ++i\nréalisera une action, à savoir : augmenter la valeur i de 1 ; en même temps, elle aura une\nvaleur, à savoir celle de i après incrémentation.\n●d’autre part, une affectation apparemment classique telle que :\n     i = 5\npourra, à son tour, être considérée comme une expression (ici, de valeur 5). D’ailleurs, en\nC, l’affectation (=) est un opérateur. Par exemple, la notation suivante :\n     k = i = 5\nreprésente une expression en C (ce n’est pas encore une instruction - nous y reviendrons).Elle sera interprétée comme :\n     k = (i = 5)\nAutrement dit, elle affectera à i la valeur 5 puis elle affectera à k la valeur de l’expression\ni = 5 , c’est-à-dire 5.\nEn fait, en C, les notions d’expression et d’instruction sont étroitement liées puisque la\nprincipale instruction  de ce langage est une expression terminée par un point-virgule . On\nla nomme souvent « instruction expression ». V oici des exemples de telles instructions  qui\nreprennent les expressions  évoquées ci-dessus :\n++i ;\ni = 5 ;\nk = i = 5 ;\nLes deux premières ont l’allure d’une affectation telle qu’on la rencontre classiquement dans\nla plupart des autres langages. Notez que, dans les deux cas, il y a évaluation d’une expression\n(++i  ou i=5) dont la valeur est ﬁnalement inutilisée. Dans le dernier cas, la valeur de\nl’expression i=5, c’est-à-dire 5, est à son tour affectée à k ; par contre, la valeur ﬁnale\nde l’expression complète est, là encore, inutilisée.\nCe chapitre vous présente la plupart des opérateurs du C ainsi que les règles de priorité et de\nconversion de type qui interviennent dans les évaluations des expressions. Les (quelques)autres opérateurs concernent essentiellement les pointeurs, l’accès aux tableaux et aux structureset les manipulations de bits. Ils seront exposés dans la suite de cet ouvrage.Delannoy Livre.book  Page 26  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 27chapitre n° 3 Les opérateurs et les expressions en langage C\n2Les opérateurs arithmétiques en C\n2.1 Présentation des opérateurs\nComme tous les langages, C dispose d’opérateurs classiques « binaires » (c’est-à-dire portant\nsur deux « opérandes »), à savoir l’addition ( +), la soustraction ( -), la multiplication ( *) et la\ndivision (/), ainsi que d’un opérateur « unaire » (c’est-à-dire ne portant que sur un seul opérande)\ncorrespondant à l’opposé noté - (comme dans -n ou dans -x+y ).\nLes opérateurs binaires ne sont a priori déﬁnis que pour deux opérandes ayant le même typeparmi : \nint, long int , float , double , long double  et ils fournissent un résultat de\nmême type que leurs opérandes. \nEn machine, il n’existe, par exemple, que des additions de deux entiers de même taille ou de\nflottants de même taille. Il n’existe pas d’addition d’un entier et d’un flottant ou de deux flottants\nde taille différente. \nMais nous verrons, dans le paragraphe 2, que, par le jeu des conversions implicites, le compi-lateur saura leur donner une signiﬁcation :\n●soit lorsqu’ils porteront sur des opérateurs de type différent,\n●soit lorsqu’ils porteront sur des opérandes de type char  ou short .\nDe plus, il existe un opérateur de modulo noté % qui ne peut porter que sur des entiers et qui\nfournit le reste de la division de son premier opérande par son second. Par exemple, 11%4  vaut\n3, 23%6  vaut 5. \nLa norme ANSI ne déﬁnit les opérateurs % et / que pour des valeurs positives de leurs deux opé-\nrandes. Dans les autres cas, le résultat dépend de l’implémentation (C99 lève cette ambiguïté).\nNotez bien qu’en C le quotient de deux entiers fournit un entier. Ainsi, 5/2 vaut 2 ; en revan-\nche, le quotient de deux ﬂottants (noté, lui aussi, /) est bien un ﬂottant ( 5.0/2.0  vaut bien\napproximativement 2.5).\nIl n’existe pas d’opérateur d’élévation à la puissance. Il est nécessaire de faire appel soit à des\nproduits successifs pour des puissances entières pas trop grandes (par exemple, on calculera\nx3 comme x*x*x ), soit à la fonction power  de la bibliothèque standard (voyez éventuellement\nl’annexe).\n2.2 Les priorités relatives des opérateurs\nLorsque plusieurs opérateurs apparaissent dans une même expression, il est nécessaire de\nsavoir dans quel ordre ils sont mis en jeu. En C, comme dans les autres langages, les règlessont naturelles et rejoignent celles de l’algèbre traditionnelle (du moins, en ce qui concerne lesopérateurs arithmétiques dont nous parlons ici).Delannoy Livre.book  Page 27  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n28 © Éditions EyrollesLes opérateurs unaires + et - ont la priorité la plus élevée. On trouve ensuite, à un même\nniveau, les opérateurs *, / et %. Enﬁn, sur un dernier niveau, apparaissent les opérateurs\nbinaires + et -.\nEn cas de priorités identiques, les calculs s’effectuent de gauche à droite. On dit que l’on a\naffaire à une associativité de gauche à droite  (nous verrons que quelques opérateurs, autres\nqu’arithmétiques, utilisent une associativité de droite à gauche).\nEnﬁn, des parenthèses permettent d’outrepasser ces règles de priorité, en forçant le calcul\npréalable de l’expression qu’elles contiennent. Notez que ces parenthèses peuvent égalementêtre employées pour assurer une meilleure lisibilité d’une expression.\nV oici quelques exemples dans lesquels l’expression de droite, où ont été introduites des paren-\nthèses superﬂues, montre dans quel ordre s’effectuent les calculs (les deux expressions proposéesconduisent donc aux mêmes résultats) : \na + b * c                        a + ( b * c )\na * b + c % d                    ( a * b ) + ( c % d )- c % d                          ( - c ) % d- a + c % d                      ( - a ) + ( c % d )- a / - b + c                    ( ( - a ) / ( - b ) ) + c- a / - ( b + c )                ( - a ) / ( - ( b + c ) )\nLes règles de priorité interviennent pour définir la signification exacte d’une expression. Néan-\nmoins, lorsque deux opérateurs sont théoriquement commutatifs, on ne peut être certain de\nl’ordre dans lequel ils seront finalement exécutés. Par exemple, une expression telle que\na+b+c pourra aussi bien être calculée en ajoutant c à la somme de a et b, qu’en ajoutant a à\nla somme de b et c. Même l’emploi de parenthèses dans ce cas ne suffit pas à « forcer »\nl’ordre des calculs. Notez bien qu’une telle remarque n’a d’importance que lorsque l’on cherche à\nmaîtriser parfaitement les erreurs de calcul.\nIl est tout à fait possible qu'une opération portant sur deux valeurs entières conduise à un\nrésultat non représentable dans le type concerné, parce que en dehors des limites permises,lesquelles, rappelons-le, dépendent de la machine employée. Dans ce cas, la plupart dutemps, on obtient un résultat aberrant : les bits excédentaires sont ignorés, le résultat est ana-logue à celui obtenu lorsque la somme de deux nombres à 3 chiffres est un nombre à quatrechiffres dont on élimine le chiffre de gauche ; l'exécution du programme se poursuit sans quel'utilisateur ait été informé d'une quelconque anomalie. Notez bien à ce propos qu’un opérateurappliqué par exemple à deux opérandes de type \nint fournit toujours un résultat de type int,\nmême s’il n’est plus représentable dans ce type et qu’un type long  aurait pu convenir.\nDe la même manière, il se peut qu'à un moment donné vous cherchiez à diviser un entier par\nzéro. Cette fois, la plupart du temps, cette anomalie est effectivement détectée : un messaged'erreur est fourni à l'utilisateur, et l'exécution du programme est interrompue.\nComme les opérations entières, les opérations sur les flottants peuvent conduire à des résultats\nnon représentables dans le type concerné (de valeur absolue trop grande ou trop petite). Dansce cas, le comportement dépend des environnements de programmation utilisés ; en particulier,il peut y avoir arrêt de l'exécution du programme. Là encore, il faut bien noter qu’un opérateurDelannoy Livre.book  Page 28  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 29chapitre n° 3 Les opérateurs et les expressions en langage C\nappliqué par exemple à deux opérandes de type float  fournit toujours un résultat de type\nfloat , même s’il n’est plus représentable dans ce type et qu’un type double  aurait pu convenir.\nEn ce qui concerne la division par zéro des flottants, elle conduit toujours à un message et à\nl'arrêt du programme.\n3Les conversions implicites pouvant intervenir dans un calcul \nd’expression\n3.1 Notion d’expression mixte\nComme nous l’avons dit, les opérateurs arithmétiques ne sont déﬁnis que lorsque leurs deux\nopérandes sont de même type. Mais vous pouvez écrire ce que l’on nomme des « expressionsmixtes » dans lesquelles interviennent des opérandes de types différents. V oici un exempled’expression autorisée, dans laquelle \nn et p sont supposés de type int, tandis que x est supposé\nde type float  :\nn * x + p\nDans ce cas, le compilateur sait, compte tenu des règles de priorité, qu’il doit d’abord effectuerle produit \nn*x. Pour que cela soit possible, il va mettre en place des instructions de conversion\nde la valeur de n dans le type float  (car on considère que ce type float  permet de repré-\nsenter à peu près convenablement une valeur entière, l’inverse étant naturellement faux). Aubout du compte, la multiplication portera sur deux opérandes de type \nfloat  et elle fournira\nun résultat de type float .\nPour l’addition, on se retrouve à nouveau en présence de deux opérandes de types différents(\nfloat  et int). Le même mécanisme sera mis en place, et le résultat ﬁnal sera de type\nfloat .\nAttention, le compilateur ne peut que prévoir les instructions de conversion (qui seront donc\nexécutées en même temps que les autres instructions du programme) ; il ne peut pas effectuer\nlui-même la conversion d’une valeur que généralement il ne peut pas connaître.\n3.2 Les conversions d’ajustement de type\nUne conversion telle que int -> float  se nomme une « conversion d’ajustement de type ».\nUne telle conversion ne peut se faire que suivant une hiérarchie qui permet de ne pas dénaturerla valeur initiale (on dit parfois que de telles conversions respectent l’intégrité des données), àsavoir :\nint -> long -> float -> double -> long doubleDelannoy Livre.book  Page 29  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n30 © Éditions EyrollesOn peut bien sûr convertir directement un int en double  ; en revanche, on ne pourra pas\nconvertir un double  en float ou en int.\nNotez que le choix des conversions à mettre en œuvre est effectué en considérant un à un les\nopérandes concernés et non pas l’expression de façon globale. Par exemple, si n est de type\nint, p de type long  et x de type float , l’expression :\nn * p + x\nsera évaluée suivant ce schéma :\n3.3 Les promotions numériques\nLes conversions d’ajustement de type ne sufﬁsent pas à régler tous les cas. En effet, commenous l’avons déjà dit, les opérateurs numériques ne sont pas déﬁnis pour les types \nchar  et\nshort .\nEn fait, le langage C prévoit tout simplement que toute valeur de l’un de ces deux types appa-raissant dans une expression est d’abord convertie en \nint, et cela sans considérer les types des\néventuels autres opérandes. On parle alors, dans ce cas, de « promotions numériques » (ouencore de « conversions systématiques »).\nPar exemple, si \np1, p2 et p3 sont de type short  et x de type float , l’expression :\np1 * p2 + p3 * x\nest évaluée comme l’indique le schéma ci-après :   n   *   p   +   x\n   |        |       | long       |       |     conversion de n en long   |        |       |   |__ *  __|       |     multiplication par p       |            |     long           |     le résultat de * est de type long       |            |     float          |     il est converti en float       |            |       |____ +  ____|     pour être additionné à x             |           float          ce qui fournit un résultat de type floatDelannoy Livre.book  Page 30  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 31chapitre n° 3 Les opérateurs et les expressions en langage C\nNotez bien que les valeurs des trois variables de type short  sont d’abord soumises à la\npromotion numérique short -> int  ; après quoi, on applique les mêmes règles que précé-\ndemment.\nEn principe, comme nous l’avons déjà dit, les types entiers peuvent être non signés ( unsigned ).\nNous y reviendrons dans le chapitre 13. Pour l’instant, sachez que nous vous déconseillons\nfortement de mélanger, dans une même expression, des types signés et des types non signés,dans la mesure où les conversions qui en résultent sont généralement dénuées de sens (et\nsimplement faites pour préserver un motif binaire).\n3.4 Le cas du type char\nA priori, vous pouvez être surpris de l’existence d’une conversion systématique (promotion\nnumérique) de char  en int et vous interroger sur sa signiﬁcation. En fait, il ne s’agit que\nd’une question de point de vue. En effet, une valeur de type caractère peut être considérée dedeux façons :\n●comme le caractère concerné : a, Z, ﬁn de ligne,\n●comme le code de ce caractère, c’est-à-dire un motif de 8 bits ; or à ce dernier on peuttoujours faire correspondre un nombre entier (le nombre qui, codé en binaire, fournit lemotif en question) ; par exemple, dans le code ASCII, le caractère \nE est représenté par\nle motif binaire 01000101 , auquel on peut faire correspondre le nombre 65.\nEffectivement, on peut dire qu’en quelque sorte le langage C confond facilement un caractèreavec la valeur (entier) du code qui le représente. Notez bien que, comme toutes les machinesn’emploient pas le même code pour les caractères, l’entier associé à un caractère donné ne serapas toujours le même. p1    *     p2    +    p3    *    x\n |           |          |          |int         int        int         |   \npromotions numériques short -> int\n |____ * ____|          |          |   addition \n       |              float        |   conversion d’ajustement de type    \n      int               |___ * ___ |   addition\n       |                     |     float                 float       \nconversion d’ajustement de type\n       |_________ + _________|                  |                floatDelannoy Livre.book  Page 31  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n32 © Éditions EyrollesV oici quelques exemples d’évaluation d’expressions, dans lesquels on suppose que c1 et c2\nsont de type char , tandis que n est de type int.\nL ’expression c1+1  fournit donc un résultat de type int, correspondant à la valeur du code du\ncaractère contenu dans c1 augmenté d’une unité.\nIci, bien que les deux opérandes soient de type char , il y a quand même conversion préalable\nde leurs valeurs en int (promotions numériques).\nThéoriquement, en plus de ce qui vient d’être dit, il faut tenir compte de l’attribut de signe des\ncaractères. Ainsi, lorsque l’on convertit un unsigned  char  en int, on obtient toujours un\nnombre entre 0 et 255, tandis que lorsque l’on convertit  un signed  char  en int, on obtient\nun nombre compris entre -127 et 128. Nous y reviendrons en détail dans le chapitre 13.\nDans la première version de C (telle qu’elle a été définie initialement par Kernighan et Ritchie,\nc’est-à-dire avant la normalisation par le comité ANSI), il était prévu une promotion numérique\nfloat  -> double . Certains compilateurs l’appliquent encore.\nLes arguments d’appel d’une fonction peuvent être également soumis à des conversions. Le\nmécanisme exact est toutefois assez complexe dans ce cas, car il tient compte de la manière   c1    +    1\n    |         |   int        |             promotion numérique char -> int    |___ + ___|         |        int\n   c1    -   c2\n    |         |   int       int            promotions numériques char -> int    |___ _ ___|         |        int\n   c1    +    n\n    |         |   int        |             promotion numérique pour c1    |___ + ___|         |        intDelannoy Livre.book  Page 32  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 33chapitre n° 3 Les opérateurs et les expressions en langage C\ndont la fonction a été déclarée dans le programme qui l’utilise (on peut trouver : aucune décla-\nration, une déclaration partielle ne mentionnant pas le type des arguments ou une déclaration\ncomplète dite prototype mentionnant le type des arguments).\nLorsque le type des arguments n’a pas été déclaré, les valeurs transmises en argument sont\nsoumises aux règles précédentes (donc, en particulier, aux promotions numériques) auxquellesil faut ajouter la promotion numérique \nfloat  -> double . Or, précisément, c’est ainsi que sont\ntraitées les valeurs que vous transmettez à printf  (ses arguments n’étant pas d’un type\nconnu à l’avance, il est impossible au compilateur d’en connaître le type !). Ainsi :\n• tout argument de type char  ou short  est converti en int ; autrement dit, le code %c s’appli-\nque aussi à un int : il affichera tout simplement le caractère ayant le code correspondant ; de\nmême on obtiendra la valeur numérique du code d’un caractère c en écrivant : printf  (\"%d\", c),\n• tout argument de type float  sera converti en double  (et cela dans toutes les versions du\nC) ; ainsi le code %f pour printf  correspond-il à un double , et il n’est pas besoin de prévoir\nun code pour un float .\n4Les opérateurs relationnels\nComme tout langage, C permet de comparer des expressions à l’aide d’opérateurs classiques\nde comparaison. En voici un exemple :\n2 * a > b + 5\nEn revanche, C se distingue de la plupart des autres langages sur deux points :\n●le résultat de la comparaison est, non pas une valeur booléenne (on dit aussi logique)prenant l’une des deux valeurs vrai ou faux, mais un entier valant :\n•0 si le résultat de la comparaison est faux,\n•1 si le résultat de la comparaison est vrai.\nAinsi, la comparaison ci-dessus devient en f ait une expr\nession de type entier . Cela signiﬁe\nqu’elle pourra éventuellement intervenir dans des calculs arithmétiques ;\n●les expressions comparées pourront être d’un type de base quelconque et elles seront soumisesaux règles de conversion présentées dans le paragraphe précédent. Cela signiﬁe qu’au boutdu compte on ne sera amené à comparer que des expressions de type numérique.\nV oici la liste des opérateurs relationnels existant en C. Remarquez bien la notation (\n==) de\nl’opérateur d’égalité, le signe = étant, comme nous le verrons, réservé aux affectations. Notez\négalement que = utilisé par mégarde à la place de == ne conduit généralement pas à un\ndiagnostic de compilation, dans la mesure où l’expression ainsi obtenue possède un sens (maisqui n’est pas celui voulu).Delannoy Livre.book  Page 33  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n34 © Éditions EyrollesEn ce qui concerne leurs priorités, il faut savoir que les quatre premiers opérateurs ( <, <=, >, >=)\nsont de même priorité. Les deux derniers ( == et !=) possèdent également la même priorité,\nmais celle-ci est inférieure à celle des précédents. Ainsi, l’expression :\na < b == c < d\nest interprétée comme :\n( a < b) == (c < d)\nce qui, en C, a effectivement une signiﬁcation, étant donné que les expressions a < b et c < d\nsont, ﬁnalement, des quantités entières. En fait, cette expression prendra la valeur 1 lorsque les\nrelations a < b et c < d auront toutes les deux la même valeur, c’est-à-dire soit lorsqu’elles\nseront toutes les deux vraies, soit lorsqu’elles seront toutes les deux fausses. Elle prendra la\nvaleur 0 dans le cas contraire.\nD’autre part, ces opérateurs relationnels sont moins prioritaires que les opérateurs arithmétiques.Cela permet souvent d’éviter certaines parenthèses dans des expressions. \nAinsi :\nx + y < a + 2\nest équivalent à :\n( x + y ) < ( a + 2 )\nimportant : comparaisons de caractères.  Compte tenu des règles de conversion, une com-\nparaison peut porter sur deux caractères. Bien entendu, la comparaison d’égalité ne pose pas\nde problème particulier ; par exemple ( c1 et c2 étant de type char ) :\nc1 == c2 sera vraie si c1 et c2 ont la même valeur, c’est-à-dire si c1 et c2 contiennent des\ncaractères de même code, donc si c1 et c2 contiennent le même caractère,\nc1 == 'e' sera vraie si le code de c1 est égal au code de 'e', donc si c1 contient le caractère e.Les opérateurs relationnels\n             OPÉRATEUR                 SIGNIFICATION\n                  <                   inférieur à                  <=                  inférieur ou égal à                  >                   supérieur à                  >=                  supérieur ou égal à                  ==                  égal à                  !=                  différent deDelannoy Livre.book  Page 34  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 35chapitre n° 3 Les opérateurs et les expressions en langage C\nAutrement dit, dans ces circonstances, l’existence d’une conversion char  --> int n’a guère\nd’influence. En revanche, pour les comparaisons d’inégalité, quelques précisions s’imposent.\nEn effet, par exemple c1 < c2 sera vraie si le code du caractère de c1 a une valeur inférieure\nau code du caractère de c2. Le résultat d’une telle comparaison peut donc varier suivant le\ncodage employé. Cependant, il faut savoir que, quel que soit ce codage :\n• l’ordre alphabétique est respecté pour les minuscules d’une part, pour les majuscules d’autre\npart ; on a toujours 'a' < 'c', 'C' < 'S'...\n• les chiffres sont classés par ordre naturel ; on a toujours '2' < '5'...\nEn revanche, aucune hypothèse ne peut être faite sur les places relatives des chiffres, desmajuscules et des minuscules, pas plus que sur la place relative des caractères accentués\n(lorsqu’ils existent) par rapport aux autres caractères !\n5Les opérateurs logiques\nC dispose de trois opérateurs logiques classiques : et (noté &&), ou (noté ||) et non (noté !).\nPar exemple :\n●(a<b) && (c<d)\nprend la valeur 1 (vrai) si les deux expressions a<b et c<d sont toutes deux vraies (de\nvaleur 1), et prend la valeur 0 (faux) dans le cas contraire.\n●(a<b) || (c<d)\nprend la valeur 1 (vrai) si l’une au moins des deux conditions a<b et c<d est vraie (de\nvaleur 1), et prend la valeur 0 (faux) dans le cas contraire.\n●! (a<b)\nprend la valeur 1 (vrai) si la condition a<b est fausse (de valeur 0) et prend la valeur 0\n(faux) dans le cas contraire. Cette expression est équivalente à : a>=b .\nIl est important de constater que, ne disposant pas de type logique, C se contente de représen-\nter vrai par 1 et faux par 0. C’est pourquoi ces opérateurs produisent un résultat numérique (de\ntype int).\nDe plus, on pourrait s’attendre à ce que les opérandes de ces opérateurs ne puissent être quedes expressions prenant soit la valeur \n0, soit la valeur 1. En fait, ces opérateurs acceptent\nn’importe quel opérande numérique , y compris les types ﬂottants, avec les règles de conver-\nsion implicite déjà rencontrées. Leur signiﬁcation reste celle évoquée ci-dessus, à condition deconsidérer que :\n●0 correspond à faux,\n●toute valeur non nulle (et donc pas seulement la valeur 1) correspond à vrai. Delannoy Livre.book  Page 35  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n36 © Éditions EyrollesLe tableau suivant récapitule la situation.\nAinsi, en C, si n et p sont des entiers, des expressions telles que :\nn && p            n || p           !n\nsont acceptées par le compilateur. Notez que l’on rencontre fréquemment l’écriture :\nif (!n)\nplus concise (mais pas forcément plus lisible) que :\nif ( n == 0 )\nL ’opérateur ! a une priorité supérieure à celle de tous les opérateurs arithmétiques binaires et\naux opérateurs relationnels. Ainsi, pour écrire la condition contraire de :\na == b\nil est nécessaire d’utiliser des parenthèses en écrivant :\n! ( a == b )\nEn effet, l’expression :\n! a == b\nserait interprétée comme :\n( ! a ) == bFonctionnement des opérateurs logiques en C\n   OPERANDE 1       OPERATEUR         OPERANDE 2       RESULTAT____________________________________________________________________\n       0                &&                0                0       0                &&             non nul             0    non nul             &&                0                0    non nul             &&             non nul             1____________________________________________________________________\n       0                ||                0                0       0                ||             non nul             1    non nul             ||                0                1    non nul             ||             non nul             1____________________________________________________________________\n                        !                 0                1                        !              non nul             0Delannoy Livre.book  Page 36  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 37chapitre n° 3 Les opérateurs et les expressions en langage C\nL ’opérateur || est moins prioritaire que &&. Tous deux sont de priorité inférieure aux opéra-\nteurs arithmétiques ou relationnels. Ainsi, les expressions utilisées comme exemples en début\nde ce paragraphe auraient pu, en fait, être écrites sans parenthèses :\na<b && c<d       équivaut à       (a<b) && (c<d)\na<b || c<d       équivaut à       (a<b) || (c<d)\nEnﬁn, les deux opérateurs && et || jouissent en C d’une propriété intéressante : leur second\nopérande (celui qui ﬁgure à droite de l’opérateur) n’est évalué que si la connaissance de sa\nvaleur est indispensable  pour décider si l’expression correspondante est vraie ou fausse. Par\nexemple, dans une expression telle que :\na<b && c<d\non commence par évaluer a<b. Si le résultat est faux ( 0), il est inutile d’évaluer c<d puisque,\nde toute façon, l’expression complète aura la valeur faux ( 0).\nLa connaissance de cette propriété est indispensable pour maîtriser des « constructions » tellesque :\nif ( i<max && ( (c=getchar()) != '\\n' ) )\nEn effet, le second opérande de l’opérateur &&, à savoir :\nc = getchar() != '\\n'\nfait appel à la lecture d’un caractère au clavier. Celle-ci n’aura donc lieu que si la premièrecondition (\ni<max ) est vraie.\n6L’opérateur d’affectation ordinaire\nNous avons déjà eu l’occasion de remarquer que :\ni = 5\nétait une expression qui :\n●réalisait une action : l’affectation de la valeur 5 à i,\n●possédait une valeur : celle de i après affectation, c’est-à-dire 5.\nCet opérateur d’affectation ( =) peut faire intervenir d’autres expressions comme dans :\nc = b + 3\nLa faible priorité de cet opérateur = (elle est inférieure à celle de tous les opérateurs arithmé-\ntiques et de comparaison) fait qu’il y a d’abord évaluation de l’expression b + 3 . La valeur\nainsi obtenue est ensuite affectée à c.Delannoy Livre.book  Page 37  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n38 © Éditions EyrollesEn revanche, il n’est pas possible de faire apparaître une expression comme premier opérande\nde cet opérateur =. Ainsi, l’expression suivante n’aurait pas de sens :\nc + 5 = x\n6.1 Notion de lvalue\nNous voyons donc que cet opérateur d’affectation impose des restrictions sur son premier opé-rande. En effet, ce dernier doit être une référence à un emplacement mémoire dont on pourraeffectivement modiﬁer la valeur.\nDans les autres langages, on désigne souvent une telle référence par le nom de « variable » ; on\nprécise généralement que ce terme recouvre par exemple les éléments de tableaux ou les com-posantes d’une structure. En langage C, cependant, la syntaxe du langage est telle que cettenotion de variable n’est pas assez précise. Il faut introduire un mot nouveau : la lvalue. Ce\nterme désigne une « valeur à gauche », c’est-à-dire tout ce qui peut apparaître à gauche d’unopérateur d’affectation.\nCertes, pour l’instant, vous pouvez trouver que dire qu’à gauche d’un opérateur d’affectation\ndoit apparaître une lvalue  n’apporte aucune information. En fait, d’une part, nous verrons\nqu’en C d’autres opérateurs que = font intervenir une lvalue ; d’autre part, au fur et à mesure\nque nous rencontrerons de nouveaux types d’objets, nous préciserons s’ils peuvent être ou nonutilisés comme lvalue .\nPour l’instant, les seules lvalue  que nous connaissons restent les variables de n’importe quel\ntype de base déjà rencontré.\n6.2 L’opérateur d’affectation possède une associativité \nde droite à gauche\nContrairement à tous ceux que nous avons rencontrés jusqu’ici, cet opérateur d’affectationpossède une associativité de droite à gauche . C’est ce qui permet à une expression telle que :\ni = j = 5\nd’évaluer d’abord l’expression j = 5  avant d’en affecter la valeur ( 5) à la variable j. Bien\nentendu, la valeur ﬁnale de cette expression est celle de i après affectation, c’est-à-dire 5.\n6.3 L’affectation peut entraîner une conversion\nLà encore, la grande liberté offerte par le langage C en matière de mixage de types se traduitpar la possibilité de fournir à cet opérateur d’affectation des opérandes de types différents.\nCette fois, cependant, contrairement à ce qui se produisait pour les opérateurs rencontrés\nprécédemment et qui mettaient en jeu des conversions implicites, il n’est plus question,ici, d’effectuer une quelconque conversion de la lvalue  qui apparaît à gauche de cet opérateur.Delannoy Livre.book  Page 38  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 39chapitre n° 3 Les opérateurs et les expressions en langage C\nUne telle conversion reviendrait à changer le type de la lvalue  ﬁgurant à gauche de cet opérateur,\nce qui n’a pas de sens.\nEn fait, lorsque le type de l’expression ﬁgurant à droite n’est pas du même type que la lvalue\nﬁgurant à gauche, il y a conversion systématique  de la valeur de l’expression (qui est évaluée\nsuivant les règles habituelles) dans le type de la lvalue . Une telle conversion imposée  ne respecte\nplus nécessairement la hiérarchie des types qui est de rigueur dans le cas des conversions\nimplicites. Elle peut donc conduire, suivant les cas, à une dégradation plus ou moins impor-tante de l’information (par exemple lorsque l’on convertit un \ndouble  en int, on perd la partie\ndécimale du nombre).\nNous ferons le point sur ces différentes possibilités de conversions imposées par les affectations\ndans le paragraphe 9.\n7Les opérateurs d’incrémentation et de décrémentation\n7.1 Leur rôle\nDans des programmes écrits dans un langage autre que C, on rencontre souvent des expres-sions (ou des instructions) telles que :\ni = i + 1\nn = n - 1\nqui incrémentent ou qui décrémentent de 1 la valeur d’une variable (ou plus généralement\nd’une lvalue ).\nEn C, ces actions peuvent être réalisées par des opérateurs « unaires » portant sur cette lvalue .\nAinsi, l’expression :\n++i\na pour effet d’incrémenter de 1 la valeur de i, et sa valeur est celle de i après incrémen-\ntation .\nLà encore, comme pour l’affectation, nous avons affaire à une expression qui non seulement\npossède une valeur, mais qui, de surcroît, réalise une action (incrémentation de i).\nIl est important de voir que la valeur de cette expression est celle de i après incrémentation.\nAinsi, si la valeur de i est 5, l’expression :\nn = ++i - 5\naffectera à i la valeur 6 et à n la valeur 1.\nEn revanche, lorsque cet opérateur est placé après la lvalue  sur laquelle il porte, la valeur de\nl’expression correspondante est celle de la variable avant incrémentation . Delannoy Livre.book  Page 39  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n40 © Éditions EyrollesAinsi, si i vaut 5, l’expression :\nn = i++ - 5\naffectera à i la valeur 6 et à n la valeur 0 (car ici la valeur de l’expression i++ est 5).\nOn dit que ++ est :\n●un opérateur de préincrémentation  lorsqu’il est placé à gauche de la lvalue  sur laquelle il\nporte,\n●un opérateur de postincrémentation  lorsqu’il est placé à droite de la lvalue  sur laquelle\nil porte.\nBien entendu, lorsque seul importe l’effet d’incrémentation d’une lvalue , cet opérateur peut\nêtre indifféremment placé avant ou après. Ainsi, ces deux instructions (ici, il s’agit bien d’ins-\ntructions car les expressions sont terminées par un point-virgule - leur valeur se trouve doncinutilisée) sont équivalentes :\n     i++ ;\n     ++i ;\nDe la même manière, il existe un opérateur de décrémentation noté -- qui, suivant les cas,\nsera :\n●un opérateur de prédécrémentation  lorsqu’il est placé à gauche de la lvalue  sur laquelle il\nporte,\n●un opérateur de postdécrémentation  lorsqu’il est placé à droite de la lvalue  sur laquelle il\nporte.\n7.2 Leurs priorités\nLes priorités élevées de ces opérateurs unaires (voir tableau en ﬁn de chapitre) permettent\nd’écrire des expressions assez compliquées sans qu’il soit nécessaire d’employer des parenthè-ses pour isoler la lvalue  sur laquelle ils portent. Ainsi, l’expression suivante a un sens :\n3 * i++ * j-- + k++\n(si * avait été plus prioritaire que la postincrémentation, ce dernier aurait été appliqué àl’expression \n3*i qui n’est pas une lvalue ; l’expression n’aurait alors pas eu de sens).\nIl est toujours possible (mais non obligatoire) de placer un ou plusieurs espaces entre un opé-\nrateur et les opérandes sur lesquels il porte. Nous utilisons souvent cette latitude pour accroître\nla lisibilité de nos instructions. Cependant, dans le cas des opérateurs d’incrémentation, nousavons plutôt tendance à ne pas le faire, cela pour mieux rapprocher l’opérateur de la lvalue sur\nlaquelle il porte.Delannoy Livre.book  Page 40  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 41chapitre n° 3 Les opérateurs et les expressions en langage C\n7.3 Leur intérêt\nCes opérateurs allègent l’écriture de certaines expressions et offrent surtout le grand avantage\nd’éviter la redondance qui est de mise dans la plupart des autres langages. En effet, dans unenotation telle que :\ni++\non ne cite qu’une seule fois la lvalue  concernée alors qu’on est amené à le faire deux fois dans\nla notation :\ni = i + 1\nLes risques d’erreurs de programmation s’en trouvent ainsi quelque peu limités. Bien entendu,cet aspect prendra d’autant plus d’importance que la lvalue  correspondante sera d’autant plus\ncomplexe. \nD’une manière générale, nous utiliserons fréquemment ces opérateurs dans la manipulation de\ntableaux ou de chaînes de caractères. Ainsi, anticipant sur les chapitres suivants, nous pouvonsindiquer qu’il sera possible de lire l’ensemble des valeurs d’un tableau nommé \nt en répétant la\nseule instruction :\nt [i++] = getchar() ;\nCelle-ci réalisera à la fois :\n●la lecture d’un caractère au clavier,\n●l’affectation de ce caractère à l’élément de rang i du tableau t,\n●l’incrémentation de 1 de la valeur de i (qui sera ainsi préparée pour la lecture du prochain\nélément).\n8Les opérateurs d’affectation élargie\nNous venons de voir comment les opérateurs d’incrémentation permettaient de simpliﬁerl’écriture de certaines affectations. Par exemple :\ni++\nremplaçait avantageusement :\ni = i + 1\nMais C dispose d’opérateurs encore plus puissants. Ainsi, vous pourrez remplacer :\ni = i + k\npar :\ni += kDelannoy Livre.book  Page 41  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n42 © Éditions Eyrollesou, mieux encore :\na = a * b\npar :\na *= b\nD’une manière générale, C permet de condenser les affectations de la forme :\nlvalue   =   lvalue   opérateur   expression\nen :\nlvalue   opérateur=   expression\nCette possibilité concerne tous les opérateurs binaires arithmétiques et de manipulation de bits.\nV oici la liste complète de tous ces nouveaux opérateurs nommés « opérateurs d’affectationélargie » :\n    +=  -=  *=  /=  %=  |=  ^=  &=  <<=  >>=\nLes cinq derniers correspondent en fait à des « opérateurs de manipulation de bits » ( |, ^, &,\n<< et >>) que nous n’aborderons que dans le chapitre 13.\nCes opérateurs, comme ceux d’incrémentation, permettent de condenser l’écriture de certai-nes instructions et contribuent à éviter la redondance introduite fréquemment par l’opérateurd’affectation classique.\nNe confondez pas l’opérateur de comparaison <= avec un opérateur d’affectation élargie.\nNotez bien que les opérateurs de comparaison ne sont pas concernés par cette possibilité.\n9Les conversions forcées par une affectation\nNous avons déjà vu comment le compilateur peut être amené à introduire des conversionsimplicites dans l’évaluation des expressions. Dans ce cas, il applique les règles de promotionsnumériques et d’ajustement de type.\nPar ailleurs, une affectation introduit une conversion d’ofﬁce dans le type de la lvalue  réceptrice,\ndès lors que cette dernière est d’un type différent de celui de l’expression correspondante.\nPar exemple, si \nn est de type int et x de type float , l’affectation :\nn = x + 5.3 ;Delannoy Livre.book  Page 42  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 43chapitre n° 3 Les opérateurs et les expressions en langage C\nentraînera tout d’abord l’évaluation de l’expression située à droite, ce qui fournira une valeur\nde type float  ; cette dernière sera ensuite convertie en int pour pouvoir être affectée à n.\nD’une manière générale, lors d’une affectation, toutes les conversions (d’un type numériquevers un autre type numérique) sont acceptées par le compilateur mais le résultat en est plus oumoins satisfaisant. En effet, si aucun problème ne se pose (autre qu’une éventuelle perte deprécision) dans le cas de conversion ayant lieu suivant le bon sens de la hiérarchie des types, iln’en va plus de même dans les autres cas.\nPar exemple, la conversion \nfloat -> int  (telle que celle qui est mise en jeu dans l’instruc-\ntion précédente) ne fournira un résultat acceptable que si la partie entière de la valeur ﬂottante\nest représentable dans le type int. Si une telle condition n’est pas réalisée, non seulement\nle résultat obtenu pourra être différent d’un environnement à un autre mais, de surcroît, onpourra aboutir, dans certains cas, à une erreur d’exécution.\nDe la même manière, la conversion d’un \nint en char  sera satisfaisante si la valeur de l’entier\ncorrespond à un code d’un caractère.Sachez, toutefois, que les conversions d’un type entier vers un autre type entier ne conduisent,\nau pis, qu’à une valeur inattendue mais jamais à une erreur d’exécution.\n10L’opérateur de cast\nS’il le souhaite, le programmeur peut forcer la conversion d’une expression quelconque dans\nun type de son choix, à l’aide d’un opérateur un peu particulier nommé en anglais « cast ».\nSi, par exemple, n et p sont des variables entières, l’expression :\n(double) ( n/p )\naura comme valeur celle de l’expression entière n/p convertie en double .\nLa notation (double)  correspond en fait à un opérateur unaire dont le rôle est d’effectuer la\nconversion  dans le type double  de l’expression sur laquelle il porte. Notez bien que cet\nopérateur force la conversion du résultat  de l’expression et non celle des différentes valeurs\nqui concourent à son évaluation. Autrement dit, ici, il y a d’abord calcul, dans le type int,\ndu quotient de n par p ; c’est seulement ensuite que le résultat sera converti en double . Si n\nvaut 10 et que p vaut 3, cette expression aura comme valeur 3.\nD’une manière générale, il existe autant d’opérateurs de « cast » que de types différents (ycompris les types dérivés comme les pointeurs que nous rencontrerons ultérieurement). Leurpriorité élevée (voir tableau en ﬁn de chapitre) fait qu’il est généralement nécessaire de placerentre parenthèses l’expression concernée. Ainsi, l’expression :\n(double) n/pDelannoy Livre.book  Page 43  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n44 © Éditions Eyrollesconduirait d’abord à convertir n en double  ; les règles de conversions implicites amèneraient\nalors à convertir p en double  avant qu’ait lieu la division (en double ). Le résultat serait\nalors différent de celui obtenu par l’expression proposée en début de ce paragraphe (avec les\nmêmes valeurs de n et de p, on obtiendrait une valeur de l’ordre de 3.33333 ...).\nBien entendu, comme pour les conversions forcées par une affectation, toutes les conversionsnumériques sont réalisables par un opérateur de « cast », mais le résultat en est plus ou moinssatisfaisant (revoyez éventuellement le paragraphe précédent).\n11L’opérateur conditionnel\nConsidérons l’instruction suivante :\nif ( a>b )\n       max = a ;   else       max = b ;\nElle attribue à la variable max la plus grande des deux valeurs de a et de b. La valeur de max\npourrait être déﬁnie par cette phrase :\nSi a>b alors a sinon b\nEn langage C, il est possible, grâce à l’aide de l’opérateur conditionnel , de traduire presque\nlittéralement la phrase ci-dessus de la manière suivante :\nmax = a>b ? a : b \nL ’expression ﬁgurant à droite de l’opérateur d’affectation est en fait constituée de trois\nexpressions ( a>b, a et b) qui sont les trois opérandes de l’opérateur conditionnel, lequel se\nmatérialise par deux symboles séparés :  ? et :.\nD’une manière générale, cet opérateur évalue la première expression qui joue le rôle d’unecondition. Comme toujours en C, celle-ci peut être en fait de n’importe quel type. Si sa valeurest différente de zéro, il y a évaluation du second opérande, ce qui fournit le résultat ; si savaleur est nulle, en revanche, il y a évaluation du troisième opérande, ce qui fournit le résultat.\nV oici un autre exemple d’une expression calculant la valeur absolue de \n3*a + 1 : \n3*a+1 > 0  ?  3*a+1 :  -3*a-1\nL ’opérateur conditionnel dispose d’une faible priorité (il arrive juste avant l’affectation), de\nsorte qu’il est rarement nécessaire d’employer des parenthèses pour en délimiter les différentsopérandes (bien que cela puisse parfois améliorer la lisibilité du programme). V oici, toutefois,un cas où les parenthèses sont indispensables :\nz = (x=y) ? a : b Delannoy Livre.book  Page 44  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 45chapitre n° 3 Les opérateurs et les expressions en langage C\nLe calcul de cette expression amène tout d’abord à affecter la valeur de y à x. Puis, si cette\nvaleur est non nulle, on affecte la valeur de a à z. Si, au contraire, cette valeur est nulle, on\naffecte la valeur de b à z.\nIl est clair que cette expression est différente de :\nz = x = y ? a : b\nlaquelle serait évaluée comme :\nz = x = ( y ? a : b )\nBien entendu, une expression conditionnelle peut, comme toute expression, apparaître à son\ntour dans une expression plus complexe. V oici, par exemple, une instruction (notez qu’il s’agiteffectivement d’une instruction, car elle se termine par un point-virgule) affectant à \nz la plus\ngrande des valeurs de a et de b :\nz = ( a>b ? a : b ) ;\nDe même, rien n’empêche que l’expression conditionnelle soit évaluée sans que sa valeur soitutilisée comme dans cette instruction :\na>b ? i++ : i-- ;\nIci, suivant que la condition a>b est vraie ou fausse, on incrémentera ou on décrémentera la\nvariable i. \n12L’opérateur séquentiel\nNous avons déjà vu qu’en C la notion d’expression était beaucoup plus générale que dans laplupart des autres langages. L ’opérateur dit « séquentiel » va élargir encore un peu plus cettenotion d’expression. En effet, celui-ci permet, en quelque sorte, d’exprimer plusieurs calculs\nsuccessifs au sein d’une même expression.  Par exemple :\na * b , i + j\nest une expression qui évalue d’abord a*b, puis i+j et qui prend comme valeur la dernière\ncalculée (donc ici celle de i+j). Certes, dans ce cas d’école, le calcul préalable de a*b est\ninutile puisqu’il n’intervient pas dans la valeur de l’expression globale et qu’il ne réaliseaucune action.\nEn revanche, une expression telle que :\ni++, a + b\npeut présenter un intérêt puisque la première expression (dont la valeur ne sera pas utilisée)\nréalise en fait une incrémentation de la variable i.Delannoy Livre.book  Page 45  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n46 © Éditions EyrollesIl en est de même de l’expression suivante :\ni++, j = i + k\ndans laquelle, il y a :\n●évaluation de l’expression i++ ,\n●évaluation de l’affectation j = i + k . Notez qu’alors on utilise la valeur de i après incré-\nmentation par l’expression précédente.\nCet opérateur séquentiel, qui dispose d’une associativité de gauche à droite, peut facilement\nfaire intervenir plusieurs expressions (sa faible priorité évite l’usage de parenthèses) :\ni++, j = i+k, j--\nCertes, un tel opérateur peut être utilisé pour réunir plusieurs instructions en une seule. Ainsi,par exemple, ces deux formulations sont équivalentes :\ni++, j = i+k, j-- ;\ni++ ; j = i+k ; j-- ;\nDans la pratique, ce n’est cependant pas là le principal usage que l’on fera de cet opérateur\nséquentiel. En revanche, ce dernier pourra fréquemment intervenir dans les instructions dechoix ou dans les boucles ; là où celles-ci s’attendent à trouver une seule expression, l’opé-rateur séquentiel permettra d’en placer plusieurs, et donc d’y réaliser plusieurs calculs ouplusieurs actions. En voici deux exemples :\nif (i++, k>0) ......\nremplace :\ni++ ; if (k>0) ......\net :\nfor (i=1, k=0 ; ... ; ... ) .......\nremplace :\ni=1 ; for (k=0 ; ... ; ... ) ......\nCompte tenu de ce que l’appel d’une fonction n’est en fait rien d’autre qu’une expression, laconstruction suivante est parfaitement valide en C :\nfor (i=1, k=0, printf(\"on commence\") ; ... ; ...) ......\nNous verrons même que, dans le cas des boucles conditionnelles, cet opérateur permet de réaliserdes constructions ne possédant pas d’équivalent simple.Delannoy Livre.book  Page 46  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 47chapitre n° 3 Les opérateurs et les expressions en langage C\n13L’opérateur sizeof\nL ’opérateur sizeof , dont l’emploi ressemble à celui d’une fonction, fournit la taille en octets\n(n’oubliez pas que l’octet est, en fait, la plus petite partie adressable de la mémoire). Par exem-\nple, dans une implémentation où le type int est représenté sur 2 octets et le type double  sur\n8 octets, si l’on suppose que l’on a affaire à ces déclarations :\n     int n ;\n     double z ;\n●l’expression sizeof(n)  vaudra 2,\n●l’expression sizeof(z)  vaudra 8.\nCet opérateur peut également s’appliquer à un type de nom donné. Ainsi, dans l’implémenta-\ntion précédemment citée :\n●sizeof(int)  vaudra 2,\n●sizeof(double)  vaudra 8.\nQuelle que soit l’implémentation, sizeof(char)  vaudra toujours 1 (par déﬁnition, en quel-\nque sorte).\nCet opérateur offre un intérêt :\n●lorsque l’on souhaite écrire des programmes portables dans lesquels il est nécessaire de\nconnaître la taille exacte de certains objets,\n●pour éviter d’avoir à calculer soi-même la taille d’objets d’un type relativement complexepour lequel on n’est pas certain de la manière dont il sera implémenté par le compilateur.Ce sera notamment le cas des structures.Delannoy Livre.book  Page 47  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n48 © Éditions Eyrolles14Récapitulatif des priorités de tous les opérateurs\nLe tableau ci-après fournit la liste complète  des opérateurs du langage C, classés par ordre de\npriorité décroissante, accompagnés de leur mode d’associativité.\nEn langage C, un certain nombre de notations servant à référencer des objets sont considérées\ncomme des opérateurs et, en tant que tels, soumises à des règles de priorité. Ce sontessentiellement :\n●les références à des éléments d’un tableau réalisées par []\n●des références à des champs d’une structure : opérateurs -> et ,\n● des opérateurs d’adressage : * et &\nCes opérateurs seront étudiés ultérieurement dans les chapitres correspondant aux tableaux,structures et pointeurs. Néanmoins, ils ﬁgurent dans le tableau proposé. De même, vous y trou-verez les opérateurs de manipulation de bits dont nous ne parlerons que dans le chapitre 13.Les opérateurs du langage C et leurs priorités\n  CATEGORIE              OPERATEURS                      ASSOCIATIVITE\n   référence             ()  []  ->  .                        --->   unaire                +   -   ++  --  !  ~  *  &           <---                         (cast)   sizeof    arithmétique          *   /   %                            --->   arithmétique          +   -                                --->   décalage              <<  >>                               --->   relationnels          <   <=   >   >=                      --->   relationnels          ==  !=                               --->   manip. de bits        &                                    --->   manip. de bits        ^                                    --->   manip de bits         |                                    --->   logique               &&                                   --->   logique               ||                                   --->   conditionnel          ? :                                  --->   affectation           =   +=  -=  *=   /=   %=             <---                         &=  ^=  |=  <<=  >>=   séquentiel            ,                                    --->Delannoy Livre.book  Page 48  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 49chapitre n° 3 Les opérateurs et les expressions en langage C\nExercices\nTous ces exercices sont corrigés en fin de volume.\n1) Soit les déclarations suivantes :\nint n = 10 , p = 4 ;\nlong q = 2 ;float x = 1.75 ;\nDonner le type et la valeur de chacune des expressions suivantes :\na)\nn + q\nb) n + x\nc) n % p +q\nd) n < p\ne)n >= p\nf) n > q\ng) q + 3 * (n > p)\nh) q && n\ni) (q-2) && (n-10)\nj) x * (q==2)\nk) x *(q=5)\n2) Écrire plus simplement l’instruction suivante :\nz = (a>b ? a : b) + (a <= b ? a : b) ;\n3) n étant de type int, écrire une expression qui prend la valeur :\n-1 si n est négatif,\n0 si n est nul,\n1 si n est positif.\n4) Quels résultats fournit le programme suivant ?\n#include <stdio.h>main(){   int n=10, p=5, q=10, r ;   r = n == (p = q) ;   printf (\"A : n = %d  p = %d  q = %d  r = %d\\n\", n, p, q, r) ;   n = p = q = 5 ;   n += p += q ;   printf (\"B : n = %d  p = %d  q = %d\\n\", n, p, q) ;   q = n < p ? n++ : p++ ;   printf (\"C : n = %d  p = %d  q = %d\\n\", n, p, q) ;   q = n > p ? n++ : p++ ;   printf (\"D : n = %d  p = %d  q = %d\\n\", n, p, q) ;}Delannoy Livre.book  Page 49  Mercredi, 6. mai 2009  4:26 16\nDelannoy Livre.book  Page 50  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 51Chapitre 4 \nLes entrées-sorties \nconversationnelles\nJusqu’ici, nous avons utilisé de façon intuitive les fonctions printf  et scanf  pour afﬁcher\ndes informations à l’écran ou pour en lire au clavier. Nous vous proposons maintenant d’étu-\ndier en détail les différentes possibilités de ces fonctions, ce qui nous permettra de répondre àdes questions telles que :\n●quelles sont les écritures autorisées pour des nombres fournis en données ? Que se passe-t-illorsque l’utilisateur ne les respecte pas ?\n●comment organiser les données lorsque l’on mélange les types numériques et les typescaractères ?\n●que se produit-il lorsque, en réponse à scanf , on fournit trop ou trop peu d’informations ?\n●comment agir sur la présentation des informations à l’écran ?\nNous nous limiterons ici à ce que nous avons appelé les « entrées-sorties conversationnelles ».Plus tard, nous verrons que ces mêmes fonctions (moyennant la présence d’un argumentsupplémentaire) permettent également d’échanger des informations avec des ﬁchiers.\nEn ce qui concerne la lecture au clavier, nous serons amené à mettre en évidence certaines\nlacunes de \nscanf en matière de comportement lors de réponses incorrectes et à vous fournir\nquelques idées sur la manière d’y remédier.Delannoy Livre.book  Page 51  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n52 © Éditions Eyrolles1Les possibilités de la fonction printf\nNous avons déjà vu que le premier argument de printf  est une chaîne de caractères qui\nspéciﬁe à la fois :\n●des caractères à afﬁcher tels quels,\n●des codes de format repérés par %. Un code de conversion (tel que c, d ou f) y précise le\ntype de l’information à afﬁcher.\nD’une manière générale, il existe d’autres caractères de conversion soit pour d’autres types de\nvaleurs, soit pour agir sur la précision de l’information que l’on afﬁche. De plus, un code deformat peut contenir des informations complémentaires agissant sur le cadrage, le gabarit oula précision. Ici, nous nous limiterons aux possibilités les plus usitées de \nprintf  . Nous avons\ntoutefois mentionné le code de conversion relatif aux chaînes (qui ne seront abordées que dansle chapitre 8) et les entiers non signés (chapitre 13). Sachez cependant que le paragraphe 1.2de l’annexe vous en fournit un panorama complet.\n1.1 Les principaux codes de conversion\ncchar  : caractère afﬁché « en clair » (convient aussi à short  ou à int compte tenu des\nconversions systématiques)\ndint (convient aussi à char  ou à int, compte tenu des conversions systématiques)\nuunsigned  int (convient aussi à unsigned  char  ou à unsigned  short , compte\ntenu des conversions systématiques)\nldlong\nluunsigned  long\nfdouble  ou float  (compte tenu des conversions systématiques float  -> double )\nécrit en notation décimale avec six chiffres après le point (par exemple : 1.234500  ou\n123.456789 )\nedouble  ou float  (compte tenu des conversions systématiques float  -> double )\nécrit en notation exponentielle (mantisse entre 1 inclus et 10 exclu) avec six chiffres\naprès le point décimal, sous la forme x.xxxxxxe+yyy  ou x.xxxxxx-yyy  pour les\nnombres positifs et -x.xxxxxxe+yyy  ou -x.xxxxxxe-yyy  pour les nombres négatifs\ns chaîne de caractères dont on fournit l’adresse (notion qui sera étudiée ultérieurement)\n1.2 Action sur le gabarit d’afﬁchage\nPar défaut, les entiers sont afﬁchés avec le nombre de caractères nécessaires (sans espacesavant ou après). Les ﬂottants sont afﬁchés avec six chiffres après le point (aussi bien pour lecode \ne que f). Delannoy Livre.book  Page 52  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 53chapitre n° 4 Les entrées-sorties conversationnelles\nUn nombre placé après % dans le code de format précise un gabarit d’afﬁchage, c’est-à-dire\nun nombre minimal  de caractères à utiliser. Si le nombre peut s’écrire avec moins de caractères,\nprintf  le fera précéder d’un nombre sufﬁsant d’espaces ; en revanche, si le nombre ne peut\ns’afﬁcher convenablement dans le gabarit imparti, printf utilisera le nombre de caractères\nnécessaires.\nV oici quelques exemples, dans lesquels nous fournissons, à la suite d’une instruction printf ,\nà la fois des valeurs possibles des expressions à afﬁcher et le résultat obtenu à l’écran. Notez\nque le symbole ^ représente un espace.\nprintf (\"%3d\", n) ;     /* entier avec 3 caractères minimum */\n    n = 20                  ^20\n    n = 3                   ^^3    n = 2358                2358    n = -5200               -5200\nprintf (\"%f\", x) ;      /* notation décimale gabarit par défaut  */\n                        /*   (6 chiffres après point)            */\n    x = 1.2345              1.234500    x = 12.3456789          12.345679\nprintf (\"%10f\", x) ;    /* notation décimale - gabarit mini 10 */\n                        /*   (toujours 6 chiffres après point) */\n    x = 1.2345              ^^1.234500    x = 12.345              ^12.345000    x = 1.2345E5            123450.000000\nprintf (\"%e\", x) ;  /* notation exponentielle - gabarit par défaut */\n                    /*      (6 chiffres après point)               */\n    x = 1.2345              1.234500e+000    x = 123.45              1.234500e+002    x = 123.456789E8        1.234568e+010    x = -123.456789E8       -1.234568e+010\n1.3 Actions sur la précision\nPour les types ﬂottants, on peut spéciﬁer un nombre de chiffres (éventuellement inférieur à 6)\naprès le point décimal (aussi bien pour la notation décimale que pour la notation exponentielle).Ce nombre doit apparaître, précédé d’un point, avant le code de format (et éventuellementaprès le gabarit). Delannoy Livre.book  Page 53  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n54 © Éditions EyrollesV oici quelques exemples :\nprintf (\"%10.3f\", x) ;  /* notation décimale, gabarit mini 10 */\n                        /*    et 3 chiffres après point       */\n    x = 1.2345               ^^^^^1.235\n    x = 1.2345E3             ^^1234.500    x = 1.2345E7             12345000.000\nprintf (\"%12.4e\", x) ;  /* notation exponentielle, gabarit mini 12*/\n                        /*    et 4 chiffres après point           */\n    x = 1.2345               ^1.2345e+000    x = 123.456789E8         ^1.2346e+010\nLe signe moins ( -), placé immédiatement après le symbole % (comme dans %-4d  ou %-10.3f ),\ndemande de cadrer l’affichage à gauche au lieu de le cadrer (par défaut) à droite ; les éven-\ntuels espaces supplémentaires sont donc placés à droite et non plus à gauche de l’informationaffichée.\nLe caractère * figurant à la  place d’un gabarit ou d’une précision signifie que la valeur effective\nest fournie dans la liste des arguments de printf . En voici un exemple dans lequel nous appli-\nquons ce mécanisme à la précision :\n       printf (\"%8.*f\", n, x) ;\n       n = 1    x = 1.2345                ^^^^1.2 \n       n = 3    x = 1.2345                ^^^1.234\nLa fonction printf  fournit en fait une valeur de retour. Il s’agit du nombre de caractères qu’elle\na réellement affichés (ou la valeur -1 en cas d’erreur). Par exemple, avec l’instruction suivante,\non s’assure que l’opération d’affichage s’est bien déroulée :\n       if (printf (\"....\", ...) != -1 ) .....\nDe même, on obtient le nombre de caractères effectivement affichés par :\n       n = printf (\"....\", ....)  \n1.4 La syntaxe de printf\nD’une manière générale, nous pouvons dire que l’appel à printf  se présente ainsi :\nLa fonction printf\n     printf  ( format,  liste_d’expressions )Delannoy Livre.book  Page 54  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 55chapitre n° 4 Les entrées-sorties conversationnelles\n●format  :\n•constante chaîne (entre \" \"),\n•pointeur sur une chaîne de caractères (cette notion sera étudiée ultérieurement).\n●liste_d’expressions  : suite d’expressions séparées par des virgules d’un type en\naccord avec le code format correspondant.\nNous verrons que les deux notions de constante chaîne et de pointeur sur une chaîne sont\nidentiques.\n1.5 En cas d’erreur de programmation\nDeux types d’erreur de programmation peuvent apparaître dans l’emploi de printf .\na) code de format en désaccord avec le type de l’expression\nLorsque le code de format, bien qu’erroné, correspond à une information de même taille\n(c’est-à-dire occupant la même place en mémoire) que celle relative au type de l’expression,\nles conséquences de l’erreur se limitent à une mauvaise interprétation de l’expression . C’est\nce qui se passe, par exemple, lorsque l’on écrit une valeur de type int en %u ou une valeur de\ntype unsigned int  en %d.\nEn revanche, lorsque le code format correspond à une information de taille différente  de celle\nrelative au type de l’expression, les conséquences sont généralement plus désastreuses, dumoins si d’autres valeurs doivent être afﬁchées à la suite. En effet, tout se passe alors commesi, dans la suite d’octets (correspondant aux différentes valeurs à afﬁcher) reçue par \nprintf ,\nle repérage des emplacements des valeurs suivantes se trouvait soumis à un décalage.\nb) nombre de codes de format différent du nombre d’expressions  \nde la liste\nDans ce cas, il faut savoir que C cherche toujours à satisfaire le contenu du format .\nCe qui signiﬁe que, si des expressions de la liste n’ont pas de code format, elles ne seront pasafﬁchées. C’est le cas dans cette instruction où la valeur de \np ne sera pas afﬁchée :\nprintf (\"%d\", n, p) ;\nEn revanche, si vous prévoyez trop de codes de format, les conséquences seront là encoreassez désastreuses puisque \nprintf  cherchera à afﬁcher n’importe quoi. C’est le cas dans\ncette instruction où deux valeurs seront afﬁchées, la seconde étant (relativement) aléatoire :\nprintf (\"%d %d \", n) ;Delannoy Livre.book  Page 55  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n56 © Éditions Eyrolles1.6 La macro putchar\nL ’expression :\nputchar (c)\njoue le même rôle que :\nprintf (\"%c\", c)\nSon exécution est toutefois plus rapide, dans la mesure où elle ne fait pas appel au mécanisme\nd’analyse de format. Notez qu’en toute rigueur putchar  n’est pas une vraie fonction mais une\nmacro. Ses instructions (écrites en C) seront incorporées à votre programme par la directive :\n#include <stdio.h>\nAlors que cette directive était facultative pour printf (qui est une fonction), elle devient\nabsolument nécessaire pour putchar . En son absence, l’éditeur de liens serait amené à\nrechercher une fonction putchar en bibliothèque et, ne la trouvant pas, il vous gratiﬁerait\nd’un message d’erreur  En toute rigueur, la fonction recherchée pourra porter un nom légèrementdifférent, par exemple \n_putchar  ; c’est ce nom qui ﬁgurera dans le message d’erreur fourni\npar l’éditeur de liens.\n2 Les possibilités de la fonction scanf\nNous avons déjà rencontré quelques exemples d’appels de scanf . Nous y avons notamment\nvu la nécessité de recourir à l’opérateur & pour désigner l’adresse de la variable (plus généra-\nlement de la lvalue ) pour laquelle on souhaite lire une valeur. V ous avez pu remarquer que\ncette fonction possédait une certaine ressemblance avec printf  et qu’en particulier elle faisait,\nelle aussi, appel à des « codes de format ».\nCependant, ces ressemblances masquent également des différences assez importantes au niveau :\n●de la signiﬁcation des codes de format. Certains codes correspondront à des types diffé-\nrents, suivant qu’ils sont employés avec printf  ou avec scanf  ;\n●de l’interprétation des caractères du format qui ne font pas partie d’un code de format.\nIci, nous allons vous montrer le fonctionnement de scanf . Comme nous l’avons fait pour\nprintf , nous vous présenterons d’abord les principaux codes de conversion. (Le paragraphe 1.2\nde l’annexe vous en fournira un panorama complet). Là encore, nous avons également mentionnéles codes de conversion relatifs aux chaînes et aux entiers non signés.\nEn revanche, compte tenu de la complexité de \nscanf , nous vous en exposerons les différentes\npossibilités de façon progressive, à l’aide d’exemples. Notamment, ce n’est qu’à la ﬁn de ce\nchapitre que vous serez en mesure de connaître toutes les conséquences de données incorrectes.Delannoy Livre.book  Page 56  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 57chapitre n° 4 Les entrées-sorties conversationnelles\n2.1 Les principaux codes de conversion de scanf\nPour chaque code de conversion, nous précisons le type de la lvalue  correspondante.\nc char\nd int\nu unsigned  int\nhd short  int\nhu unsigned  short\nld long  int\nlu unsigned  long\nf ou eloat  écrit indifféremment dans l’une des deux notations : décimale (éventuel-\nlement sans point, c’est-à-dire comme un entier) ou exponentielle (avec la lettre e\nou E)\nlf ou ledouble  avec la même présentation que ci-dessus\ns chaîne de caractères dont on fournit l’adresse (notion qui sera étudiée ultérieurement)\nContrairement à ce qui se passait pour printf , il ne peut plus y avoir ici de conversion auto-\nmatique puisque l’argument transmis à scanf  est l’adresse d’un emplacement mémoire. C’est\nce qui justifie l’existence d’un code hd par exemple pour le type short  ou encore celle des\ncodes lf et le pour le type double .\n2.2 Premières notions de tampon et de séparateurs\nLorsque scanf  attend que vous lui fournissiez des données, l’information frappée au clavier\nest rangée temporairement dans l’emplacement mémoire nommé « tampon ». Ce dernier est\nexploré, caractère par caractère par scanf , au fur et à mesure des besoins. Il existe un pointeur\nqui précise quel est le prochain caractère à prendre en compte.\nD’autre part, certains caractères dits « séparateurs » (ou « espaces blancs ») jouent un rôle parti-\nculier dans les données. Les deux principaux sont l’espace et la ﬁn de ligne ( \\n). Il en existe\ntrois autres d’un usage beaucoup moins fréquent : la tabulation horizontale ( \\t), la tabulation\nverticale (\\v) et le changement de page ( \\f).\n2.3 Les premières règles utilisées par scanf\nLes codes de format correspondant à un nombre (c’est-à-dire tous ceux de la liste précédente,excepté \n%c et %s) entraînent d’abord l’avancement éventuel du pointeur jusqu’au premier\ncaractère différent d’un séparateur. Puis scanf  prend en compte tous les caractères suivants\njusqu’à la rencontre d’un séparateur (en y plaçant le pointeur), du moins lorsque aucun gabaritDelannoy Livre.book  Page 57  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n58 © Éditions Eyrollesn’est précisé (comme nous apprendrons à le faire dans le paragraphe 2.4) et qu’aucun carac-\ntère invalide n’est présent dans la donnée (nous y reviendrons au paragraphe 2.6).\nQuant au code de format %c, il entraîne la prise en compte du caractère désigné par le pointeur\n(même s’il s’agit d’un séparateur comme espace ou ﬁn de ligne), et le pointeur est simplement\navancé sur le caractère suivant du tampon.\nV oici quelques exemples dans lesquels nous supposons que n et p sont de type int, tandis que\nc est de type char . Nous fournissons, pour chaque appel de scanf , des exemples de réponses\npossibles (^ désigne un espace et @ une ﬁn de ligne) et, en regard, les valeurs effectivement lues.\nscanf (\"%d%d\", &n, &p) ;\n    12^25@            n = 12     p = 25\n    ^12^^25^^@        n = 12     p = 25\n    12@\n    @    ^25@              n = 12     p = 25\nscanf (\"%c%d\", &c, &n) ;\n    a25@              c = 'a'    n = 25    a^^25@            c = 'a'    n = 25\nscanf (\"%d%c\", &n, &c) ;\n    12 a@             n = 12     c = ' '\nNotez que, dans ce cas, on obtient bien le caractère « espace » dans c. Nous verrons dans le\nparagraphe 2.5 comment imposer à scanf  de sauter quand même les espaces dans ce cas.\nLe code de format précise la nature du travail à effectuer pour transcoder une partie de l’infor-\nmation frappée au clavier, laquelle n’est en fait qu’une suite de caractères (codés chacun sur\nun octet) pour fabriquer la valeur (binaire) de la variable correspondante. Par exemple, %d\nentraîne en quelque sorte une double conversion : suite de caractères -> nombre écrit en déci-mal -> nombre codé en binaire ; la première conversion revient à faire correspondre un nombreentre 0 et 9 à un caractère représentant un chiffre. En revanche, le code \n%c demande simple-\nment de ne rien faire puisqu’il suffit de recopier tel quel l’octet contenant le caractère concerné.\n2.4 Imposition d’un gabarit maximal\nComme dans les codes de format de printf , on peut, dans un code de format de scanf ,\npréciser un gabarit. Dans ce cas, le traitement d’un code de format s’interrompt soit à la ren-\ncontre d’un séparateur, soit lorsque le nombre de caractères indiqués a été atteint (attention, lesséparateurs éventuellement sautés auparavant ne sont pas comptabilisés !). Delannoy Livre.book  Page 58  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 59chapitre n° 4 Les entrées-sorties conversationnelles\nV oici un exemple :\nscanf (\"%3d%3d\", &n, &p)\n    12^25@                   n = 12   p = 25\n    ^^^^^12345@              n = 123  p = 45    12@\n    25@                      n = 12   p = 25\n2.5 Rôle d’un espace dans le format\nUn espace entre deux codes de format demande à scanf  de faire avancer le pointeur au pro-\nchain caractère différent d’un séparateur. Notez que c’est déjà ce qui se passe lorsque l’on a\naffaire à un code de format correspondant à un type numérique. En revanche, cela n’était pasle cas pour les caractères, comme nous l’avons vu au paragraphe 2.3.\nV oici un exemple :\nscanf (\"%d^%c\", &n, &c) ;   /* ^ désigne un espace         */\n                            /* %d^%c est différent de %d%c */\n    12^a@              n = 12   c = 'a'\n    12^^^a@            n = 12   c = 'a'    12@a@              n = 12   c = 'a'\n2.6 Cas où un caractère invalide apparaît dans une donnée\nV oyez cet exemple, accompagné des valeurs obtenues dans les variables concernées :\nscanf (\"%d^%c\", &n, &c) ;     /* ^ désigne un espace */\n    12a@               n = 12   c = 'a'\nCe cas fait intervenir un mécanisme que nous n’avons pas encore rencontré. Il s’agit d’un troi-\nsième critère d’arrêt du traitement d’un code format (les deux premiers étaient : rencontred’un séparateur ou gabarit atteint).\nIci, lors du traitement du code \n%d, scanf  rencontre les caractères 1, puis 2, puis a. Ce caractère\na ne convenant pas à la fabrication d’une valeur entière, scanf  interrompt son exploration et\nfournit donc la valeur 12 pour n. L ’espace qui suit %d dans le format n’a aucun effet puisque le\ncaractère courant est le caractère a (différent d’un séparateur). Le traitement du code suivant,\nc’est-à-dire %c, amène scanf  à prendre ce caractère courant ( a) et à l’affecter à la variable c.\nD’une manière générale, dans le traitement d’un code de format, scanf  arrête son exploration\ndu tampon dès que l’une des trois conditions est satisfaite :\n●rencontre d’un caractère séparateur,Delannoy Livre.book  Page 59  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n60 © Éditions Eyrolles●gabarit maximal atteint (s’il y en a un de spéciﬁé),\n●rencontre d’un caractère invalide, par rapport à l’usage qu’on veut en faire (par exemple un\npoint pour un entier, une lettre autre que E ou e pour un ﬂottant,...). Notez bien l’aspect\nrelatif de cette notion de caractère invalide.\n2.7 Arrêt prématuré de scanf\nV oyez cet exemple, dans lequel nous utilisons, pour la première fois, la valeur de retour de la\nfonction scanf .\ncompte = scanf (\"%d^%d^%c\", &n, &p, &c) ;     /* ^ désigne un espace */\n12^25^b@    n = 12        p = 25        c = 'b'        compte = 3\n12b@        n = 12        p inchangé    c inchangé     compte = 1b@          n indéfini    p inchangé    c inchangé     compte = 0\nLa valeur fournie par scanf  n’est pas comparable à celle fournie par printf  puisqu’il s’agit\ncette fois du nombre de valeurs convenablement lues . Ainsi, dans le premier cas, il n’est pas\nsurprenant de constater que cette valeur est égale à 3.\nEn revanche, dans le deuxième cas, le caractère b a interrompu le traitement du premier code %d.\nDans le traitement du deuxième code ( %d), scanf  a rencontré d’emblée ce caractère b, toujours\ninvalide pour une valeur numérique. Dans ces conditions, scanf se trouve dans l’incapacité\nd’attribuer une valeur à p (puisque ici, contrairement à ce qui s’est passé pour n, elle ne dispose\nd’aucun caractère correct). Dans un tel cas, scanf s’interrompt sans chercher à lire d’autres\nvaleurs et fournit, en retour, le nombre de valeurs correctement lues jusqu’ici, c’est-à-dire 1. Les\nvaleurs de p et de c restent inchangées (éventuellement indéﬁnies).\nDans le troisième cas, le même mécanisme d’arrêt prématuré se produit dès le traitement du\npremier code de format, et le nombre de valeurs correctement lues est 0.\nNe confondez pas cet arrêt prématuré de scanf  avec le troisième critère d’arrêt de traite-\nment d’un code de format.  En effet, les deux situations possèdent bien la même cause (un\ncaractère invalide par rapport à l’usage que l’on souhaite en faire), mais seul le cas où scanf\nn’est pas en mesure de fabriquer une valeur conduit à l’arrêt prématuré.\nIci, nous avons vu la signification d’un espace introduit entre deux codes de format. En toute\nrigueur, vous pouvez introduire à un tel endroit n’importe quel caractère de votre choix. Dans\nce cas, sachez que lorsque scanf rencontre un caractère ( x par exemple) dans le format,\nil le compare avec le caractère courant (celui désigné par le pointeur) du tampon. S’ils sontégaux, il poursuit son travail (après avoir avancé le pointeur) mais, dans le cas contraire, ily a arrêt prématuré . Une telle possibilité ne doit toutefois être réservée qu’à des cas bien\nparticuliers.Delannoy Livre.book  Page 60  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 61chapitre n° 4 Les entrées-sorties conversationnelles\n2.8 La syntaxe de scanf\nD’une manière générale, l’appel de scanf  se présente ainsi :\n●format  :\n•constante chaîne (entre \" \"),\n•pointeur sur une chaîne de caractères (cette notion sera étudiée ultérieurement).\n●liste_d_adresses  : liste de lvalue , séparées par des virgules, d’un type en accord avec\nle code de format correspondant.\n2.9 Problèmes de synchronisation entre l’écran et le clavier\nV oyez cet exemple de programme accompagné de son exécution alors que nous avons répondu :\n12^25@\nà la première question posée.La fonction scanf\n        scanf (format, liste_d_adresses)\nL’écran et le clavier semblent mal synchronisés\n#include <stdio.h>\nmain(){    int n, p ;    printf (\"donnez une valeur pour n : \") ;    scanf (\"%d\", &n) ;    printf (\"merci pour %d\\n\", n) ;    printf (\"donnez une valeur pour p : \") ;    scanf (\"%d\", &p) ;    printf (\"merci pour %d\", p) ;}\n    donnez une valeur pour n : 12 25\n    merci pour 12    donnez une valeur pour p : merci pour 25Delannoy Livre.book  Page 61  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n62 © Éditions EyrollesV ous constatez que la seconde question (donnez une valeur pour p) est apparue à l’écran, mais\nle programme n’a pas attendu que vous frappiez votre réponse pour vous afﬁcher la suite. V ous\nnotez alors qu’il a bien pris pour p la seconde valeur entrée au préalable, à savoir 25.\nEn fait, comme nous l’avons vu, les informations frappées au clavier ne sont pas traitées ins-tantanément par \nscanf  mais mémorisées dans un tampon. Jusqu’ici, cependant, nous n’avi-\nons pas précisé quand scanf s’arrêtait de mémoriser pour commencer à traiter. Il le fait tout\nnaturellement à la rencontre d’un caractère de ﬁn de ligne généré par la frappe de la touche« return », dont le rôle est aussi classiquement celui d’une validation. Notez que, bien qu’iljoue le rôle d’une validation, ce caractère de ﬁn de ligne est quand même recopié dans letampon ; il pourra donc éventuellement être lu en tant que tel.\nL ’élément nouveau réside donc dans le fait que \nscanf  reçoit une information découpée en\nlignes (nous appelons ainsi une suite de caractères terminée par une ﬁn de ligne). Tant que son\ntraitement n’est pas terminé, elle attend une nouvelle ligne (c’est d’ailleurs ce qui se produisaitdans notre premier exemple dans lequel nous commencions par frapper « return »).\nPar contre, lorsque son traitement est terminé, s’il existe une partie de ligne non encore utilisée,\ncelle-ci est conservée pour une prochaine lecture.\nAutrement dit, le tampon n’est pas vidé à chaque nouvel appel de \nscanf . C’est ce qui explique\nle comportement du programme précédent.\n2.10 En cas d’erreur\nDans le cas de printf , la source unique d’erreur résidait dans les fautes de programmation.\nDans le cas de scanf , en revanche, il peut s’agir, non seulement d’une faute de programma-\ntion, mais également d’une mauvaise réponse de l’utilisateur.\n2.10.1 Erreurs de programmation\nComme dans le cas de printf , ces erreurs peuvent être de deux types :\na) Code de format en désaccord avec le type de l’expression\nSi le code de format, bien qu’erroné, correspond à un type de longueur égale à celle de la\nlvalue  mentionnée dans la liste, les conséquences se limitent, là encore, à l’introduction\nd’une mauvaise valeur. Si, en revanche, la lvalue  a une taille inférieure à celle correspon-\ndant au type mentionné dans le code format, il y aura écrasement d’un emplacementmémoire consécutif à cette lvalue . Les conséquences en sont difﬁcilement prévisibles.\nb) Nombre de codes de format différent du nombre d’éléments de la liste\nComme dans le cas de \nprintf , il faut savoir que scanf cherche toujours à satisfaire le\ncontenu du format . Les conséquences sont limitées dans le cas où le format comporte\nmoins de codes que la liste ; ainsi, dans cette instruction, on ne cherchera à lire que lavaleur de \nn :\n       scanf (\"%d\", &n, &p) ;Delannoy Livre.book  Page 62  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 63chapitre n° 4 Les entrées-sorties conversationnelles\nEn revanche, dans le cas où le format comporte plus de codes que la liste, on cherchera à\naffecter des valeurs à des emplacements (presque) aléatoires de la mémoire. Là encore, lesconséquences en seront pratiquement imprévisibles.\n2.10.2 Mauvaise réponse de l’utilisateur\nNous avons déjà vu ce qui se passait lorsque l’utilisateur fournissait trop ou trop peu d’infor-mation par rapport à ce qu’attendait \nscanf .\nDe même, nous avons vu comment, en cas de rencontre d’un caractère invalide, il y avait arrêtprématuré. Dans ce cas, il faut bien voir que ce caractère non exploité reste dans le tamponpour une prochaine fois. Cela peut conduire à des situations assez cocasses telles que celle quiest présentée dans cet exemple (l’impression de \n^C représente, dans l’environnement utilisé,\nune interruption du programme par l’utilisateur) :\nFort heureusement, il existe un remède à cette situation. Nous ne pourrons vous l’exposer\ncomplètement que lorsque nous aurons étudié les chaînes de caractères.Boucle infinie sur un caractère invalide\nmain()\n{     int n ;   do      { printf (\"donnez un nombre : \") ;        scanf (\"%d\", &n) ;        printf (\"voici son carré : %d\\n\", n*n) ;      }   while (n) ;}\n   donnez un nombre : 12\n   voici son carré : 144   donnez un nombre : &   voici son carré : 144   donnez un nombre : voici son carré : 144   donnez un nombre : voici son carré : 144   donnez un nombre : voici son carré : 144   donnez un nombre : voici son carré : 144    ^CDelannoy Livre.book  Page 63  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n64 © Éditions Eyrolles2.11 La macro getchar\nL ’expression :\nc = getchar()\njoue le même rôle que :\nscanf (\"%c\", &c)\ntout en étant plus rapide puisque ne faisant pas appel au mécanisme d’analyse d’un format.\nNotez bien que getchar utilise le même tampon (image d’une ligne) que scanf . \nEn toute rigueur, getchar  est une macro (comme putchar ) dont les instructions ﬁgurent\ndans stdio.h . Là encore, l’omission d’une instruction #include  appropriée conduit à une\nerreur à l’édition de liens.Delannoy Livre.book  Page 64  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 65chapitre n° 4 Les entrées-sorties conversationnelles\nExercices\nTous ces exercices sont corrigés en fin de volume.\n1) Quels seront les résultats fournis par ce programme ?\n#include <stdio.h>\nmain (){   int n = 543 ;    int p = 5 ;    float x = 34.5678;    printf (\"A : %d %f\\n\", n, x) ;    printf (\"B : %4d %10f\\n\", n, x) ;    printf (\"C : %2d %3f\\n\", n, x) ;    printf (\"D : %10.3f %10.3e\\n\", x, x) ;    printf (\"E : %*d\\n\", p, n) ;    printf (\"F : %*.*f\\n\", 12, 5, x) ;}\n2) Quelles seront les valeurs lues dans les variables n et p (de type int), par l’instruction\nsuivante ?\nscanf (\"%4d %2d\", &n, &p) ;\nlorsqu’on lui fournit les données suivantes (le symbole \n^ représente un espace et le symbole @\nreprésente une fin de ligne, c’est-à-dire une validation) ?\na) 12^45@    b) 123456@    c) 123456^7@d) 1^458@    e) ^^^4567^^8912@Delannoy Livre.book  Page 65  Mercredi, 6. mai 2009  4:26 16\nDelannoy Livre.book  Page 66  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 67Chapitre 5 \nLes instructions de contrôle\nA priori, dans un programme, les instructions sont exécutées séquentiellement, c’est-à-dire\ndans l’ordre où elles apparaissent. Or la puissance et le « comportement intelligent » d’unprogramme proviennent essentiellement :\n●de la possibilité d’effectuer des choix, de se comporter différemment suivant les circonstan-\nces (celles-ci pouvant être, par exemple, une réponse de l’utilisateur, un résultat de calcul...),\n●de la possibilité d’effectuer des boucles , autrement dit de répéter plusieurs fois un ensemble\ndonné d’instructions.\nTous les langages disposent d’instructions, nommées instructions de contrôle , permettant de\nréaliser ces choix ou ces boucles. Suivant le cas, celles-ci peuvent être :\n●basées essentiellement sur la notion de branchement (conditionnel ou inconditionnel) ;c’était le cas, par exemple, des premiers Basic,\n●ou, au contraire, traduire ﬁdèlement les structures fondamentales de la programmationstructurée ; cela était le cas, par exemple, du langage Pascal bien que, en toute rigueur, cedernier dispose d’une instruction de branchement inconditionnel GOTO.\nSur ce point, le langage C est quelque peu hybride. En effet d’une part, il dispose d’instructionsstructurées permettant de réaliser :\n●des choix : instructions if...else  et switch ,\n●des boucles : instructions do...while , while  et for.Delannoy Livre.book  Page 67  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n68 © Éditions EyrollesMais, d’autre part, la notion de branchement n’en est pas totalement absente puisque, comme\nnous le verrons :\n●il dispose d’instructions de branchement inconditionnel : goto , break  et continue ,\n●l’instruction switch  est en fait intermédiaire entre un choix multiple parfaitement struc-\nturé (comme dans Pascal) et un aiguillage multiple (comme dans Fortran).\nCe sont ces différentes instructions de contrôle du langage C que nous nous proposons d’étudierdans ce chapitre.\n1L’instruction if\nNous avons déjà rencontré des exemples d’instruction if et nous avons vu que cette dernière\npouvait éventuellement faire intervenir un bloc. Précisons donc tout d’abord ce qu’est un blocd’une manière générale.\n1.1 Blocs d’instructions\nUn bloc est une suite d’instructions placées entre { et }. Les instructions ﬁgurant dans un bloc\nsont absolument quelconques. Il peut s’agir aussi bien d’instructions simples (terminées parun point-virgule) que d’instructions structurées (choix, boucles) lesquelles peuvent alors à leurtour renfermer d’autres blocs. \nRappelons qu’en C, la notion d’instruction est en quelque sorte récursive. Dans la description\nde la syntaxe des différentes instructions, nous serons souvent amené à mentionner ce termed’instruction . Comme nous l’avons déjà noté, celui-ci désignera toujours n’importe quelle\ninstruction C : simple , structurée  ou un bloc.\nUn bloc peut se réduire à une seule instruction, voire être vide. V oici deux exemples de blocscorrects :\n{ }\n{ i = 1 ; }\nLe second bloc ne présente aucun intérêt en pratique puisqu’il pourra toujours être remplacé\npar l’instruction simple qu’il contient.\nEn revanche, nous verrons que le premier bloc (lequel pourrait a priori être remplacé par...\nrien) apportera une meilleure lisibilité dans le cas de boucles ayant un corps vide.\nNotez encore que { ; } est un bloc constitué d’une seule instruction vide, ce qui est syntaxi-\nquement correct.Delannoy Livre.book  Page 68  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 69chapitre n° 5 Les instructions de contrôle\nImportant. N’oubliez pas que toute instruction simple est toujours terminée par un point-\nvirgule. Ainsi, ce bloc :\n{ i = 5 ; k = 3 }\nest incorrect car il manque un point-virgule à la fin de la seconde instruction.\nD’autre part, un bloc joue le même rôle syntaxique qu’une instruction simple (point-virgule\ncompris). Évitez donc d’ajouter des points-virgules intempestifs à la suite d’un bloc.\n1.2 Syntaxe de l’instruction if\nLe mot else  et l’instruction qu’il introduit sont facultatifs, de sorte que cette instruction if\nprésente deux formes.\n●expression  : expression quelconque\n●instruction_1  et instruction_2  : instructions quelconques, c’est-à-dire :\n•simple (terminée par un point-virgule),\n•bloc,\n•instruction structurée.\nLa syntaxe de cette instruction n’impose en soi aucun point-virgule, si ce n’est ceux qui termi-\nnent naturellement les instructions simples qui y figurent.\n1.3 Exemples\nL ’expression conditionnant le choix est quelconque. La richesse de la notion d’expression en C\nfait que celle-ci peut elle-même réaliser certaines actions. Ainsi :\n     if ( ++i < limite)  printf (\"OK\") ;\nest équivalent à :\n     i = i + 1 ;\n     if ( i < limite )  printf (\"OK\") ;L’instruction if\n     if (expression)                       if (expression)\n             instruction_1                           instruction_1         else             instruction_2Delannoy Livre.book  Page 69  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n70 © Éditions EyrollesPar ailleurs :\n     if ( i++ < limite ) ......\nest équivalent à :\n     i = i + 1 ;\n     if ( i-1 < limite ) ......\nDe même :\n     if ( ( c=getchar() ) != '\\n' ) ......\npeut remplacer :\n     c = getchar() ;     if ( c != '\\n' ) ......\nEn revanche :\n     if ( ++i<max && ( (c=getchar()) != '\\n') ) ......\nn’est pas équivalent à :\n     ++i ;     c = getchar() ;     if ( i<max && ( c!= '\\n' ) ) ......\ncar, comme nous l’avons déjà dit, l’opérateur && n’évalue son second opérande que lorsque\ncela est nécessaire. Autrement dit, dans la première formulation, l’expression :\nc = getchar()\nn’est pas évaluée lorsque la condition ++i<max  est fausse ; elle l’est, en revanche, dans la\ndeuxième formulation.\n1.4 Imbrication des instructions if\nNous avons déjà mentionné que les instructions ﬁgurant dans chaque partie du choix d’une\ninstruction pouvaient être absolument quelconques. En particulier, elles peuvent, à leur tour,renfermer d’autres instructions \nif. Or, compte tenu de ce que cette instruction peut comporter\nou ne pas comporter de else , il existe certaines situations où une ambiguïté apparaît. C’est le\ncas dans cet exemple :\n    if (a<=b)  if (b<=c)  printf (\"ordonné\") ;\n              else printf (\"non ordonné\") ;\nEst-il interprété comme le suggère cette présentation ?\n    if (a<=b)  if (b<=c) printf (\"ordonné\") ;         else  printf (\"non ordonné\") ;Delannoy Livre.book  Page 70  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 71chapitre n° 5 Les instructions de contrôle\nou bien comme le suggère celle-ci ?\n    if (a<=b) if (b<=c) printf (\"ordonné\") ;\n                   else printf (\"non ordonné\") ;\nLa première interprétation conduirait à afﬁcher \"non ordonné\"  lorsque la condition a<=b\nest fausse, tandis que la seconde n’afﬁcherait rien dans ce cas. La règle adoptée par le langage\nC pour lever une telle ambiguïté est la suivante :\nUn else  se rapporte toujours au dernier if rencontré auquel un else  n’a pas encore\nété attribué.Dans notre exemple, c’est la seconde présentation qui suggère le mieux ce qui se passe. V oici un exemple d’utilisation de \nif imbriqués. Il s’agit d’un programme de facturation avec\nremise. Il lit en donnée un simple prix hors taxes et calcule le prix TTC correspondant (avec un\ntaux de TV A constant de 18,6 %). Il établit ensuite une remise dont le taux dépend de la valeurainsi obtenue, à savoir :\n●0 % pour un montant inférieur à 1 000 F\n●1 % pour un montant supérieur ou égal à 1 000 F et inférieur à 2 000 F\n●3 % pour un montant supérieur ou égal à 2 000 F et inférieur à 5 000 F\n●5 % pour un montant supérieur ou égal à 5 000 F\nCe programme est accompagné de deux exemples d’exécution.\nExemple de if imbriqués : facturation avec remise \n#define TAUX_TVA  18.6\nmain(){   double ht, ttc, net, tauxr, remise ;   printf(\"donnez le prix hors taxes : \") ;   scanf (\"%lf\", &ht) ;\n   ttc = ht * ( 1. + TAUX_TVA/100.) ;\n   if ( ttc < 1000.)            tauxr = 0 ;      else if ( ttc < 2000 )    tauxr = 1. ;         else if ( ttc < 5000 ) tauxr = 3. ;            else                tauxr = 5. ;\n   remise = ttc * tauxr / 100. ;\n   net = ttc - remise ;   printf (\"prix ttc     %10.2lf\\n\", ttc) ;   printf (\"remise       %10.2lf\\n\", remise) ;   printf (\"net à payer  %10.2lf\\n\", net) ;}Delannoy Livre.book  Page 71  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n72 © Éditions Eyrolles2Instruction switch\n2.1 Exemples d’introduction de l’instruction switch\na) Premier exemple\nV oyez ce premier exemple de programme accompagné de trois exemples d’exécution.Exemple de if imbriqués : facturation avec remise (suite)\ndonnez le prix hors taxes : 500\nprix ttc         593.00remise             0.00net à payer      593.00               ___________________________________________                    \ndonnez le prix hors taxes : 4000\nprix ttc        4744.00remise           142.32net à payer     4601.68\nPremier exemple d’instruction switch\nmain()\n{   int n ;   printf (\"donnez un entier : \") ;   scanf (\"%d\", &n) ;\n   switch (n)\n   {  case 0 : printf (\"nul\\n\") ;               break ;      case 1 : printf (\"un\\n\") ;               break ;      case 2 : printf (\"deux\\n\") ;               break ;   }\n   printf (\"au revoir\\n\") ;\n}Delannoy Livre.book  Page 72  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 73chapitre n° 5 Les instructions de contrôle\nL ’instruction switch  s’étend ici sur huit lignes (elle commence au mot switch ). Son exécution\nse déroule comme suit. On commence tout d’abord par évaluer l’expression ﬁgurant après le mot\nswitch  (ici n). Puis, on recherche dans le bloc qui suit s’il existe une « étiquette » de la forme\n« case x » correspondant à la valeur ainsi obtenue. Si c’est le cas, on se branche à l’instruction\nﬁgurant après cette étiquette. Dans le cas contraire, on passe à l’instruction qui suit le bloc.\nPar exemple, quand n vaut 0, on trouve effectivement une étiquette case 0  et l’on exécute\nl’instruction correspondante, c’est-à-dire :\nprintf (\"nul\") ;\nOn passe ensuite, naturellement, à l’instruction suivante, à savoir, ici :\nbreak ;\nCelle-ci demande en fait de sortir du bloc. Notez bien que le rôle de cette instruction est\nfondamental. V oyez, à titre d’exemple, ce que produirait ce même programme en l’absenced’instructions \nbreak  :Premier exemple d’instruction switch (suite)\ndonnez un entier : 0\nnulau revoir______\ndonnez un entier : 2\ndeuxau revoir______\ndonnez un entier : 5\nau revoir\nAbsence d’instructions break\nmain()\n{   int n ;   printf (\"donnez un entier : \") ;   scanf (\"%d\", &n) ;\n   switch (n)\n   {  case 0 : printf (\"nul\\n\") ;      case 1 : printf (\"un\\n\") ;      case 2 : printf (\"deux\\n\") ;   }   printf (\"au revoir\\n\") ;}Delannoy Livre.book  Page 73  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n74 © Éditions Eyrollesb) Étiquette default\nIl est possible d’utiliser le mot-clé default  comme étiquette à laquelle le programme se\nbranchera dans le cas où aucune valeur satisfaisante n’aura été rencontrée auparavant. \nEn voici un exemple :Absence d’instructions break  (suite)\ndonnez un entier : 0\nnulundeuxau revoir______\ndonnez un entier : 2\ndeuxau revoir\nÉtiquette default\nmain()\n{   int n ;   printf (\"donnez un entier : \") ;   scanf (\"%d\", &n) ;   switch (n)   {  case 0 :  printf (\"nul\\n\") ;\n                break ;\n      case 1 :  printf (\"un\\n\") ;                break ;      case 2 :  printf (\"deux\\n\") ;                break ;      default : printf (\"grand\\n\") ;   }   printf (\"au revoir\\n\") ;}\ndonnez un entier : 2\ndeuxau revoir\n_______\ndonnez un entier : 25\ngrandau revoirDelannoy Livre.book  Page 74  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 75chapitre n° 5 Les instructions de contrôle\nc) Exemple plus général\nD’une manière générale, on peut trouver :\n●plusieurs instructions à la suite d’une étiquette,\n●des étiquettes sans instructions, c’est-à-dire, en déﬁnitive, plusieurs étiquettes successives\n(accompagnées de leurs deux-points).\nV oyez cet exemple, dans lequel nous avons volontairement omis certains break .\nExemple général d’instruction switch \nmain()\n{   int n ;   printf (\"donnez un entier : \") ;   scanf (\"%d\", &n) ;\n   switch (n)               \n   {  case 0  : printf (\"nul\\n\") ;                break ;      case 1  :      case 2  : printf (\"petit\\n\") ;      case 3  :                            case 4  :\n      case 5  : printf (\"moyen\\n\") ;                break ;      default : printf (\"grand\\n\") ;   }}\ndonnez un entier : 1\npetitmoyen______\ndonnez un entier : 4\nmoyen ______\ndonnez un entier : 25\ngrandDelannoy Livre.book  Page 75  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n76 © Éditions Eyrolles2.2 Syntaxe de l’instruction switch\n●expression  : expression entière quelconque,\n●constante  : expression constante d’un type entier quelconque ( char  est accepté car il\nsera converti en int),\n●suite_d’instructions  : séquence d’instructions quelconques.\nLes crochets ( [ et ] ) signifient que ce qu’ils renferment est facultatif.\nCommentaires :\n1) Il paraît normal que cette instruction limite les valeurs des étiquettes à des valeurs entières ; en\neffet, il ne faut pas oublier que la comparaison d’égalité de la valeur d’une expression ﬂottante àcelle d’une constante ﬂottante est relativement aléatoire, compte tenu de la précision limitée descalculs. En revanche, il est possible d’employer des constantes de type caractère, étant donnéqu’il y aura systématiquement conversion en \nint. Cela autorise des constructions du type :\n     switch(c)\n       {  case 'a' : ......          case 132 : .....             ......       }\noù c est de type char , ou encore :\n     switch (n)       {  case 'A' : .....          case 559 : .....             .......       }\noù n est du type int.L’instruction switch\n     switch (expression)\n        { case constante_ 1 : [ suite_d’instructions_1 ]\n          case constante_ 2 : [ suite_d’instructions_2 ]\n                     ..............          case constante_\nn : [ suite_d’instructions_n ]\n          [ default        :   suite_d’instructions   ]        }Delannoy Livre.book  Page 76  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 77chapitre n° 5 Les instructions de contrôle\n2) La syntaxe autorise des expressions constantes et non seulement des constantes. On nomme\nainsi des expressions qui peuvent être évaluées lors de la compilation. Cela peut être, bien sûr,des expressions telles que :\n5 + 2           3  * 8 - 2\nmais l’intérêt en reste limité puisqu’il est alors toujours possible de faire le calcul soi-même.\nMais cela peut également faire appel à des symboles déﬁnis par la directive #define , comme\ndans cet exemple :\n      #define  LIMITE  20\n          .....      switch (n)          {  .....            case LIMITE-1 : ......            case LIMITE   : ......            case LIMITE+1 : ......         }\nÀ la compilation, les expressions LIMITE-1 , LIMITE  et LIMITE+1  seront effectivement\nremplacées par les valeurs 19, 20 et 21.\nCette façon de procéder permet un certain paramétrage des programmes. Ainsi, dans cet exem-\nple, une modiﬁcation de la valeur de LIMITE  se résume à une seule intervention au niveau de\nla directive #define . Notez bien qu’une variable initialisée à 20 au sein du programme ne\npourrait pas être utilisée puisque les étiquettes de l’instruction switch  ne seraient plus des\nexpressions constantes.\n3) Les connaisseurs du Pascal trouveront que cette sélection réalisée par l’instruction switch\nest moins riche que celle offerte par l’instruction CASE  dans la mesure où elle impose d’énumérer\nles différentes valeurs concernées. En aucun cas, on ne peut fournir un intervalle autrement\nqu’en citant chacune de ses valeurs.\n3L’instruction do… while\nAbordons maintenant la première façon de réaliser une boucle en C, à savoir l’instruction\ndo... while .Delannoy Livre.book  Page 77  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n78 © Éditions Eyrolles3.1 Exemple d’introduction de l’instruction do... while\nL ’instruction :\n      do  {  .......  }  while (n<=0) ;\nrépète l’instruction qu’elle contient (ici un bloc) tant que la condition mentionnée ( n<=0 ) est\nvraie (c’est-à-dire, en C, non nulle). Autrement dit, ici, elle demande un nombre à l’utilisateur\n(en afﬁchant la valeur lue) tant qu’il ne fournit pas une valeur positive.\nOn ne sait pas a priori combien de fois une telle boucle sera répétée. Toutefois, de par sa nature\nmême, elle est toujours parcourue au moins une fois. En effet, la condition qui régit cetteboucle n’est examinée qu’à la ﬁn de chaque répétition (comme le suggère d’ailleurs le fait quela « partie \nwhile  » ﬁgure en ﬁn).\nNotez bien que la sortie de boucle ne se fait qu’après un parcours complet de ses instructionset non dès que la condition mentionnée devient fausse. Ainsi, ici, même après que l’utilisateura fourni une réponse convenable, il y a exécution de l’instruction d’afﬁchage :\nprintf (\"vous avez fourni %d\", n) ;Exemple d’instruction do... while\nmain()\n{    int n ;   do      { printf (\"donnez un nb >0 : \") ;        scanf (\"%d\", &n) ;        printf (\"vous avez fourni %d\\n\", n) ;      }   while (n<=0) ;   printf (\"réponse correcte\") ;}\ndonnez un nb >0 : -3\nvous avez fourni -3donnez un nb >0 : -9vous avez fourni –9donnez un nb >0 : 12vous avez fourni 12réponse correcteDelannoy Livre.book  Page 78  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 79chapitre n° 5 Les instructions de contrôle\n3.2 Syntaxe de l’instruction do... while\nCommentaires\n1) Notez bien, d’une part la présence de parenthèses  autour de l’expression qui régit la pour-\nsuite de la boucle, d’autre part la présence d’un point-virgule  à la ﬁn de cette instruction.\n2) Lorsque l’instruction à répéter se limite à une seule instruction simple, n’omettez pas le\npoint-virgule qui la termine. Ainsi :\n     do c = getchar() while ( c != 'x') ;\nest incorrecte. Il faut absolument écrire :\n    do c = getchar() ; while ( c != 'x') ;\n3) N’oubliez pas que, là encore, l’expression suivant le mot while  peut être aussi élaborée\nque vous le souhaitez et qu’elle permet ainsi de réaliser certaines actions. Nous en verronsquelques exemples dans le paragraphe suivant.\n4) L ’instruction à répéter peut être vide (mais quand même terminée par un point-virgule). Ces\nconstructions sont correctes :\n    do ; while ( ... ) ;\n     do { } while ( ... ) ;\n5) La construction :\n    do { } while (1) ;\nreprésente une boucle inﬁnie ; elle est syntaxiquement correcte, bien qu’elle ne présente en\npratique aucun intérêt. En revanche :\n    do  instruction  while (1) ;\npourra présenter un intérêt dans la mesure où, comme nous le verrons, il sera possible d’ensortir éventuellement par une instruction \nbreak .L’instruction do... while\n           do     instruction\n                while  (expression) ;Delannoy Livre.book  Page 79  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n80 © Éditions Eyrolles6) Si vous connaissez Pascal, vous remarquerez que cette instruction do... while corres-\npond au repeat... until avec, cependant, une condition exprimée sous forme contraire.\n3.3 Exemples\na) L ’exemple proposé au paragraphe 3.1 peut également s’écrire :\n  do  { printf (\"donnez un nb > 0 : \") ;\n        scanf (\"%d\", &n) ;      }  while ( printf(\"vous avez fourni %d\", n), n<= 0 )\nou encore :\n  do  printf (\"donnez un nb >0 : \") ;  while (scanf(\"%d\", &n), printf (\"vous avez fourni %d\", n), n <= 0 ) ;\nou même :\n  do { }  while ( printf (\"donnez un nb > 0 :\"),  scanf (\"%d\", &n),          printf (\"vous avez fourni %d\", n), n <= 0 ) ;\nNotez bien que la condition de poursuite doit être la dernière expression évaluée, compte tenu\ndu fonctionnement de l’opérateur séquentiel.\nb) L ’instruction :\n  do { } while ( (c=getchar()) != 'x' ) ;\nlit des caractères au clavier jusqu’à ce qu’elle ait obtenu le caractère x. Elle est équivalente à :\n  do  c = getchar() ;\n  while ( c != 'x' ) ;\n4L’instruction while\nV oyons maintenant la deuxième façon de réaliser une boucle conditionnelle, à savoir l’instruc-\ntion while .Delannoy Livre.book  Page 80  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 81chapitre n° 5 Les instructions de contrôle\n4.1 Exemple d’introduction de l’instruction while\nLa construction :\nwhile (som<100)\nrépète l’instruction qui suit (ici un bloc) tant que la condition mentionnée est vraie (différente\nde zéro), comme le ferait do... while . En revanche, cette fois, la condition de poursuite est\nexaminée avant chaque parcours de la boucle et non après. Ainsi, contrairement à ce qui se\npassait avec do... while , une telle boucle peut très bien n’être parcourue aucune fois si la\ncondition est fausse dès qu’on l’aborde (ce qui n’est pas le cas ici).\n4.2 Syntaxe de l’instruction while\nCommentaires\n1) Là encore, notez bien la présence de parenthèses pour délimiter la condition de poursuite.Remarquez que, par contre, la syntaxe n’impose aucun point-virgule de ﬁn (il s’en trouveranaturellement un à la ﬁn de l’instruction qui suit si celle-ci est simple).Exemple d’instruction while\nmain()\n{   int n, som ;   som = 0 ;   while (som<100      { printf (\"donnez un nombre : \") ;        scanf (\"%d\", &n) ;        som += n ;      }   printf (\"somme obtenue : %d\", som) ;} \ndonnez un nombre : 15\ndonnez un nombre : 25donnez un nombre : 12donnez un nombre : 60somme obtenue : 112\nL’instruction while\nwhile  (expression)      \n                             instructionDelannoy Livre.book  Page 81  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n82 © Éditions Eyrolles2) L ’expression utilisée comme condition de poursuite est évaluée avant le premier tour de\nboucle. Il est donc nécessaire que sa valeur soit déﬁnie à ce moment.\n3) Lorsque la condition de poursuite est une expression qui fait appel à l’opérateur séquentiel,\nn’oubliez pas qu’alors toutes les expressions qui la constituent seront évaluées avant le test depoursuite de la boucle. Ainsi, cette construction :\n  while ( printf (\"donnez un nombre : \") , scanf (\"%d\", &n), som<=100)\n             som += n ;\nn’est pas équivalente à celle de l’exemple d’introduction.\n4) La construction :\n     while ( expression1, expression2 ) ;\nest équivalente à :\n     do expression1 \n         while ( expression2 ) ;\nPar exemple, ces deux instructions sont équivalentes :\nwhile ( (c=getchar()) != 'x' ) { }do { } while ( (c=getchar()) != 'x' ) ;\n5 L’instruction for\nÉtudions maintenant la dernière instruction permettant de réaliser des boucles, à savoir l’ins-\ntruction for.\n5.1 Exemple d’introduction de l’instruction for\nConsidérez ce programme :\nExemple d’instruction for\nmain()\n{   int i ;   for ( i=1 ; i<=5 ; i++ )      {  printf (\"bonjour \") ;         printf (\"%d fois\\n\", i) ;      }}Delannoy Livre.book  Page 82  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 83chapitre n° 5 Les instructions de contrôle\nLa ligne :\n    for ( i=1 ; i<=5 ; i++ )\ncomporte en fait trois expressions. La première est évaluée (une seule fois) avant d’entrer dans\nla boucle. La deuxième conditionne la poursuite de la boucle. Elle est évaluée avant chaque\nparcours. La troisième, enﬁn, est évaluée à la ﬁn de chaque parcours.\nLe programme précédent est équivalent au suivant :\nLà encore, la généralité de la notion d’expression en C fait que ce qui était expression dans la\npremière formulation ( for) devient instruction dans la seconde ( while ).Exemple d’instruction for (suite)\nbonjour 1 fois\nbonjour 2 foisbonjour 3 foisbonjour 4 foisbonjour 5 fois\nRemplacement d’ une boucle for par une boucle while\nmain(){   int i ;   i = 1 ;   while (i<=5)      {  printf (\"bonjour \") ;         printf (\"%d fois\\n\", i) ;         i++ ;      }}\nbonjour 1 foisbonjour 2 foisbonjour 3 foisbonjour 4 foisbonjour 5 foisDelannoy Livre.book  Page 83  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n84 © Éditions Eyrolles5.2 Syntaxe de l’instruction for\nLes crochets [ et ] signiﬁent que leur contenu est facultatif.\nCommentaires\n1) D’une manière générale, nous pouvons dire que :\n    for ( expression_1 ; expression_2 ; expression_3) instruction\nest équivalent à :\n    expression_1 ;\n    while (expression_2)       {  instruction           expression_3 ;       }\n2) Chacune des trois expressions est facultative. Ainsi, ces constructions sont équivalentes à\nl’instruction for de notre premier exemple de programme :\n    i = 1 ;\n    for ( ; i<=5 ; i++ )  { printf (\"bonjour \") ;                            printf (\"%d fois\\n\", i) ;                          }\n    i = 1 ;\n    for ( ; i<=5 ; )    { printf (\"bonjour \") ;                          printf (\"%d fois\\n\", i) ;                          i++ ;                        }\n3) Lorsque l’expression_2  est absente, elle est considérée comme vraie.\n4) Là encore, la richesse de la notion d’expression en C permet de grouper plusieurs actions\ndans une expression. Ainsi :\n    for ( i=0, j=1, k=5 ; ... ; ... )\nest équivalent à :\n    j=1 ; k=5 ;\n    for ( i=0 ; ... ; ... )L’instruction for\n      for  ( [ expression_1 ] ; [ expression_2 ] ; [ expression_3 ] )\n                    instructionDelannoy Livre.book  Page 84  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 85chapitre n° 5 Les instructions de contrôle\nou encore à :\n    i=0 ; j=1 ; k=5 ;\n    for ( ; ... ; ...)\nDe même :\n    for ( i=1 ; i <= 5 ; printf(\"fin de tour\"), i++ )  { instructions }\nest équivalent à :\n    for ( i=1 ; i<=5 ; i++ )         {  instructions             printf (\"fin de tour\") ;         }\nEn revanche :\n for ( i=1, printf(\"on commence\") ; printf(\"début de tour\"), i<=5 ; i++)         { instructions }\nn’est pas équivalent à :\n    printf (\"on commence\") ;    for ( i=1 ; i<=5 ; i++ )         { printf (\"début de tour\") ;           instructions         }\ncar, dans la première construction, le message début de tour  est afﬁché après le dernier\ntour tandis qu’il ne l’est  pas dans la seconde construction.\n5) Les deux constructions :\n    for ( ; ; ) ;\n    for ( ; ; ) { }\nsont syntaxiquement correctes. Elles représentent des boucles inﬁnies de corps vide (n’oubliez\npas que, lorsque la seconde expression est absente, elle est considérée comme vraie). En prati-que, elles ne présentent aucun intérêt. \nEn revanche, cette construction \n    for ( ; ; )  instruction\nest une boucle a priori inﬁnie dont on pourra éventuellement sortir par une instruction break\n(comme nous le verrons dans le paragraphe suivant).Delannoy Livre.book  Page 85  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n86 © Éditions EyrollesContrairement à ce qui se passe dans beaucoup de langages, les trois instructions de boucle\ndu langage C sont des boucles conditionnelles. En effet, l’instruction for, basée sur une\ncondition, n’est pas l’équivalent strict de la « répétition avec compteur » (ce qui est le cas du\nfor du Pascal et du Basic ou du do du Fortran), même si c’est généralement celle que l’on\nutilise en C pour jouer un tel rôle.\n6Les instructions de branchement inconditionnel : break , \ncontinue  et goto\nCes trois instructions fournissent des possibilités diverses de branchement inconditionnel. Les\ndeux premières s’emploient principalement au sein de boucles tandis que la dernière est d’unusage libre mais peu répandu, à partir du moment où l’on cherche à structurer quelque peu sesprogrammes.\n6.1 L’instruction break\nNous avons déjà vu le rôle de break  au sein du bloc régi par une instruction switch .\nLe langage C autorise également l’emploi de cette instruction dans une boucle. Dans ce cas,elle sert à interrompre le déroulement de la boucle, en passant à l’instruction qui suit cetteboucle. Bien entendu, cette instruction n’a d’intérêt que si son exécution est conditionnée parun choix ; dans le cas contraire, en effet, elle serait exécutée dès le premier tour de boucle, cequi rendrait la boucle inutile.\nV oici un exemple montrant le fonctionnement de \nbreak  :\nExemple d’instruction break\nmain()\n{       int i ;   for ( i=1 ; i<=10 ; i++ )      { printf (\"début tour %d\\n\", i) ;        printf (\"bonjour\\n\")         if ( i==3 ) break ;        printf (\"fin tour %d\\n\", i) ;      }   printf (\"après la boucle\") ;}Delannoy Livre.book  Page 86  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 87chapitre n° 5 Les instructions de contrôle\nEn cas de boucles imbriquées, break  fait sortir de la boucle la plus interne. De même si break\napparaît dans un switch  imbriqué dans une boucle, elle ne fait sortir que du switch .\n6.2 L’instruction continue\nL ’instruction continue , quant à elle, permet de passer prématurément au tour de boucle\nsuivant. En voici un premier exemple avec for :Exemple d’instruction break (suite)\ndébut tour 1\nbonjourfin tour 1début tour 2bonjourfin tour 2début tour 3bonjouraprès la boucle\nExemple d’instruction continue  dans une boucle for\nmain(){  int i ;   for ( i=1 ; i<=5 ; i++ )      { printf (\"début tour %d\\n\", i) ;         if (i<4) continue ;        printf (\"bonjour\\n\") ;      } }\ndébut tour 1début tour 2début tour 3 \ndébut tour 4\nbonjourdébut tour 5bonjourDelannoy Livre.book  Page 87  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n88 © Éditions EyrollesEt voici un second exemple avec do... while  :\nLorsqu’elle est utilisée dans une boucle for, cette instruction continue  effectue bien un bran-\nchement sur l’évaluation de l’expression de fin de parcours de boucle (nommée expression_2\ndans la présentation de sa syntaxe), et non après.\nEn cas de boucles imbriquées, l’instruction continue ne concerne que la boucle la plus interne.\n6.3 L’instruction goto\nElle permet classiquement le branchement en un emplacement quelconque du programme.\nV oyez cet exemple qui simule, dans une boucle for, l’instruction break  à l’aide de l’instruc-\ntion goto  (ce programme fournit les mêmes résultats que celui présenté comme exemple de\nl’instruction break ).Exemple d’instruction continue  dans une boucle do... while\nmain()\n{  int n ;   do      { printf (\"donnez un nb>0 : \") ;        scanf (\"%d\", &n) ;        if (n<0) { printf (\"svp >0\\n\") ;                   continue ;                 }        printf (\"son carré est : %d\\n\", n*n) ;      }   while(n) ;}\ndonnez un nb>0 : 4\nson carré est : 16donnez un nb>0 : -5svp >0donnez un nb>0 : 2son carré est : 4donnez un nb>0 : 0son carré est : 0Delannoy Livre.book  Page 88  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 89chapitre n° 5 Les instructions de contrôle\nExemple d’instruction goto\nmain()\n{   int i ;   for ( i=1 ; i<=10 ; i++ )      { printf (\"début tour %d\\n\", i) ;        printf (\"bonjour\\n\") ;        if ( i==3 ) goto sortie ;        printf (\"fin tour %d\\n\", i) ;      }   sortie : printf (\"après la boucle\") ;}\ndébut tour 1\nbonjourfin tour 1début tour 2bonjourfin tour 2début tour 3bonjouraprès la boucleDelannoy Livre.book  Page 89  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n90 © Éditions EyrollesExercices\nTous ces exercices sont corrigés en fin de volume.\n1) Soit le petit programme suivant :\n#include <stdio.h>\nmain()\n{    int i, n, som ;\n   som = 0 ;\n   for (i=0 ; i<4 ; i++)\n      { printf (\"donnez un entier \") ;\n        scanf (\"%d\", &n) ;\n        som += n ;\n      }   printf (\"Somme : %d\\n\", som) ;\n}    \nÉcrire un programme réalisant exactement la même chose, en employant, à la place de\nl’instruction \nfor :\n●une instruction while ,\n●une instruction do...  while .\n2) Calculer la moyenne de notes fournies au clavier avec un dialogue de ce type :\n  note 1 : 12\n  note 2 : 15.25  note 3 : 13.5  note 4 : 8.75  note 5 : -1  moyenne de ces 4 notes : 12.37\nLe nombre de notes n’est pas connu a priori et l’utilisateur peut en fournir autant qu’il le désire.\nPour signaler qu’il a terminé, on convient qu’il fournira une note fictive négative. Celle-ci nedevra naturellement pas être prise en compte dans le calcul de la moyenne.\n3) Afficher un triangle rempli d’étoiles, s’étendant sur un nombre de lignes fourni en donnée et\nse présentant comme dans cet exemple :\n  *\n  **  ***  ****  *****Delannoy Livre.book  Page 90  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 91chapitre n° 5 Les instructions de contrôle\n4) Déterminer si un nombre entier fourni en donnée est premier ou non.\n5) Écrire un programme qui détermine la n-ième valeur un (n étant fourni en donnée) de la\n« suite de Fibonacci » définie comme suit :\nu1 = 1\nu2 = 1\nun = un-1 + un-2    pour n>2\n6) Écrire un programme qui affiche la table de multiplication des nombres de 1 à 10, sous la\nforme suivante :\n      I   1   2   3   4   5   6   7   8   9  10\n-----------------------------------------------   1  I   1   2   3   4   5   6   7   8   9  10   2  I   2   4   6   8  10  12  14  16  18  20   3  I   3   6   9  12  15  18  21  24  27  30   4  I   4   8  12  16  20  24  28  32  36  40   5  I   5  10  15  20  25  30  35  40  45  50   6  I   6  12  18  24  30  36  42  48  54  60   7  I   7  14  21  28  35  42  49  56  63  70   8  I   8  16  24  32  40  48  56  64  72  80   9  I   9  18  27  36  45  54  63  72  81  90  10  I  10  20  30  40  50  60  70  80  90 100Delannoy Livre.book  Page 91  Mercredi, 6. mai 2009  4:26 16\nDelannoy Livre.book  Page 92  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 93Chapitre 6 \nLa programmation modulaire \net les fonctions \nComme tous les langages, C permet de découper un programme en plusieurs parties nommées\nsouvent « modules ». Cette programmation dite modulaire se justiﬁe pour de multiples raisons :\n●Un programme écrit d’un seul tenant devient difﬁcile à comprendre dès qu’il dépasse uneou deux pages de texte. Une écriture modulaire permet de le scinder en plusieurs parties etde regrouper dans le programme principal les instructions en décrivant les enchaînements.Chacune de ces parties peut d’ailleurs, si nécessaire, être décomposée à son tour en modu-les plus élémentaires ; ce processus de décomposition pouvant être répété autant de foisque nécessaire, comme le préconisent les méthodes de programmation structurée.\n●La programmation modulaire permet d’éviter des séquences d’instructions répétitives, etcela d’autant plus que la notion d’argument permet de paramétrer certains modules.\n●La programmation modulaire permet le partage d’outils communs qu’il sufﬁt d’avoir écritset mis au point une seule fois. Cet aspect sera d’autant plus marqué que C autorise effecti-vement la compilation séparée de tels modules.Delannoy Livre.book  Page 93  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n94 © Éditions Eyrolles1La fonction : la seule sorte de module existant en C\nDans certains langages, on trouve deux sortes de modules, à savoir :\n●Les fonctions , assez proches de la notion mathématique correspondante. Notamment, une\nfonction dispose d’arguments (en C, comme dans la plupart des autres langages, une fonc-\ntion peut ne comporter aucun argument) qui correspondent à des informations qui lui sonttransmises et elle fournit un unique résultat scalaire (simple) ; désigné par le nom même dela fonction, ce dernier peut apparaître dans une expression. On dit d’ailleurs que la fonc-tion possède une valeur et qu’un appel de fonction est assimilable à une expression.\n●Les procédures  (terme Pascal) ou sous-programmes (terme Fortran ou Basic) qui élargissent\nla notion de fonction. La procédure ne possède plus de valeur à proprement parler et sonappel ne peut plus apparaître au sein d’une expression. Par contre, elle dispose toujoursd’arguments. Parmi ces derniers, certains peuvent, comme pour la fonction, correspondreà des informations qui lui sont transmises. Mais d’autres, contrairement à ce qui se passepour la fonction, peuvent correspondre à des informations qu’elle produit en retour de sonappel. De plus, une procédure peut réaliser une action, par exemple afﬁcher un message(en fait, dans la plupart des langages, la fonction peut quand même réaliser une action,bien que ce ne soit pas là sa vocation).\nEn C, il n’existe qu’une seule sorte de module, nommé fonction (il en ira de même en C++ et\nen Java, langage dont la syntaxe est proche de celle de C). Ce terme, quelque peu abusif, pour-rait laisser croire que les modules du C sont moins généraux que ceux des autres langages. Oril n’en est rien, bien au contraire ! Certes, la fonction pourra y être utilisée comme dansd’autres langages, c’est-à-dire recevoir des arguments et fournir un résultat scalaire qu’onutilisera dans une expression, comme, par exemple, dans :\ny = sqrt(x)+3 ;\nMais, en C, la fonction pourra prendre des aspects différents, pouvant complètement dénaturerl’idée qu’on se fait d’une fonction. Par exemple :\n●La valeur d’une fonction pourra très bien ne pas être utilisée ; c’est ce qui se passe fré-quemment lorsque vous utilisez \nprintf ou scanf . Bien entendu, cela n’a d’intérêt que\nparce que de telles fonctions réalisent une action  (ce qui, dans d’autres langages, serait\nréservée aux sous-programmes ou procédures).\n●Une fonction pourra ne fournir aucune valeur.\n●Une fonction pourra fournir un résultat non scalaire (nous n’en parlerons toutefois quedans le chapitre consacré aux structures).\n●Une fonction pourra modiﬁer les valeurs de certains de ses arguments (il vous faudra tou-tefois attendre d’avoir étudié les pointeurs pour voir par quel mécanisme elle y parviendra).\nAinsi, donc, malgré son nom, en C, la fonction pourra jouer un rôle aussi général que la procé-dure ou le sous-programme des autres langages.Delannoy Livre.book  Page 94  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 95chapitre n° 6 La programmation modulaire et les fonctions\nPar ailleurs, nous verrons qu’en C plusieurs fonctions peuvent partager des informations,\nautrement que par passage d’arguments. Nous retrouverons la notion classique de « variablesglobales » (en Basic, toutes les variables sont globales, de sorte qu’on ne le dit pas - en For-tran, ces variables globales sont rangées dans des « \nCOMMON  »). \nEnﬁn, l’un des atouts du langage C réside dans la possibilité de compilation séparée. Celle-\nci permet de découper le programme source en plusieurs parties, chacune de ces parties pou-vant comporter une ou plusieurs fonctions. Certains auteurs emploient parfois le mot« module » pour désigner chacune de ces parties (stockées dans un ﬁchier) ; dans ce cas, ceterme de module devient synonyme de ﬁchier source. Cela facilite considérablement le déve-loppement et la mise au point de grosses applications. Cette possibilité crée naturellementquelques contraintes supplémentaires, notamment au niveau des variables globales que l’onsouhaite partager entre différentes parties du programme source (c’est d’ailleurs ce qui justiﬁeral’existence de la déclaration \nextern ).\nPour garder une certaine progressivité dans notre exposé, nous supposerons tout d’abord quenous avons affaire à un programme source d’un seul tenant (ce qui ne nécessite donc pas decompilation séparée). Nous présenterons ainsi la structure générale d’une fonction, les notionsd’arguments, de variables globales et locales. Ce n’est qu’alors que nous introduirons lespossibilités de compilation séparée en montrant quelles sont ses incidences sur les pointsprécédents ; cela nous amènera à parler des différentes « classes d’allocation » des variables.\n2Exemple de déﬁnition et d’utilisation d’une fonction en C\nNous vous proposons d’examiner tout d’abord un exemple simple de fonction correspondant àl’idée usuelle que l’on se fait d’une fonction, c’est-à-dire recevant des arguments et fournissantune valeur. \nExemple de définition et d’utilisation d’une fonction \n#include <stdio.h>\n           /***** le programme principal (fonction main) *****/main(){   float fexple (float, int, int) ; /* déclaration de fonction fexple */   float x = 1.5 ;    float y, z ;   int n = 3, p = 5, q = 10 ;          /* appel de fexple avec les arguments x, n et p */   y = fexple (x, n, p) ;    printf (\"valeur de y : %e\\n\", y) ;Delannoy Livre.book  Page 95  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n96 © Éditions EyrollesNous y trouvons tout d’abord, de façon désormais classique, un programme principal formé\nd’un bloc. Mais, cette fois, à sa suite, apparaît la déﬁnition d’une fonction . Celle-ci possède\nune structure voisine de la fonction main , à savoir un en-tête et un corps délimité par des\naccolades ({ et }). Mais l’en-tête est plus élaboré que celui de la fonction main  puisque, outre\nle nom de la fonction ( fexple ), on y trouve une liste d’arguments (nom + type), ainsi que le\ntype de la valeur qui sera fournie par la fonction (on la nomme indifféremment « résultat »,« valeur de la fonction », « valeur de retour »...) :\nfloat          fexple         (float x,        int b,        int c)\n  |               |               |              |             |type de la    nom de la        premier        deuxième      troisième\"valeur        fonction       argument        argument       argument\nde retour\"                  (type float)     (type int)     (type int)\nLes noms des arguments n’ont d’importance qu’au sein du corps de la fonction. Ils servent à\ndécrire le travail que devra effectuer la fonction quand on l’appellera en lui fournissant troisvaleurs.\nSi on s’intéresse au corps de la fonction, on y rencontre tout d’abord une déclaration :\nfloat val ;\nCelle-ci précise que, pour effectuer son travail, notre fonction a besoin d’une variable de type\nfloat  nommée val. On dit que val est une variable locale à la fonction fexple , de même\nque les variables telles que n, p, y... sont des variables locales à la fonction main  (mais\ncomme jusqu’ici nous avions affaire à un programme constitué d’une seule fonction, cette\ndistinction n’était pas utile). Un peu plus loin, nous examinerons plus en détail cette notion devariable locale et celle de portée qui s’y attache.\nL ’instruction suivante de notre fonction \nfexple  est une affectation classique (faisant toutefois\nintervenir les valeurs des arguments x, n et p).         /* appel de fexple avec les arguments x+0.5, q et n-1 */ \n   z = fexple (x+0.5, q, n-1) ;   printf (\"valeur de z : %e\\n\", z) ;}\n         /*************** la fonction fexple ****************/\nfloat fexple (float x, int b, int c){  float val ;          /* déclaration d’une variable \"locale\" à fexple   val = x * x + b * x + c ;   return val ;}Exemple de définition et d’utilisation d’une fonction (suite)Delannoy Livre.book  Page 96  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 97chapitre n° 6 La programmation modulaire et les fonctions\nEnﬁn, l’instruction return val  précise la valeur que fournira la fonction à la ﬁn de son travail.\nEn déﬁnitive, on peut dire que fexple est une fonction telle que fexple  (x, b, c)  four-\nnisse la valeur de l’expression x2 + bx + c. Notez bien l’aspect arbitraire du nom des\narguments ; on obtiendrait la même déﬁnition de fonction avec, par exemple :\nfloat fexple (float z, int coef, int n)\n{   float val ; /* déclaration d’une variable \"locale\" à fexple */   val = z * z + coef * z + n ;   return val ;}\nExaminons maintenant la fonction main . V ous constatez qu’on y trouve une déclaration :\n   float fexple (float, int, int) ; \nElle sert à prévenir le compilateur que fexple  est une fonction et elle lui précise le type de\nses arguments ainsi que celui de sa valeur de retour. Nous reviendrons plus loin en détail sur le\nrôle d’une telle déclaration.\nQuant à l’utilisation de notre fonction fexple  au sein de la fonction main , elle est classique\net comparable à celle d’une fonction prédéﬁnie telle que scanf  ou sqrt . Ici, nous nous som-\nmes contenté d’appeler notre fonction à deux reprises avec des arguments différents.\n3Quelques règles\n3.1 Arguments muets et arguments effectifs\nLes noms des arguments ﬁgurant dans l’en-tête de la fonction se nomment des « arguments\nmuets », ou encore « arguments formels » ou « paramètres formels » (de l’anglais :  formal\nparameter) . Leur rôle est de permettre, au sein du corps de la fonction, de décrire ce qu’elle\ndoit faire.\nLes arguments fournis lors de l’utilisation (l’appel) de la fonction se nomment des « arguments\neffectifs » (ou encore « paramètres effectifs »). Comme le laisse deviner l’exemple précédent,on peut utiliser n’importe quelle expression comme argument effectif ; au bout du compte,c’est la valeur de cette expression qui sera transmise à la fonction lors de son appel. Notezqu’une telle « liberté » n’aurait aucun sens dans le cas des paramètres formels : il serait impos-sible d’écrire un en-tête de \nfexple sous la forme float  fexple  (float  a+b,  ...)  pas\nplus qu’en mathématiques vous ne déﬁniriez une fonction f par f (x+y)=5  !Delannoy Livre.book  Page 97  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n98 © Éditions Eyrolles3.2 L’instruction return\nV oici quelques règles générales concernant cette instruction.\n●L ’instruction return  peut mentionner n’importe quelle expression. Ainsi, nous aurions pu\ndéﬁnir la fonction fexple  précédente d’une manière plus simple :\n     float fexple (float x, int b, int c)\n     {        return (x * x + b * x + c) ;     }\n●L ’instruction return  peut apparaître à plusieurs reprises dans une fonction, comme dans\ncet autre exemple :\n     double absom (double u, double v)     {         double s ;         s = a + b ;         if (s>0)    return (s) ;              else   return (-s)      }\nNotez bien que non seulement l’instruction return  déﬁnit la valeur du résultat, mais, en\nmême temps, elle interrompt l’exécution de la fonction en revenant dans la fonction qui\nl’a appelée (n’oubliez pas qu’en C tous les modules sont des fonctions, y compris leprogramme principal). Nous verrons qu’une fonction peut ne fournir aucune valeur : ellepeut alors disposer de une ou plusieurs instructions \nreturn  sans expression , interrom-\npant simplement l’éxecution de la fonction ; mais elle peut aussi dans ce cas ne comporteraucune instruction \nreturn , le retour étant alors mis en place automatiquement par le\ncompilateur à la ﬁn de la fonction.\n●Si le type de l’expression ﬁgurant dans return  est différent du type du résultat tel qu’il a\nété déclaré dans l’en-tête, le compilateur mettra automatiquement en place des instructionsde conversion.\nIl est toujours possible de ne pas utiliser le résultat d’une fonction, même si elle en pro-\nduit un. C’est d’ailleurs ce que nous avons fait fréquemment avec \nprintf  ou scanf .\nBien entendu, cela n’a d’intérêt que si la fonction fait autre chose que de calculer unrésultat. En revanche, il est interdit d’utiliser la valeur d’une fonction ne fournissant pasde résultat (si certains compilateurs l’acceptent, vous obtiendrez, lors de l’exécution, unevaleur aléatoire !).Delannoy Livre.book  Page 98  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 99chapitre n° 6 La programmation modulaire et les fonctions\n3.3 Cas des fonctions sans valeur de retour \nou sans arguments\nQuand une fonction ne renvoie pas de résultat, on le précise, à la fois dans l’en-tête et dans sa\ndéclaration, à l’aide du mot-clé void . Par exemple, voici l’en-tête d’une fonction recevant un\nargument de type int et ne fournissant aucune valeur :\nvoid sansval (int n)\net voici quelle serait sa déclaration :\nvoid sansval (int) ;\nNaturellement, la déﬁnition d’une telle fonction ne doit, en principe, contenir aucune instruc-tion \nreturn . Certains compilateurs ne détecteront toutefois pas l’erreur.\nQuand une fonction ne reçoit aucun argument, on place le mot-clé void  (le même que précé-\ndemment, mais avec une signiﬁcation différente !) à la place de la liste d’arguments (atten-tion, en C++, la règle sera différente : on se contentera de ne rien mentionner dans la listed’arguments). V oici l’en-tête d’une fonction ne recevant aucun argument et renvoyant unevaleur de type \nfloat  (il pourrait s’agir, par exemple, d’une fonction fournissant un nombre\naléatoire !) :\nfloat tirage (void) \nSa déclaration serait très voisine (elle ne diffère que par la présence du point-virgule !) :\nfloat tirage (void) ;\nEnﬁn, rien n’empêche de réaliser une fonction ne possédant ni arguments ni valeur de retour.Dans ce cas, son en-tête sera de la forme :\nvoid message (void)\net sa déclaration sera :\nvoid message (void) ;\nEn toute rigueur, la fonction main  est une fonction sans argument et sans valeur de retour. Elle\ndevrait donc avoir pour en-tête « void  main  (void)  ». Certains compilateurs fournissent\nd’ailleurs un message d’avertissement (« warning ») lorsque vous vous contentez de l’en-tête\nusuel main .Delannoy Livre.book  Page 99  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n100 © Éditions EyrollesV oici un exemple illustrant deux des situations évoquées. Nous y déﬁnissons une fonction\naffiche_carres  qui afﬁche les carrés des nombres entiers compris entre deux limites four-\nnies en arguments et une fonction erreur  qui se contente d’afﬁcher un message d’erreur (il\ns’agit de notre premier exemple de programme source contenant plus de deux fonctions).\n#include <stdio.h>\nmain(){  void affiche_carres (int, int) ; /* prototype de affiche_carres */   void erreur (void) ;             /* prototype de erreur */   int debut = 5, fin = 10 ;      .....   affiche_carres (debut, fin) ;      .....   if (...) erreur () ;}void affiche_carres (int d, int f){  int i ;              for (i=d ; i<=f ; i++)      printf (\"%d a pour carré %d\\n\", i, i*i) ;}void erreur (void){  printf (\"*** erreur ***\\n\") ; }\n3.4 Les anciennes formes de l’en-tête des fonctions\nDans la première version du langage C, telle qu’elle a été déﬁnie par Kernighan et Ritchie,\navant la normalisation par le comité ANSI, l’en-tête d’une fonction s’écrivait différemment dece que nous avons vu ici. Par exemple, l’en-tête de notre fonction \nfexple aurait été :\nfloat fexple (x, b, c)\nfloat x ;int b, c ;\nLa norme ANSI autorise les deux formes, lesquelles sont actuellement acceptées par la plupart\ndes compilateurs. Toutefois, seule la forme moderne, c’est-à-dire celle que nous avons présentéeprécédemment, sera autorisée par C++.\nL’habitude veut que les en-têtes écrits sous l’ancienne forme le soient sur plusieurs lignes\ncomme dans notre exemple. Mais rien ne nous empêcherait de l’écrire sous cette forme :\nfloat fexple (x, b, c) float x ; int b, c ;Delannoy Livre.book  Page 100  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 101chapitre n° 6 La programmation modulaire et les fonctions\n4Les fonctions et leurs déclarations\n4.1 Les différentes façons de déclarer (ou de ne pas déclarer) une fonction\nDans notre exemple du paragraphe 2, nous avions fourni la déﬁnition de la fonction fexple\naprès celle de la fonction main . Mais nous aurions pu tout aussi bien faire l’inverse :\nfloat fexple (float x, int b, int c)\n{    ....}\nmain()\n{   float fexple (float, int, int) ; /* déclaration de la fonc. fexple */       .....   y = fexple (x, n, p) ;        .....}\nEn toute rigueur, dans ce cas, la déclaration de la fonction fexple (ici, dans main ) est facul-\ntative, car, lorsqu’il traduit la fonction main , le compilateur connaît déjà la fonction fexple .\nNéanmoins, nous vous déconseillons d’omettre la déclaration de fexple  dans ce cas ; en\neffet, il est tout à fait possible qu’ultérieurement vous soyez amené à modiﬁer votre programme\nsource ou même à l’éclater en plusieurs ﬁchiers source comme l’autorisent les possibilités decompilation séparée du langage C.\nPar ailleurs, le langage C (mais pas le C++) vous permet d’effectuer des déclarations partielles\nen ne mentionnant pas le type des arguments ; ainsi, dans notre exemple du paragraphe 2, nouspourrions déclarer \nfexple  de cette façon dans la fonction main  :\nfloat fexple () ;\nQui plus est, C vous autorise à ne pas déclarer du tout une fonction qui renvoie une valeur detype \nint (là encore, ce sera interdit en C++ ainsi qu’en C99).\nNous ne saurions trop vous conseiller d’éviter de telles possibilités. Toutefois, sachez que vousrisquez d’employer la dernière sans y prendre garde. En effet, toute fonction que vous utiliserezsans l’avoir déclarée sera considérée par le compilateur comme ayant des arguments quel-conques et fournissant un résultat de type \nint. Les conséquences en seront différentes suivant\nque ladite fonction est ou non fournie dans le même ﬁchier source. Dans le premier cas, onobtiendra bien une erreur de compilation ; dans le second, en revanche, les conséquencesn’apparaîtront (de manière plus ou moins voilée) que lors de l’exécution !Delannoy Livre.book  Page 101  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n102 © Éditions EyrollesLa déclaration complète d’une fonction porte le nom de prototype . Il est possible, dans un\nprototype, de faire ﬁgurer des noms d’arguments, lesquels sont alors totalement arbitraires ;\ncette possibilité a pour seul intérêt de pouvoir écrire des prototypes qui sont identiques à l’en-tête de la fonction (au point-virgule près), ce qui peut en faciliter la création automatique.Dans notre exemple du paragraphe 2, notre fonction \nfexple  aurait pu être déclarée  ainsi :\nfloat fexple (float x, int b, int c) ;\n4.2 Où placer la déclaration d’une fonction\nLa tendance la plus naturelle consiste à placer la déclaration d’une fonction à l’intérieur desdéclarations de toute fonction l’utilisant ; c’est ce que nous avons fait jusqu’ici. Et, de surcroît,dans tous nos exemples précédents, la fonction utilisatrice était la fonction \nmain  elle-même !\nDans ces conditions, nous avions affaire à une déclaration locale dont la portée était limitée àla fonction où elle apparaissait.\nMais il est également possible d’utiliser des déclarations globales, en les faisant apparaître\navant la déﬁnition de la première fonction . Par exemple, avec :\nfloat fexple (float, int, int) ;\nmain(){  .....}void f1 (...){  .....}\nla déclaration de fexple  est connue à la fois de main  et de f1.\n4.3 À quoi sert la déclaration d’une fonction\nNous avons vu que la déclaration d’une fonction est plus ou moins obligatoire et qu’elle peut\nêtre plus ou moins détaillée. Malgré tout, nous vous avons recommandé d’employer toujoursla forme la plus complète possible qu’on nomme prototype. Dans ce cas, un tel prototype peutêtre utilisé par le compilateur, et cela de deux façons complètement différentes.\na) Si la déﬁnition de la fonction se trouve dans le même ﬁchier source (que ce soit avant ou\naprès la déclaration), il s’assure que les arguments muets ont bien le type déﬁni dans le proto-type. Dans le cas contraire, il signale une erreur.\nb) Lorsqu’il rencontre un appel de la fonction, il met en place d’éventuelles conversions des\nvaleurs des arguments effectifs dans le type indiqué dans le prototype. Par exemple, avec notrefonction \nfexple  du paragraphe 2, un appel tel que :\nfexple (n+1, 2*x, p) Delannoy Livre.book  Page 102  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 103chapitre n° 6 La programmation modulaire et les fonctions\nsera traduit par :\n●l’évaluation de la valeur de l’expression n+1 (en int) et sa conversion en float ,\n●l’évaluation de la valeur de l’expression 2*x (en float ) et sa conversion en int ; il y a\ndonc dans ce dernier cas une conversion dégradante.\nRappelons que, lorsque le compilateur ne connaît pas le type des arguments d’une fonction, il\nutilise des règles de conversions systématiques : char  et short  -> int et float  -> double .\nLa fonction printf  est précisément dans ce cas.\nCompte tenu de la remarque précédente, seule une fonction déclarée avec un prototype\npourra recevoir un argument de type float , char  ou short .\n5Retour sur les ﬁchiers en-tête\nNous avons déjà dit qu’il existe un certain nombre de ﬁchiers d’extension .h, correspondant\nchacun à une classe de fonctions. On y trouve, entre autres choses, les prototypes de ces\nfonctions.\nCe point se révèle fort utile :\n●d’une part pour effectuer des contrôles sur le nombre et le type des arguments mentionnés\ndans les appels de ces fonctions,\n●d’autre part pour forcer d’éventuelles conversions auxquelles on risque de ne pas penser.\nÀ titre d’illustration de ce dernier aspect, supposez que vous ayez écrit ces instructions :\n    float x, y ;\n       .....    y = sqrt (x) ;       .....\nsans les faire précéder d’une quelconque directive #include .\nElles produiraient alors des résultats faux . En effet, il se trouve que la fonction sqrt  s’attend\nà recevoir un argument de type double  (ce qui sera le cas ici, compte tenu des conversions\nimplicites), et elle fournit un résultat de type double . Or, lors de la traduction de votre\nprogramme, le compilateur ne le sait pas. Il attribue donc d’ofﬁce à sqrt  le type int et il met\nen place une conversion de la valeur de retour (laquelle sera en fait de type double ) en int.\nOn se trouve en présence des conséquences habituelles d’une mauvaise interprétation de type.\nUn premier remède consiste à placer dans votre module la déclaration :\ndouble sqrt(double) ;\nmais encore faut-il que vous connaissiez de façon certaine le type de cette fonction.Delannoy Livre.book  Page 103  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n104 © Éditions EyrollesUne meilleure solution  consiste à placer, en début de votre programme, la directive :\n#include <math.h>\nlaquelle incorporera automatiquement le prototype approprié (entre autres choses).\n6En C, les arguments sont transmis par valeur\nNous avons déjà eu l’occasion de dire qu’en C les arguments d’une fonction étaient transmis par\nvaleur. Cependant, dans les exemples que nous avons rencontrés dans ce chapitre, les conséquenceset les limitations de ce mode de transmission n’apparaissaient guère. Or voyez cet exemple :\nLa fonction \nechange  reçoit deux valeurs correspondant à ses deux arguments muets a et b.\nElle effectue un échange de ces deux valeurs. Mais, lorsque l’on est revenu dans le programme\nprincipal, aucune trace de cet échange ne subsiste sur les arguments effectifs n et p.\nEn effet, lors de l’appel de echange , il y a eu transmission de la valeur des expressions n et\np. On peut dire que ces valeurs ont été recopiées localement dans la fonction echange  dansConséquences de la transmission par valeur des arguments\n#include <stdio.h>\nmain(){  void echange (int a, int b) ;   int n=10, p=20 ;   printf (\"avant appel   : %d %d\\n\", n, p) ;   echange (n, p) ;   printf (\"après appel   : %d %d\", n, p) }void echange (int a, int b){   int c ;   printf (\"début echange : %d %d\\n\", a, b) ;   c = a ;   a = b ;   b = c ;   printf (\"fin echange   : %d %d\\n\", a, b) ;}\navant appel   : 10 20début echange : 10 20fin echange   : 20 10après appel   : 10 20Delannoy Livre.book  Page 104  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 105chapitre n° 6 La programmation modulaire et les fonctions\ndes emplacements nommés a et b. C’est effectivement sur ces copies qu’a travaillé la fonction\nechange , de sorte que les valeurs des variables n et p n’ont, quant à elles, pas été modiﬁées.\nC’est ce qui explique le résultat constaté.\nCe mode de transmission semble donc interdire a priori qu’une fonction produise une ou\nplusieurs valeurs en retour, autres que celle de la fonction elle-même.\nOr, il ne faut pas oublier qu’en C tous les modules doivent être écrits sous forme de fonction.\nAutrement dit, ce simple problème d’échange des valeurs de deux variables doit pouvoir serésoudre à l’aide d’une fonction.\nNous verrons que ce problème possède plusieurs solutions, à savoir :\n●Transmettre en argument la valeur de l’adresse d’une variable. La fonction pourra éven-\ntuellement agir sur le contenu de cette adresse. C’est précisément ce que nous faisonslorsque nous utilisons la fonction \nscanf . Nous examinerons cette technique en détail dans\nle chapitre consacré aux pointeurs.\n●Utiliser des variables globales, comme nous le verrons dans le prochain paragraphe ; cettedeuxième solution devra toutefois être réservée à des cas exceptionnels, compte tenu desrisques qu’elle présente (effets de bords).\nC’est bien parce que la transmission des arguments se fait « par valeur » que les arguments\neffectifs peuvent prendre la forme d’une expression quelconque. Dans les langages où le seul\nmode de transmission est celui « par adresse », les arguments effectifs ne peuvent être quel’équivalent d’une lvalue .\nLa norme n’impose aucun ordre pour l’évaluation des différents arguments d’une fonction lors\nde son appel. En général, ceci est de peu d’importance, excepté dans une situation (fortementdéconseillée !) telle que :\n  int i = 10 ;\n    ...\nf (i++, i) ;   /* on peut calculer i++ avant i --> f (10, 11) */\n               /*                   ou après i --> f (10, 10) */\n7Les variables globales\nNous avons vu comment échanger des informations entre différentes fonctions grâce à la\ntransmission d’arguments et à la récupération d’une valeur de retour.\nEn fait, en C, plusieurs fonctions (dont, bien entendu le programme principal main ) peuvent\npartager des variables communes qu’on qualiﬁe alors de globales . \nLa norme ANSI ne parle pas de variables globales, mais de variables externes. Le terme « global »\nillustre plutôt le partage entre plusieurs fonctions tandis que le terme « externe » illustre plutôt le par-\ntage entre plusieurs fichiers source. En C, une variable globale est partagée par plusieurs fonctions ;\nelle peut être (mais elle n’est pas obligatoirement) partagée entre plusieurs fichiers source.Delannoy Livre.book  Page 105  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n106 © Éditions Eyrolles7.1 Exemple d’utilisation de variables globales\nV oyez cet exemple de programme.\nLa variable i a été déclarée en dehors de la fonction main . Elle est alors connue de toutes les\nfonctions qui seront compilées par la suite au sein du même programme source. Ainsi, ici, le pro-\ngramme principal affecte à i des valeurs qui se trouvent utilisées par la fonction optimist .\nNotez qu’ici la fonction optmist  se contente d’utiliser la valeur de i mais rien ne l’empêche\nde la modiﬁer. C’est précisément ce genre de remarque qui doit vous inciter à n’utiliser lesvariables globales que dans des cas limités. En effet, toute variable globale peut être modiﬁéeinsidieusement par n’importe quelle fonction. Lorsque vous aurez à écrire des fonctions suscep-tibles de modiﬁer la valeur de certaines variables, il sera beaucoup plus judicieux de prévoird’en transmettre l’adresse en argument (comme vous apprendrez à le faire dans le prochainchapitre). En effet, dans ce cas, l’appel de la fonction montrera explicitement quelle est lavariable qui risque d’être modiﬁée et, de plus, ce sera la seule qui pourra l’être.\n7.2 La portée des variables globales\nLes variables globales ne sont connues du compilateur que dans la partie du programme sourcesuivant leur déclaration. On dit que leur portée  (ou encore leur espace de validité ) est limitée à\nla partie du programme source qui suit leur déclaration (n’oubliez pas que, pour l’instant, nousnous limitons au cas où l’ensemble du programme est compilé en une seule fois).Exemple d’utilisation d’une variable globale\n#include <stdio.h>\nint i ;main(){  void optimist (void) ;   for (i=1 ; i<=5 ; i++)       optimist() ;}\nvoid optimist(void)\n{   printf (\"il fait beau %d fois\\n\", i) ;}\nil fait beau 1 foisil fait beau 2 foisil fait beau 3 foisil fait beau 4 foisil fait beau 5 foisDelannoy Livre.book  Page 106  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 107chapitre n° 6 La programmation modulaire et les fonctions\nAinsi, voyez, par exemple, ces instructions :\n      main()\n      {         ....      }        int n ;      float x ;      fct1 (...)      {         ....      }      fct2 (...)      {         ....      }\nLes variables n et x sont accessibles aux fonctions fct1 et fct2 , mais pas au programme\nprincipal. En pratique, bien qu’il soit possible effectivement de déclarer des variables globales\nà n’importe quel endroit du programme source qui soit extérieur aux fonctions, on procéderararement ainsi. En effet, pour d’évidentes raisons de lisibilité, on préférera regrouper les décla-rations de toutes les variables globales au début du programme source.\n7.3 La classe d’allocation des variables globales\nD’une manière générale, les variables globales existent pendant toute l’exécution du programmedans lequel elles apparaissent. Leurs emplacements en mémoire sont parfaitement déﬁnis lorsde l’édition de liens. On traduit cela en disant qu’elles font partie de la classe d’allocation\nstatique .\nDe plus, ces variables se voient initialisées à zéro , avant le début de l’exécution du programme,\nsauf, bien sûr, si vous leur attribuez explicitement une valeur initiale au moment de leurdéclaration.\n8Les variables locales\nÀ l’exception de l’exemple du paragraphe précédent, les variables que nous avions rencontréesjusqu’ici n’étaient pas des variables globales. Plus précisément, elles étaient déﬁnies au seind’une fonction (qui pouvait être \nmain ). De telles variables sont dites locales  à la fonction dans\nlaquelle elles sont déclarées.Delannoy Livre.book  Page 107  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n108 © Éditions Eyrolles8.1 La portée des variables locales\nLes variables locales ne sont connues qu’à l’intérieur de la fonction où elles sont déclarées.\nLeur portée est donc limitée à cette fonction.\nLes variables locales n’ont aucun lien avec des variables globales de même nom ou avec\nd’autres variables locales à d’autres fonctions. \nV oyez cet exemple :\n   int n ;\n   main()   {      int p ;      ....   }   fct1 ()   {      int p ;      int n ;   }\nLa variable p de main  n’a aucun rapport avec la variable p de fct1 . De même, la variable n\nde fct1  n’a aucun rapport avec la variable globale n. Notez qu’il est alors impossible, dans la\nfonction fct1 , d’utiliser cette variable globale n.\n8.2 Les variables locales automatiques\nPar défaut, les variables locales ont une durée de vie limitée à celle d’ une exécution  de la\nfonction dans laquelle elles ﬁgurent.\nPlus précisément, leurs emplacements ne sont pas déﬁnis de manière permanente comme ceux\ndes variables globales. Un nouvel espace mémoire leur est alloué à chaque entrée dans la fonc-tion et libéré à chaque sortie. Il sera donc généralement différent d’un appel au suivant.\nOn traduit cela en disant que la classe d’allocation  de ces variables est automatique . Nous\naurons l’occasion de revenir plus en détail sur cette gestion dynamique de la mémoire. Pour\nl’instant, il est important de noter que la conséquence immédiate de ce mode d’allocation estque les valeurs des variables locales ne sont pas conservées d’un appel au suivant (on dit aussiqu’elles ne sont pas « rémanentes »). Nous reviendrons un peu plus loin (paragraphe 11.2) surles éventuelles initialisations de telles variables. \nD’autre part, les valeurs transmises en arguments à une fonction sont traitées de la même\nmanière que les variables locales. Leur durée de vie correspond également à celle de la fonction.Delannoy Livre.book  Page 108  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 109chapitre n° 6 La programmation modulaire et les fonctions\n8.3 Les variables locales statiques\nIl est toutefois possible de demander d’attribuer un emplacement permanent à une variable\nlocale et qu’ainsi sa valeur se conserve d’un appel au suivant. Il sufﬁt pour cela de la déclarerà l’aide du mot-clé \nstatic  (le mot static  employé sans indication de type est équivalent à\nstatic  int) . \nEn voici un exemple :\nLa variable locale i a été déclarée de classe « statique ». On constate bien que sa valeur pro-\ngresse de un à chaque appel. De plus, on note qu’au premier appel sa valeur est nulle. En effet,\ncomme pour les variables globales (lesquelles sont aussi de classe statique) : les variables\nlocales de classe statique sont, par défaut, initialisées à zéro .\nPrenez garde à ne pas confondre une variable locale de classe statique avec une variableglobale. En effet, la portée d’une telle variable reste toujours limitée à la fonction dans laquelleelle est déﬁnie. Ainsi, dans notre exemple, nous pourrions déﬁnir une variable globale nom-mée \ni qui n’aurait alors aucun rapport avec la variable i de fct.Exemple d’utilisation de variable locale statique\n#include <stdio.h>\nmain(){  void fct(void) ;   int n ;   for ( n=1 ; n<=5 ; n++)      fct() ;}void fct(void){  static int i ;   i++ ;   printf (\"appel numéro : %d\\n\", i) ;}\nappel numéro : 1appel numéro : 2\nappel numéro : 3\nappel numéro : 4appel numéro : 5Delannoy Livre.book  Page 109  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n110 © Éditions Eyrolles8.4 Le cas des fonctions récursives\nLe langage C autorise la récursivité des appels de fonctions. Celle-ci peut prendre deux aspects :\n●récursivité directe : une fonction comporte, dans sa déﬁnition, au moins un appel à elle-même,\n●récursivité croisée : l’appel d’une fonction entraîne celui d’une autre fonction qui, à son tour,\nappelle la fonction initiale (le cycle pouvant d’ailleurs faire intervenir plus de deux fonctions).\nV oici un exemple fort classique (d’ailleurs inefﬁcace sur le plan du temps d’exécution) d’unefonction calculant une factorielle de manière récursive :\nIl faut bien voir qu’alors chaque appel de \nfac entraîne une allocation d’espace pour les varia-\nbles locales et pour son argument n (apparemment, fct ne comporte aucune variable locale ;\nen réalité, il lui faut prévoir un emplacement destiné à recevoir sa valeur de retour). Or chaque\nnouvel appel de fac,à l’intérieur de fac, provoque une telle allocation, sans que les emplace-\nments précédents soient libérés.\nIl y a donc un empilement des espaces alloués aux variables locales, parallèlement à un empi-\nlement des appels de la fonction. Ce n’est que lors de l’exécution de la première instruction\nreturn  que l’on commencera à « dépiler » les appels et les emplacements et donc à libérer de\nl’espace mémoire.\n9La compilation séparée et ses conséquences\nSi le langage C est effectivement un langage que l’on peut qualiﬁer d’opérationnel, c’est enpartie grâce à ses possibilités dites de compilation séparée . En C, en effet, il est possible de\ncompiler séparément plusieurs programmes (ﬁchiers) source et de rassembler les modulesobjet correspondants au moment de l’édition de liens. D’ailleurs, dans certains environne-ments de programmation, la notion de projet permet de gérer la multiplicité des ﬁchiers\n(source et modules objet) pouvant intervenir dans la création d’un programme exécutable.Cette notion de projet fait intervenir précisément les ﬁchiers à considérer ; généralement, il estpossible de demander de créer le programme exécutable, en ne recompilant que les sourcesayant subi une modiﬁcation depuis leur dernière compilation.\nIndépendamment de ces aspects techniques liés à l’environnement de programmation considéré,\nles possibilités de compilation séparée ont une incidence importante au niveau de la portée desvariables globales. C’est cet aspect que nous nous proposons d’étudier maintenant. Dans leFonction récursive de calcul de factorielle\nlong fac (int n)\n{   if (n>1) return (fac(n-1)*n) ;       else return(1) ;}Delannoy Livre.book  Page 110  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 111chapitre n° 6 La programmation modulaire et les fonctions\nparagraphe suivant, nous serons alors en mesure de faire le point sur les différentes classes\nd’allocation des variables.\nNotez que, à partir du moment où l’on parle de compilation séparée, il existe au moins (ou il\na existé) deux programmes source ; dans la suite, nous supposerons qu’ils ﬁgurent dans desﬁchiers, de sorte que nous parlerons toujours de ﬁchier source.\nPour l’instant, voyons l’incidence de cette compilation séparée sur la portée des variables globales.\n9.1 La portée d’une variable globale - la déclaration extern\nA priori, la portée d’une variable globale semble limitée au ﬁchier source dans lequel elle a été\ndéﬁnie. Ainsi, supposez que l’on compile séparément ces deux ﬁchiers source :\n     source 1                 source 2\n      int x ;                  fct2() \n      main()                   {      {                           .....         .....                 }      }                        fct3()      fct1()                   {      {                           .....         .....                 }\n      }\nIl ne semble pas possible, dans les fonctions fct2  et fct3  de faire référence à la variable\nglobale x déclarée dans le premier ﬁchier source (alors qu’aucun problème ne se poserait si\nl’on réunissait ces deux ﬁchiers source en un seul, du moins si l’on prenait soin de placer\nles instructions du second ﬁchier à la suite de celles du premier).\nEn fait, le langage C prévoit une déclaration permettant de spéciﬁer qu’une variable globale a\ndéjà été déﬁnie dans un autre ﬁchier source. Celle-ci se fait à l’aide du mot-clé extern . Ainsi,\nen faisant précéder notre second ﬁchier source de la déclaration :\nextern int x ;\nil devient possible de mentionner la variable globale x (déclarée dans le premier ﬁchier\nsource) dans les fonctions fct2  et fct3 .\nCette déclaration extern  n’effectue pas de réservation d’emplacement de variable. Elle ne\nfait que préciser que la variable globale x est définie par ailleurs et elle en précise le type.\nNous n’avons considéré ici que la façon la plus usuelle de gérer des variables globales (celle-ci\nest utilisable avec tous les compilateurs, qu’ils soient d’avant ou d’après la norme). La norme\nprévoit d’autres possibilités, au demeurant fort peu répandues et, de surcroît, peu logiques(doubles déclarations, mot \nextern  utilisé même pour la réservation d’un emplacement, défini-\ntions potentielles). Delannoy Livre.book  Page 111  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n112 © Éditions Eyrolles9.2 Les variables globales et l’édition de liens\nSupposons que nous ayons compilé les deux ﬁchiers source précédents et voyons d’un peu\nplus près comment l’éditeur de liens est en mesure de rassembler correctement les deux modulesobjet ainsi obtenus. En particulier, examinons comment il peut faire correspondre au symbole \nx\ndu second ﬁchier source l’adresse effective de la variable x déﬁnie dans le premier.\nD’une part, après compilation du premier ﬁchier source, on trouve, dans le module objet corres-pondant, une indication associant le symbole \nx et son adresse dans le module objet. Autrement\ndit, contrairement à ce qui se produit pour les variables locales, pour lesquelles ne subsisteaucune trace du nom après compilation, le nom des variables globales continue à exister auniveau des modules objet. On retrouve là un mécanisme analogue à ce qui se passe pour lesnoms de fonctions, lesquels doivent bien subsister pour que l’éditeur de liens soit en mesure deretrouver les modules objet correspondants.\nD’autre part, après compilation du second ﬁchier source, on trouve dans le module objet\ncorrespondant, une indication mentionnant qu’une certaine variable de nom \nx provient de\nl’extérieur et qu’il faudra en fournir l’adresse effective.\nCe sera effectivement le rôle de l’éditeur de liens que de retrouver dans le premier module\nobjet l’adresse effective de la variable x et de la reporter dans le second module objet.\nCe mécanisme montre que s’il est possible, par mégarde, de réserver des variables globalesde même nom dans deux ﬁchiers source différents, il sera, par contre, en général, impossibled’effectuer correctement l’édition de liens des modules objet correspondants (certains éditeursde liens peuvent ne pas détecter cette anomalie). En effet, dans un tel cas, l’éditeur de liensse trouvera en présence de deux adresses différentes pour un même identiﬁcateur, ce qui estillogique.\n9.3 Les variables globales cachées - la déclaration static\nIl est possible de « cacher » une variable globale, c’est-à-dire de la rendre inaccessible àl’extérieur du ﬁchier source où elle a été déﬁnie (on dit aussi « rendre conﬁdentielle » au lieude « cacher » ; on parle alors de « variables globales conﬁdentielles »). Il sufﬁt pour cela d’utiliserla déclaration \nstatic  comme dans cet exemple :\n     static int a ;\n     main()     {        .....     }     fct()     {        .....     }Delannoy Livre.book  Page 112  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 113chapitre n° 6 La programmation modulaire et les fonctions\nSans la déclaration static , a serait une variable globale ordinaire. Par contre, cette\ndéclaration demande qu’aucune trace de a ne subsiste dans le module objet résultant de ce\nﬁchier source. Il sera donc impossible d’y faire référence depuis une autre source par extern .\nMieux, si une autre variable globale apparaît dans un autre ﬁchier source, elle sera acceptée à\nl’édition de liens puisqu’elle ne pourra pas interférer avec celle du premier source.\nCette possibilité de cacher des variables globales peut s’avérer précieuse lorsque vous êtes\namené à développer un ensemble de fonctions d’intérêt général qui doivent partager des varia-bles globales. En effet, elle permet à l’utilisateur éventuel de ces fonctions de ne pas avoir à sesoucier des noms de ces variables globales puisqu’il ne risque pas alors d’y accéder parmégarde. Cela généralise en quelque sorte à tout un ﬁchier source la notion de variable localetelle qu’elle était déﬁnie pour les fonctions. Ce sont d’ailleurs de telles possibilités qui permettentde développer des logiciels en C, en utilisant une philosophie orientée objet.\n10Les différents types de variables, leur portée et leur classe \nd’allocation\nNous avons déjà vu différentes choses concernant les classes d’allocation des variables et leur\nportée. Ici, nous nous proposons de faire le point après avoir introduit quelques informationssupplémentaires.\n10.1 La portée des variables\nOn peut classer les variables en quatre catégories en fonction de leur portée (ou espace devalidité). Nous avons déjà rencontré les trois premières que sont : les variables globales, lesvariables globales cachées et les variables locales à une fonction. En outre, il est possible dedéﬁnir des variables locales à un bloc . Elles se déclarent en début d’un bloc de la même façon\nqu’en début d’une fonction. Dans ce cas, la portée de telles variables est limitée au bloc enquestion. Leur usage est, en pratique, peu répandu.\n10.2 Les classes d’allocation des variables\nIl est également possible de classer les variables en trois catégories en fonction de leur classe\nd’allocation. Là encore, nous avons déjà rencontré les deux premières, à savoir :\n●la classe statique : elle renferme non seulement les variables globales (quelles qu’elles\nsoient), mais aussi les variables locales faisant l’objet d’une déclaration static . Les\nemplacements mémoire correspondants sont alloués une fois pour toutes au moment del’édition de liens,Delannoy Livre.book  Page 113  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n114 © Éditions Eyrolles●la classe automatique : par défaut, les variables locales entrent dans cette catégorie. Les\nemplacements mémoire correspondants sont alloués à chaque entrée dans la fonction où\nsont déﬁnies ces variables et ils sont libérés à chaque sortie.\nEn toute rigueur, il existe une classe un peu particulière, à savoir la  classe registre :  toute\nvariable entrant a priori dans la classe automatique peut être déclarée explicitement avec lequaliﬁcatif \nregister . Celui-ci demande au compilateur d’utiliser, dans la mesure du possible,\nun registre pour y ranger la variable ; cela peut amener quelques gains de temps d’exécution.Bien entendu, cette possibilité ne peut s’appliquer qu’aux variables scalaires.\nLe cas des fonctions. La fonction est considérée par le langage C comme un objet global. C’est\nce qui permet d’ailleurs à l’éditeur de liens d’effectuer correctement son travail. Il faut noter toute-\nfois qu’il n’est pas nécessaire d’utiliser une déclaration extern  pour les fonctions définies dans un\nfichier source différent de celui où elles sont appelées (mais le faire ne constitue pas une erreur).\nEn tant qu’objet global, la fonction peut voir sa portée limitée au fichier source dans lequel elle\nest définie à l’aide d’une déclaration static  comme dans :\nstatic int fct (...)\n10.3 Tableau récapitulatif \nV oici un tableau récapitulant la portée et la classe d’allocation des différentes variables suivant\nla nature de leur déclaration (la colonne « Type » donne le nom qu’on attribue usuellement àde telles variables).\nType, portée et classe d’allocation des variables\nType de variable Déclaration Portée Classe d’allocation\nGlobale en dehors de toute \nfonction• la partie du fichier source suivant sa déclaration,• n’importe quel fichier source, avec \nextern .\nStatique Globale cachée en dehors de toute fonction, avec l’attribut \nstaticuniquement la partie du fichier source suivant sa déclaration \nLocale « rémanente » au début d’une fonction, avec l’attribut \nstaticla fonction\nLocale à une fonction au début d’une fonction la fonction\nAutomatique\nLocale à un bloc au début d’un bloc le blocDelannoy Livre.book  Page 114  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 115chapitre n° 6 La programmation modulaire et les fonctions\n11Initialisation des variables\nNous avons vu qu’il était possible d’initialiser explicitement une variable lors de sa décla-\nration. Ici, nous allons faire le point sur ces possibilités, lesquelles dépendent en fait de laclasse d’allocation de la variable concernée.\n11.1 Les variables de classe statique\nCes variables sont permanentes. Elles sont initialisées une seule fois avant le début de l’exécu-tion du programme.\nElles peuvent être initialisées explicitement lors de leur déclaration. Nous verrons que cela\ns’applique également aux tableaux ou aux structures. Bien entendu, les valeurs servant à cesinitialisations ne pourront être que des constantes ou des expressions constantes (c’est-à-direcalculables par le compilateur). N’oubliez pas que les constantes symboliques déﬁnies par\nconst  ne sont pas considérées comme des expressions constantes.\nEn l’absence d’initialisation explicite, ces variables seront initialisées à zéro.\n11.2 Les variables de classe automatique\nCes variables ne sont pas initialisées par défaut. En revanche, comme les variables de classestatique, elles peuvent être initialisées explicitement lors de leur déclaration.\nDans ce cas, lorsqu’il s’agit de variables scalaires (ce qui est le cas de toutes celles rencontrées\njusqu’ici, mais ne sera pas le cas des tableaux ou des structures), la norme vous autorise àutiliser comme valeur initiale non seulement une valeur constante, mais également n’importequelle expression (dans la mesure où sa valeur est déﬁnie au moment de l’entrée dans la fonctioncorrespondante, laquelle, ne l’oubliez pas, peut être la fonction \nmain ).\nEn voici un cas d’école :\nInitialisation de variables de classe automatique\n#include <stdio.h>\nint n ;main(){ void fct (int r) ;  int p ;  for (p=1 ; p<=5 ; p++)    { n = 2*p ;      fct(p) ;    }}void fct(int r){  int q=n, s=r*n ;  printf (\"%d %d %d\\n\", r,q,s) ;}Delannoy Livre.book  Page 115  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n116 © Éditions EyrollesN’oubliez pas que ces variables automatiques se trouvent alors initialisées à chaque appel de\nla fonction dans laquelle elles sont déﬁnies.\n12Les arguments variables en nombre\nDans tous nos précédents exemples, le nombre d’arguments fournis au cours de l’appel d’unefonction était prévu lors de l’écriture de cette fonction.\nOr, dans certaines circonstances, on peut souhaiter réaliser une fonction capable de recevoir un\nnombre d’arguments susceptible de varier d’un appel à un autre. C’est d’ailleurs ce que nousfaisons (sans même y penser) lorsque nous utilisons des fonctions comme \nprintf  ou scanf\n(en dehors du premier argument, qui représente le format, les autres sont en nombre quelconque)\nLe langage C permet de résoudre ce problème à l’aide des fonctions particulières va_start\net va_arg . La seule contrainte à respecter est que la fonction doit posséder certains argu-\nments ﬁxes (c’est-à-dire toujours présents), leur nombre ne pouvant être inférieur à un. En\neffet, comme nous allons le voir, c’est le dernier argument ﬁxe qui permet, en quelque sorte,d’initialiser le parcours de la liste d’arguments.\n12.1 Premier exemple\nV oici un premier exemple de fonction à arguments variables : les deux premiers arguments\nsont ﬁxes, l’un étant de type int, l’autre de type char . Les arguments suivants, de type int,\nsont en nombre quelconque et l’on a supposé que le dernier d’entre eux était -1. Cette\ndernière valeur sert donc, en quelque sorte, de sentinelle. Par souci de simpliﬁcation, nousnous sommes contentés, dans cette fonction, de lister les valeurs de ces différents arguments(ﬁxes ou variables), à l’exception du dernier.\nArguments en nombre variable délimités par une sentinelle \n#include <stdio.h>\n#include <stdarg.h>\nvoid essai (int par1, char  par2, ...)\n{   va_list adpar ;   int parv ;   printf (\"premier paramètre : %d\\n\", par1) ;   printf (\"second paramètre  : %c\\n\", par2) ;   va_start (adpar, par2) ;   while ( (parv = va_arg (adpar, int) ) != -1)       printf (\"argument variable : %d\\n\", parv) ;}Delannoy Livre.book  Page 116  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 117chapitre n° 6 La programmation modulaire et les fonctions\nV ous constatez la présence, dans l’en-tête, des deux noms des paramètres ﬁxes par1  et par2 ,\ndéclarés de manière classique ; les trois points servent à spéciﬁer au compilateur l’existence\nde paramètres en nombre variable.\nLa déclaration :\nva_list adpar\nprécise que adpar  est un identiﬁcateur de liste variable. C’est lui qui nous servira à récupérer,\nles uns après les autres, les différents arguments variables.Comme à l’accoutumée, une telle déclaration n’attribue aucune valeur à \nadpar . C’est effecti-\nvement la fonction va_start  qui va permettre de l’initialiser à l’adresse du paramètre variable.\nNotez bien que cette dernière est déterminée par va_start  à partir de la connaissance du\nnom du dernier paramètre ﬁxe.Le rôle de la fonction \nva_arg  est double :\n●d’une part, elle fournit comme résultat la valeur trouvée à l’adresse courante fournie par\nadpar  (son premier argument), suivant le type indiqué par son second argument (ici int).\n●d’autre part, elle incrémente l’adresse contenue dans adpar , de manière que celle-ci\npointe alors sur l’argument variable suivant.\nIci, une instruction while  nous permet de récupérer les différents arguments variables, sachant\nque le dernier a pour valeur -1.main()\n{   printf (\"premier essai\\n\") ;   essai (125, 'a', 15, 30, 40, -1) ;   printf (\"\\ndeuxième essai\\n\") ;   essai (6264, 'S', -1) ;}\npremier essai\npremier paramètre : 125second paramètre  : aargument variable : 15argument variable : 30argument variable : 40\ndeuxième essai\npremier paramètre : 6264second paramètre  : SArguments en nombre variable délimités par une sentinelle (suite)Delannoy Livre.book  Page 117  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n118 © Éditions EyrollesEnﬁn, la norme ANSI prévoit que la macro va_end  doit être appelée avant de sortir de la\nfonction concernée. Si vous manquez à cette règle, vous courrez le risque de voir un prochain\nappel à la fonction conduire à un mauvais fonctionnement du programme.\nLes arguments variables peuvent être de types différents, à condition toutefois que la fonction\nsoit en mesure de les connaître, d’une façon ou d’une autre.\nLes macros va_start  et va_end , ainsi que la description du type va_list , figurent dans le fichier\nen-tête stdarg.h  (d’où la directive #include  correspondante). Cette description utilise une\nméthode de définition de type (instruction typedef ) qui ne sera exposée que dans le chapitre\nrelatif aux structures. Notez bien qu’ici vous n’avez pas besoin de savoir ce qui se cache derrière\nva_list  pour l’utiliser correctement.\n12.2 Second exemple\nLa gestion de la ﬁn de la liste des arguments variables est laissée au bon soin de l’utilisateur ; eneffet, il n’existe aucune fonction permettant de connaître le nombre effectif de ces arguments.\nCette gestion peut se faire :\n●par sentinelle, comme dans notre précédent exemple,\n●par transmission, en argument ﬁxe, du nombre d’arguments variables.\nV oici un exemple de fonction utilisant cette seconde technique. Nous n’y avons pas prévu\nd’autres arguments ﬁxes que celui spéciﬁant le nombre d’arguments variables.\nArguments variables dont le nombre est fourni en argument fixe \n#include <stdio.h>\n#include <stdarg.h>void essai (int nbpar, ...){  va_list adpar ;   int parv, i ;   printf (\"nombre de valeurs : %d\\n\", nbpar) ;   va_start (adpar, nbpar) ;   for (i=1 ; i<=nbpar ; i++)     {  parv = va_arg (adpar, int) ;        printf (\"argument variable : %d\\n\", parv) ;     }}Delannoy Livre.book  Page 118  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 119chapitre n° 6 La programmation modulaire et les fonctions\nmain()\n{  printf (\"premier essai\\n\") ;   essai (3, 15, 30, 40) ;   printf (\"\\ndeuxième essai\\n\") ;   essai (0) ;}\npremier essai\nnombre de valeurs : 3argument variable : 15argument variable : 30argument variable : 40\ndeuxième essai\nnombre de valeurs : 0Arguments variables dont le nombre est fourni en argument fixe (suite)Delannoy Livre.book  Page 119  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n120 © Éditions EyrollesExercices\nTous ces exercices sont corrigés en fin de volume.\n1) Écrire :\n●une fonction, nommée f1, se contentant d’afficher \"bonjour\"  (elle ne possèdera aucun\nargument ni valeur de retour),\n●une fonction, nommée f2, qui affiche \"bonjour\"  un nombre de fois égal à la valeur reçue\nen argument ( int) et qui ne renvoie aucune valeur,\n●une fonction, nommée f3, qui fait la même chose que f2, mais qui, de plus, renvoie la valeur\n(int) 0.\nÉcrire un petit programme appelant successivement chacune de ces trois fonctions, après les\navoir convenablement déclarées sous forme d’un prototype.\n2) Qu’affiche le programme suivant ?\nint n=5 ;\nmain(){   void fct (int p) ;   int n=3 ;   fct(n) ;}void fct(int p){   printf(\"%d %d\", n, p) ;}\n3) Écrire une fonction qui se contente de comptabiliser le nombre de fois où elle a été appelée\nen affichant seulement un message de temps en temps, à savoir :\n●au premier appel : *** appel 1 fois ***\n●au dixième appel : *** appel 10 fois ***\n●au centième appel : *** appel 100 fois ***\n●et ainsi de suite pour le millième, le dix millième appel...\n●On supposera que le nombre maximal d’appels ne peut dépasser la capacité d’un long .\n4) Écrire une fonction récursive calculant la valeur de la « fonction d’Ackermann » A définie\npour m>0 et n>0 par :\nA(m,n) = A(m-1,A(m,n-1))     pour m>0 et n>0\nA(0,n) = n+1    pour n>0\nA(m,0) = A(m-1,1)    pour m>0Delannoy Livre.book  Page 120  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 121Chapitre 7\nLes tableaux et les pointeurs \nComme tous les langages, C permet d’utiliser des tableaux. On nomme ainsi un ensemble\nd’éléments de même type désignés par un identiﬁcateur unique ; chaque élément est repéré par\nun indice  précisant sa position au sein de l’ensemble.\nPar ailleurs, le langage C dispose de pointeurs , c’est-à-dire de variables destinées à contenir\ndes adresses d’autres objets  (variables, fonctions...).\nA priori, ces deux notions de tableaux et de pointeurs peuvent paraître fort éloignées l’une del’autre. Toutefois, il se trouve qu’en C un lien indirect existe entre ces deux notions, à savoirqu’un identiﬁcateur de tableau est une « constante pointeur ». Cela peut se répercuter dansle traitement des tableaux, notamment lorsque ceux-ci sont transmis en argument de l’appeld’une fonction.\nC’est ce qui justiﬁe que ces deux notions soient regroupées dans un seul chapitre.\n1Les tableaux à un indice \n1.1 Exemple d’utilisation d’un tableau en C\nSupposons que nous souhaitions déterminer, à partir de vingt notes d’élèves (fournies en\ndonnées), combien d’entre elles sont supérieures à la moyenne de la classe.Delannoy Livre.book  Page 121  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n122 © Éditions EyrollesS’il ne s’agissait que de calculer simplement la moyenne de ces notes, il nous sufﬁrait d’en\ncalculer la somme, en les cumulant dans une variable, au fur et à mesure de leur lecture. Mais,ici, il nous faut à nouveau pouvoir consulter les notes pour déterminer combien d’entre ellessont supérieures à la moyenne ainsi obtenue. Il est donc nécessaire de pouvoir mémoriser cesvingt notes.\nPour ce faire, il paraît peu raisonnable de prévoir vingt variables scalaires différentes (méthode\nqui, de toute manière, serait difﬁcilement transposable à un nombre important de notes).\nLe tableau va nous offrir une solution convenable à ce problème, comme le montre le pro-\ngramme suivant.\nLa déclaration :\nint t[20]\nréserve l’emplacement pour 20 éléments de type int. Chaque élément est repéré par sa posi-\ntion dans le tableau, nommée indice. Conventionnellement, en langage C, la première position\nporte le numéro 0. Ici, donc, nos indices vont de 0 à 19. Le premier élément du tableau sera\ndésigné par t[0] , le troisième par t[2] , le dernier par t[19] .\nPlus généralement, une notation telle que t[i]  désigne un élément dont la position dans le\ntableau est fournie par la valeur de i. Elle joue le même rôle qu’une variable scalaire de type int.\nLa notation &t[i]  désigne l’adresse de cet élément t[i]  de même que &n désignait l’adresse\nde n.Exemple d’utilisation d’un tableau\n#include <stdio.h>\nmain(){  int i, som, nbm ;   float moy ;   int t[20] ;\n   for (i=0 ; i<20 ; i++)\n      { printf (\"donnez la note numéro %d : \", i+1) ;        scanf (\"%d\", &t[i]) ;      }   for (i=0, som=0 ; i<20 ; i++)  som += t[i] ;   moy = som / 20 ;   printf (\"\\n\\n moyenne de la classe : %f\\n\", moy) ;   for (i=0, nbm=0 ; i<20 ; i++ )       if (t[i] > moy) nbm++ ;   printf (\"%d élèves ont plus de cette moyenne\", nbm) ;}Delannoy Livre.book  Page 122  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 123chapitre n° 7 Les tableaux et les pointeurs\n1.2 Quelques règles\na) Les éléments de tableau \nUn élément de tableau est une lvalue . Il peut donc apparaître à gauche d’un opérateur d’affec-\ntation comme dans :\nt[2] = 5\nIl peut aussi apparaître comme opérande d’un opérateur d’incrémentation, comme dans :\nt[3]++             --t[i]\nEn revanche, il n’est pas possible, si t1 et t2 sont des tableaux d’entiers, d’écrire t1 = t2  ;\nen fait, le langage C n’offre aucune possibilité d’affectations globales de tableaux, comme\nc’était le cas, par exemple, en Pascal.\nb) Les indices\nUn indice peut prendre la forme de n’importe quelle expression arithmétique de type entier(ou caractère, compte tenu des règles de conversion systématique). Par exemple, si \nn, p, k et j\nsont de type int, ces notations sont correctes :\nt[n-3]\nt[3*p-2*k+j%l]\nIl en va de même, si c1 et c2 sont de type char , de :\nt[c1+3]t[c2-c1]\nc) La dimension d’un tableau\nLa dimension d’un tableau (son nombre d’éléments) ne peut être qu’une constante ou une\nexpression constante . Ainsi, cette construction :\n#define N 50\n  .....int t[N] ;\nfloat h[2*N-1] ;\nest correcte. En revanche, elle ne le serait pas (en C) si N était une constante symbolique déﬁ-\nnie par const int N=50 , les expressions N et 2*N-1  n’étant alors plus calculables par le\ncompilateur (elle sera cependant acceptée en C++).\nd) Débordement d’indice\nAucun contrôle de débordement d’indice n’est mis en place par la plupart des compilateurs.\nDe sorte qu’il est très facile (si l’on peut dire !) de désigner et, donc, de modiﬁer, un emplace-ment situé avant ou après le tableau.Delannoy Livre.book  Page 123  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n124 © Éditions EyrollesPour être efficace, le contrôle d’indice devrait pouvoir se faire, non seulement dans le cas où\nl’indice est une constante, mais également dans tous les cas où il s’agit d’une expression quel-\nconque. Cela nécessiterait l’incorporation, dans le programme objet, d’instructions supplémen-taires assurant cette vérification lors de l’exécution, ce qui conduirait à une perte de temps. Parailleurs, nous verrons que le problème est rendu encore plus ardu, compte tenu de ce quel’accès à un élément d’un tableau peut également, en C, se faire par le biais d’un pointeur.Pour en comprendre les conséquences, il faut savoir que, lorsque le compilateur rencontre\nune lvalue  telle que \nt[i] , il en détermine l’adresse en ajoutant à l’adresse de début du\ntableau t, un décalage proportionnel à la valeur de i (et aussi proportionnel à la taille de\nchaque élément du tableau). \n   La norme C99 autorise que la dimension soit une expression quelconque, pour peu que sa\nvaleur soit calculable au moment où l’on rencontre la déclaration du tableau. Dans ce cas,l’attribution de l’emplacement mémoire correspondant sera réalisé à l'aide d’une technique de« gestion dynamique » semblable à celle présentée au chapitre 11 (mais ici, les instructions\nnécessaires seront mises en place automatiquement par le compilateur).\n2Les tableaux à plusieurs indices\n2.1 Leur déclaration\nComme tous les langages, C autorise les tableaux à plusieurs indices (on dit aussi à plusieurs\ndimensions). Par exemple, la déclaration :\nint t[5][3]\nréserve un tableau de 15 (5 x 3)  éléments. Un élément quelconque de ce tableau se trouve\nalors repéré par deux indices comme dans ces notations :\nt[3][2]     t[i][j]     t[i-3][i+j]\nNotez bien que, là encore, la notation désignant un élément d’un tel tableau est une lvalue . Il\nn’en ira toutefois pas de même de notations telles que t[3]  ou t[j]  bien que, comme nous\nle verrons un peu plus tard, de telles notations aient un sens en C.\nAucune limitation ne pèse sur le nombre d’indices que peut comporter un tableau. Seules les\nlimitations de taille mémoire liées à un environnement donné risquent de se faire sentir.\n2.2 Arrangement en mémoire des tableaux à plusieurs indices\nLes éléments d’un tableau sont rangés suivant l’ordre obtenu en faisant varier le dernier indiceen premier.\n  (Pascal utilise le même ordre, Fortran utilise l’ordre opposé). Ainsi, le tableau t\ndéclaré précédemment verrait ses éléments ordonnés comme suit :\n      t[0][0]\n      t[0][1]Delannoy Livre.book  Page 124  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 125chapitre n° 7 Les tableaux et les pointeurs\n      t[0][2]\n      t[1][0]      t[1][1]      t[1][2]        ....      t[4][0]      t[4][1]      \nt[4][2]\nNous verrons que cet ordre a une incidence dans au moins trois circonstances :\n●lorsque l’on omet de préciser certaines dimensions d’un tableau,\n●lorsque l’on souhaite accéder à l’aide d’un pointeur aux différents éléments d’un tableau,\n●lorsque l’un des indices « déborde ». Suivant l’indice concerné et les valeurs qu’il prend,\nil peut y avoir débordement d’indice sans sortie du tableau. Par exemple, toujours avecnotre tableau \nt de 5 x 3 éléments, vous voyez que la notation t[0][5]  désigne en fait\nl’élément t[1][2] . Par contre, la notation t[5][0]  désigne un emplacement situé juste\nau-delà du tableau.\nBien entendu, les différents points évoqués, dans le paragraphe 1.2, à propos des tableaux à\nune dimension, restent valables dans le cas des tableaux à plusieurs dimensions.\n3Initialisation des tableaux\nComme les variables scalaires, les tableaux peuvent être, suivant leur déclaration, de classestatique ou automatique. Les tableaux de classe statique sont, par défaut, initialisés à zéro ; lestableaux de classe automatique ne sont pas initialisés implicitement.\nIl est possible, comme on le fait pour une variable scalaire, d’initialiser (partiellement ou tota-\nlement) un tableau lors de sa déclaration. Cette fois, cependant, les valeurs fournies devrontobligatoirement être des expressions constantes, et cela quelle que soit la classe d’allocationdu tableau concerné (alors que les variables scalaires automatiques pouvaient être initialiséesavec des expressions quelconques).\nV oici quelques exemples vous montrant comment initialiser un tableau.\n3.1 Initialisation de tableaux à un indice\nLa déclaration :\nint tab[5] = { 10, 20, 5, 0, 3 } ;\nplace les valeurs 10, 20, 5, 0 et 3 dans chacun des cinq éléments du tableau tab.Delannoy Livre.book  Page 125  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n126 © Éditions EyrollesIl est possible de ne mentionner dans les accolades que les premières valeurs, comme dans ces\nexemples :\nint tab[5] = { 10, 20 } ;\nint tab[5] = { 10, 20, 5 } ;\nLes valeurs manquantes seront, suivant la classe d’allocation du tableau, initialisées à zéro\n(statique) ou aléatoires (automatique).\nDe plus, il est possible d’omettre la dimension du tableau, celle-ci étant alors déterminée par\nle compilateur par le nombre de valeurs énumérées dans l’initialisation. Ainsi, la premièredéclaration de ce paragraphe est équivalente à :\nint tab[] = { 10, 20, 5, 0, 3 } ;\nLa construction suivante :\n#define N 10\n   ...int tab[5] = { 2*N-1, N-1, N, N+1, 2*N+1}\nest correcte. Elle ne le serait pas, en revanche, si l’on définissait \nN comme une constante\nsymbolique entière par const  int N = 10.\n3.2 Initialisation de tableaux à plusieurs indices\nV oyez ces deux exemples équivalents (nous avons volontairement choisi des valeurs consécutives\npour qu’il soit plus facile de comparer les deux formulations) :\n   int tab [3] [4] = { { 1, 2, 3, 4 } ,\n                       { 5, 6, 7, 8 },                        { 9,10,11,12 }  }\n   int tab [3] [4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 } ;\nLa première forme revient à considérer notre tableau comme formé de trois tableaux de quatre\néléments chacun. La seconde, elle, exploite la manière dont les éléments sont effectivementrangés en mémoire et elle se contente d’énumérer les valeurs du tableau suivant cet ordre.\nLà encore, à chacun des deux niveaux, les dernières valeurs peuvent être omises. Les déclara-\ntions suivantes sont correctes (mais non équivalentes) :\n   int tab [3] [4] = { { 1, 2 } , { 3, 4, 5 } } ;\n      int tab [3] [4] = { 1, 2 , 3, 4, 5 } ;Delannoy Livre.book  Page 126  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 127chapitre n° 7 Les tableaux et les pointeurs\n4Notion de pointeur – Les opérateurs * et &\n4.1 Introduction\nNous avons déjà été amené à utiliser l’opérateur & pour désigner l’adresse d’une lvalue . D’une\nmanière générale, le langage C permet de manipuler des adresses par l’intermédiaire de\nvariables nommées pointeurs.\nEn guise d’introduction à cette nouvelle notion, considérons les instructions :\n    int * ad ;\n    int n ;    n = 20 ;    ad = &n ;    *ad = 30 ;\nLa première réserve une variable nommée ad comme étant un pointeur sur des entiers. Nous\nverrons que * est un opérateur qui désigne le contenu de l’adresse qui le suit. Ainsi, à titre\nmnémonique, on peut dire que cette déclaration signiﬁe que *ad, c’est-à-dire l’objet d’adresse\nad, est de type int ; ce qui signiﬁe bien que ad est l’adresse d’un entier.\nL ’instruction :\nad = &n ;\naffecte à la variable ad la valeur de l’expression &n. L ’opérateur & (que nous avons déjà utilisé\navec scanf ) est un opérateur unaire qui fournit comme résultat l’adresse de son opérande.\nAinsi, cette instruction place dans la variable ad l’adresse de la variable n. Après son exécution,\non peut schématiser ainsi la situation :\n       |         |           |   20   |       |_________| --------> |________|            ad                    n\nL ’instruction suivante :\n*ad = 30 ;\nsigniﬁe : affecter à la lvalue *ad la valeur 30. Or *ad représente l’entier ayant pour adresse\nad (notez bien que nous disons l’entier et pas simplement la valeur car, ne l’oubliez pas, ad est\nun pointeur sur des entiers). Après exécution de cette instruction, la situation est la suivante :\n       |         |           |   30   |       |_________| --------> |________|            ad                    nDelannoy Livre.book  Page 127  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n128 © Éditions EyrollesBien entendu, ici, nous aurions obtenu le même résultat avec :\nn = 30 ;\n4.2 Quelques exemples\nV oici quelques exemples d’utilisation de ces deux opérateurs. Supposez que nous ayons effectué\nces déclarations :\n    int * ad1, * ad2, * ad ;\n    int n = 10, p = 20 ;\nLes variables ad1, ad2 et ad sont donc des pointeurs sur des entiers. Remarquez bien la\nforme de la déclaration, en particulier, si l’on avait écrit :\n    int * ad1, ad2, ad ;\nla variable ad1 aurait bien été un pointeur sur un entier (puisque *ad1  est entier) mais ad2 et\nad auraient été, quant à eux, des entiers.\nConsidérons maintenant ces instructions :\n    ad1 = &n ;    ad2 = &p ;    * ad1 = * ad2 + 2 ;\nLes deux premières placent dans ad1 et ad2 les adresses de n et p. La troisième affecte à\n*ad1  la valeur de l’expression :\n* ad2 + 2\nAutrement dit, elle place à l’adresse désignée par ad1 la valeur (entière) d’adresse ad2,\naugmentée de 2. Cette instruction joue donc ici le même rôle que :\nn = p + 2 ;\nDe manière comparable, l’expression :\n* ad1 += 3 \njouerait le même rôle que :\nn = n + 3\net l’expression :\n( * ad1 ) ++\njouerait le même rôle que n++  (nous verrons plus loin que, sans les parenthèses, cette expression\naurait une signiﬁcation différente).Delannoy Livre.book  Page 128  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 129chapitre n° 7 Les tableaux et les pointeurs\nSi ad est un pointeur, les expressions ad et *ad sont des lvalue ; autrement dit ad et *ad sont\nmodifiables. En revanche, il n’en va pas de même de &ad. En effet, cette expression désigne,\nnon plus une variable pointeur comme ad, mais l’adresse de la variable ad telle qu’elle a été\ndéfinie par le compilateur. Cette adresse est nécessairement fixe et il ne saurait être question de\nla modifier (la même remarque s’appliquerait à &n, où n serait une variable scalaire quelconque).\nD’une manière générale, des expressions telles que :\n(&ad)++ ou (&p)++\nseront rejetées à la compilation.\nUne déclaration telle que :\nint * ad \nréserve un emplacement pour un pointeur sur un entier. Elle ne réserve pas en plus un empla-cement pour un tel entier. Cette remarque prendra encore plus d’acuité lorsque les objets pointés\nseront des chaînes ou des tableaux.\n4.3 Incrémentation de pointeurs\nJusqu’ici, nous nous sommes contenté de manipuler, non pas les variables pointeurs elles-\nmêmes, mais les valeurs pointées. Or si une variable pointeur ad a été déclarée ainsi :\nint * ad ;\nune expression telle que :\nad + 1\na un sens pour C.\nEn effet, ad est censée contenir l’adresse d’un entier et, pour C, l’expression ci-dessus repré-\nsente l’adresse de l’entier suivant . Certes, dans notre exemple, cela n’a guère d’intérêt car\nnous ne savons pas avec certitude ce qui se trouve à cet endroit. Mais nous verrons que cela\ns’avérera fort utile dans le traitement de tableaux ou de chaînes.\nNotez bien qu’il ne faut pas confondre un pointeur avec un nombre entier. En effet, l’expres-\nsion ci-dessus ne représente pas l’adresse de ad augmentée de un (octet). Plus précisément, la\ndifférence entre ad+1  et ad est ici de sizeof(int)  octets (n’oubliez pas que l’opérateur\nsizeof  fournit la taille, en octets, d’un type donné). Si ad avait été déclarée par :\ndouble * ad ;\ncette différence serait de sizeof(double)  octets.\nDe manière comparable, l’expression :\n ad++\nincrémente l’adresse contenue dans ad de manière qu’elle désigne l’objet  suivant.Delannoy Livre.book  Page 129  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n130 © Éditions EyrollesNotez bien que des expressions telles que ad+1  ou ad++  sont, en général, valides, quelle que\nsoit l’information se trouvant réellement à l’emplacement correspondant. D’autre part, il est\npossible d’incrémenter ou de décrémenter un pointeur de n’importe quelle quantité entière.Par exemple, avec la déclaration précédente de \nad, nous pourrions écrire ces instructions :\n   ad += 10 ;\n   ad -= 25 ;\nIl existera une exception à ces possibilités, à savoir le cas des pointeurs sur des fonctions,\ndont nous parlerons plus loin (vous pouvez dès maintenant comprendre qu’incrémenter un\npointeur d’une quantité correspondant à la taille d’une fonction n’a pas de sens en soi !).\n5Comment simuler une transmission par adresse avec un pointeur\nNous avons vu que le mode de transmission par valeur semblait interdire à une fonction de\nmodiﬁer la valeur de ses arguments effectifs et nous avions mentionné que les pointeurs four-niraient une solution à ce problème.\nNous sommes maintenant en mesure d’écrire une fonction effectuant la permutation des valeurs\nde deux variables. V oici un programme qui réalise cette opération avec des valeurs entières :\nUtilisation de pointeurs en argument d’une fonction\n#include <stdio.h>\nmain(){   void echange (int * ad1, int * ad2) ;   int a=10, b=20 ;   printf (\"avant appel %d %d\\n\", a, b) ;   echange (&a, &b) ;   printf (\"après appel %d %d\", a, b) ;}\nvoid echange (int * ad1, int * ad2)\n{  int x ;   x = * ad1 ;   * ad1 = * ad2 ;   * ad2 = x ;}\navant appel 10 20après appel 20 10Delannoy Livre.book  Page 130  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 131chapitre n° 7 Les tableaux et les pointeurs\nLes arguments effectifs de l’appel de echange  sont, cette fois, les adresses des variables n et\np (et non plus leurs valeurs). Notez bien que la transmission se fait toujours par valeur, à savoir\nque l’on transmet à la fonction echange  les valeurs des expressions &n et &p.\nV oyez comme, dans echange , nous avons indiqué, comme arguments muets, deux variables\npointeurs destinées à recevoir ces adresses. D’autre part, remarquez bien qu’il n’aurait pas\nfallu se contenter d’échanger simplement les valeurs de ces arguments en écrivant (par analogieavec la fonction \nechange  du chapitre précédent) :\n    int * x ;\n    x = ad1 ;\n    ad1 = ad2 ;\n    ad2 = x ;\nCela n’aurait conduit qu’à échanger (localement) les valeurs de ces deux adresses alors qu’il a\nfallu échanger les valeurs situées à ces adresses.\nLa fonction echange  n’a aucune raison, ici, de vouloir modifier les valeurs de ad1 et ad2. Nous\npourrions préciser dans son en-tête (et, du même coup, dans son prototype) que ce sont en fait\ndes constantes, en l’écrivant ainsi :\n   void echange (int * const ad1, int * const ad2) \nNotez bien, là encore, la syntaxe de la déclaration des arguments ad1 et ad2. Ainsi, la pre-\nmière s’interprète comme ceci :\n    * const  ad1  est de type int,\n     ad1 est donc une constante pointant sur un entier.\nIl n’aurait pas fallu écrire :\n    const int * ad1\ncar cela signifierait que :\n    int * ad1 est une constante, et que donc :\n    ad1 est un pointeur sur un entier constant.\nDans ce dernier cas, la valeur de ad1 serait modifiable ; en revanche, celle de *ad1  ne le serait\npas et notre programme conduirait à une erreur de compilation.Delannoy Livre.book  Page 131  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n132 © Éditions Eyrolles6Un nom de tableau est un pointeur constant\nEn langage C, l’identiﬁcateur d’un tableau, lorsqu’il est employé seul (sans indices à sa suite),\nest considéré comme un pointeur (constant) sur le début du tableau. Nous allons en examinerles conséquences en commençant par le cas des tableaux à un indice ; nous verrons en effetque, pour les tableaux à plusieurs indices, il faudra tenir compte du type exact du pointeur enquestion.\n6.1 Cas des tableaux à un indice\nSupposons, par exemple, que l’on effectue la déclaration suivante :\nint t[10]\nLa notation t est alors totalement équivalente à &t[0] .\nL ’identiﬁcateur t est considéré comme étant de type pointeur sur le type correspondant aux\néléments du tableau, c’est-à-dire, ici, int * . Ainsi, voici quelques exemples de notations\néquivalentes :\nt+1                &t[1]\nt+i                &t[i]t[i]               * (t+i)\nPour illustrer ces nouvelles possibilités de notation, voici plusieurs façons de placer la valeur 1\ndans chacun des 10 éléments de notre tableau t :\n    int i ;    for (i=0 ; i<10 ; i++)      * (t+i) = 1 ;\n    int i ;\n    int * p :    for (p=t, i=0 ; i<10 ; i++, p++)      * p = 1 ;\nDans la seconde façon, nous avons dû recopier la valeur représentée par t dans un pointeur\nnommé p. En effet, il ne faut pas perdre de vue que le symbole t représente une adresse\nconstante ( t est une constante de type pointeur sur des entiers). Autrement dit, une expression\ntelle que t++ aurait été invalide, au même titre que, par exemple, 3++. Un nom de tableau est\nun pointeur constant ; ce n’est pas une lvalue .Delannoy Livre.book  Page 132  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 133chapitre n° 7 Les tableaux et les pointeurs\nImportant. Nous venons de voir que la notation t[i]  est équivalente à *(t+i)  lorsque t\nest déclaré comme un tableau. En fait, cela reste vrai, quelle que soit la manière dont t a été\ndéclaré. Ainsi, avec :\n       int * t ;\nles deux notations précédentes resteraient équivalentes. Autrement dit, on peut utiliser t[i]\ndans un programme où t est simplement déclaré comme un pointeur (encore faudra-t-il, toute-\nfois, avoir alloué l’espace mémoire nécessaire).\n6.2 Cas des tableaux à plusieurs indices\nComme pour les tableaux à un indice, l’identiﬁcateur d’un tableau, employé seul, représente\ntoujours son adresse de début. Toutefois, si l’on s’intéresse à son type exact, il ne s’agit plusd’un pointeur sur des éléments du tableau. En pratique, ce point n’a d’importance que lorsquel’on effectue des calculs arithmétiques avec ce pointeur (ce qui est assez rare) ou lorsque l’ondoit transmettre ce pointeur en argument d’une fonction ; dans ce dernier cas, cependant, nousverrons que le problème est automatiquement résolu par la mise en place de conversions, desorte qu’on peut ne pas s’en préoccuper.\nÀ simple titre indicatif , nous vous présentons ici les règles employées par C, en nous limitant\nau cas de tableaux à deux indices.Lorsque le compilateur rencontre une déclaration telle que :\n     int t[3] [4] ;\nil considère en fait que t désigne un tableau de 3 éléments, chacun de ces éléments étant lui-\nmême un tableau de 4 entiers. Autrement dit, si t représente bien l’adresse de début de notre\ntableau t, il n’est plus de type int * (comme c’était le cas pour un tableau à un indice) mais\nd’un type « pointeur sur des blocs de 4 entiers », type qui devrait se noter théoriquement (vous\nn’aurez probablement jamais à utiliser cette notation :\nint [4] *\nDans ces conditions, une expression telle que t+1 correspond à l’adresse de t, augmentée de\n4 entiers (et non plus d’un seul !). Ainsi, les notations t et &t[0][0]  correspondent toujours\nà la même adresse, mais l’incrémentation de 1 n’a pas la même signiﬁcation pour les deux.\nD’autre part, les notations telles que t[0] , t[1]  ou t[i]  ont un sens. Par exemple, t[0]\nreprésente l’adresse de début du premier bloc (de 4 entiers) de t, t[1] , celle du second bloc...\nCette fois, il s’agit bien de pointeurs de type int *.  Autrement, dit les notations suivantes\nsont totalement équivalentes (elles correspondent à la même adresse et elles sont de mêmetype) :\n     t[0]   &t[0][0]\n     t[1]   &t[1][0]Delannoy Livre.book  Page 133  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n134 © Éditions EyrollesV oici un schéma récapitulant ce que nous venons de dire.\n   type int [4] *                type int *\n                     __          t ------->|__|<------- &t[0][0]  ou  t[0]                    |__|                    |__|<------- &t[0][2]                    |__|        t+1 ------->|__|<------- &t[1][0]  ou  t[1]                    |__|                    |__|                    |__|        t+2 ------->|__|<------ &t[2][0]  ou  t[2]                    |__|                    |__|                    |__|\nt[1] est une constante ; ce n’est pas une lvalue . L’expression :\nt[1]++\nest invalide. Par contre, t[1][2] est bien une lvalue .\n7Les opérateurs réalisables sur des pointeurs\nNous avons déjà vu ce qu’étaient la somme ou la différence d’un pointeur et d’une valeur\nentière. Nous allons examiner ici les autres opérations réalisables avec des pointeurs.\n7.1 La comparaison de pointeurs\nIl ne faut pas oublier qu’en C un pointeur est déﬁni à la fois par une adresse en mémoire et parun type. On ne pourra donc comparer que des pointeurs de même type . Par exemple, voici,\nen parallèle, deux suites d’instructions réalisant la même action : mise à 1 des 10 éléments dutableau \nt :\nint t[10] ;                         int t[10] ;\nint * p ;                           int i ;for (p=t ; p<t+10 ; p++)            for (i=0 ; i<10 ; i++)   *p = 1 ;                             t[i] = 1 ;Delannoy Livre.book  Page 134  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 135chapitre n° 7 Les tableaux et les pointeurs\n7.2 La soustraction de pointeurs\nLà encore, quand deux pointeurs sont de même type , leur différence fournit le nombre d’élé-\nments du type en question situés entre les deux adresses correspondantes. L ’emploi de cette\npossibilité est assez rare.\n7.3 Les affectations de pointeurs et le pointeur nul\nNous avons naturellement déjà rencontré des cas d’affectation de la valeur d’un pointeur à unpointeur de même type. A priori, c’est le seul cas autorisé par le langage C (du moins, tant quel’on ne procède pas à des conversions explicites). Une exception a toutefois lieu en ce quiconcerne la valeur entière 0, ainsi que pour le type générique \nvoid  * dont nous parlerons un\npeu plus loin. Cette tolérance est motivée par le besoin de pouvoir représenter un pointeur nul,c’est-à-dire ne pointant sur rien (c’est le nil du Pascal). Bien entendu, cela n’a d’intérêt queparce qu’il est possible de comparer n’importe quel pointeur (de n’importe quel type) avec ce« pointeur nul ».\nD’une manière générale, plutôt que la valeur 0, il est conseillé d’employer la constante \nNULL\nprédéﬁnie dans stdio.h , et également dans stddef.h  (bien entendu, elle sera remplacée\npar la constante entière 0 lors du traitement par le préprocesseur, mais les programmes source\nen seront néanmoins plus lisibles).Avec ces déclarations :\n    int * n ;\n    double * x ;\nces instructions seront correctes :\n    n = 0 ;            /* ou mieux */  n = NULL ;    x = 0 ;            /* ou mieux */  x = NULL ;    if (n == 0) ...    /* ou mieux */  if (n == NULL) ...\n7.4 Les conversions de pointeurs\nIl n’existe aucune conversion implicite d’un type pointeur dans un autre. En revanche, il est\ntoujours possible de faire appel à l’opérateur de cast . D’une manière générale, nous vous\nconseillons de l’éviter, compte tenu des risques qu’elle comporte. En effet, on pourrait penserqu’une telle conversion revient ﬁnalement à ne s’intéresser qu’à l’adresse correspondant à unpointeur, sans s’intéresser au type de l’objet pointé.\nMalheureusement, il faut tenir compte de ce que certaines machines imposent aux adresses\ndes objets ce que l’on appelle des « contraintes d’alignement ». Par exemple, un objet de 2 octetssera toujours placé à une adresse paire, tandis qu’un caractère (objet d’un seul octet) pourraêtre placé (heureusement) à n’importe quelle adresse. Dans ce cas, la conversion d’un \nchar  *\nen un int * peut conduire soit à l’adresse effective du caractère lorsque celle-ci est paire, soit\nà une adresse voisine lorsque celle-ci est impaire.Delannoy Livre.book  Page 135  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n136 © Éditions Eyrolles7.5 Les pointeurs génériques\nEn C, un pointeur correspond à la fois à une adresse en mémoire et à un type. Précisément, ce\ntypage des pointeurs peut s’avérer gênant dans certaines circonstances telles que celles où unefonction doit manipuler les adresses d’objets de type non connu (ou, plutôt, susceptible devarier d’un appel à un autre).\nDans certains cas, on pourra satisfaire un tel besoin en utilisant des pointeurs de type \nchar  *,\nlesquels, au bout du compte, nous permettront d’accéder à n’importe quel octet de la mémoire.\nToutefois, cette façon de procéder implique obligatoirement l’emploi de conversions explicites.\nEn fait, la norme ANSI a introduit le type pointeur suivant (il n’existait pas dans la déﬁnition\ninitiale du langage C, effectuée par Kernighan et Ritchie) :\nvoid *\nCelui-ci désigne un pointeur sur un objet de type quelconque  (on parle souvent de\n« pointeur générique »). Il s’agit (exceptionnellement) d’un pointeur sans type.\nUne variable de type void *  ne peut pas intervenir dans des opérations arithmétiques ;\nnotamment, si p et q sont de type void * , on ne peut pas parler de p+i (i étant entier) ou de\np-q ; on ne peut pas davantage utiliser l’expression p++ ; ceci est justiﬁé par le fait qu’on ne\nconnaît pas la taille des objets pointés. Pour des raisons similaires, il n’est pas possible\nd’appliquer l’opérateur d’indirection * à un pointeur de type void * .\nLes pointeurs génériques sont théoriquement compatibles avec tous les autres ; autrement dit,les affectations \ntype * -> void *  sont légales (ce qui ne pose aucun problème) mais les\naffectations void * -> type  * (elles seront d’ailleurs illégales en C++) le sont également,\nce qui présente les risques évoqués précédemment à propos des contraintes d’alignement.\nOn notera bien que, lorsqu’il est nécessaire à une fonction de travailler sur les différents octets\nd’un emplacement de type quelconque, le type void *  ne convient pas pour décrire les différents\noctets de cet emplacement et il faudra quand même recourir, à un moment ou à un autre, au type\nchar *  (mais les conversions void * --> char  * ne  poseront jamais de problème de con-\ntraintes d’alignement). Ainsi, pour écrire une fonction qui « met à zéro » un emplacement de lamémoire dont on lui fournit l’adresse et la taille (en octets), on pourrait songer à procéder ainsi :\nvoid raz (void * adr, int n)\n{    int i ;    for (i=0 ; i<n ; i++, adr++)  *adr = 0 ;        // illégal}\nManifestement, ceci est illégal et il faudra utiliser une variable de type char *  pour décrire\nnotre zone :\n    void raz (void * adr, int n)    {       int i ;Delannoy Livre.book  Page 136  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 137chapitre n° 7 Les tableaux et les pointeurs\n       char * ad = adr ;\n       for (i=0 ; i<n ; i++, ad++)  *ad = 0 ;           }\nV oici un exemple d’utilisation de notre fonction raz :\n    void raz (void *, int) ;      /* prototype réduit        */    int t[10] ;                   /* tableau à mettre à zéro */    double z ;                    /* double à mettre à zéro  */      ....    raz (t, 10*sizeof(int)) ;    raz (z, sizeof (z)) ;\n8Les tableaux transmis en argument\nLorsque l’on place le nom d’un tableau en argument effectif de l’appel d’une fonction, on\ntransmet ﬁnalement l’adresse du tableau à la fonction, ce qui lui permet d’effectuer toutes lesmanipulations voulues sur ses éléments, qu’il s’agisse d’utiliser leur valeur ou de la modiﬁer.V oyons quelques exemples pratiques.\n8.1 Cas des tableaux à un indice\na) Premier exemple : tableau de taille ﬁxe\nV oici un exemple de fonction qui met la valeur 1 dans tous les éléments d’un tableau de\n10 éléments, l’adresse de ce tableau étant transmise en argument.\nV oici deux exemples d’appels possibles de cette fonction :\n   int t1[10], t2[10] :\n     .....   fct(t1) ;     ....   fct(t2) ;Exemple de tableau transmis en argument d’une fonction (1)\nvoid fct (int t[10])\n{    int i ;   for (i=0 ; i<10 ; i++) t[i] =1 ;}Delannoy Livre.book  Page 137  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n138 © Éditions EyrollesL ’en-tête de fct peut être indifféremment écrit de l’une des manières suivantes :\nvoid fct (int t[10]) \nvoid fct (int * t)void fct (int t[])\nLa dernière écriture se justiﬁe par le fait que t désigne un argument muet. La réservation de\nl’emplacement mémoire du tableau dont on recevra ici l’adresse est réalisée par ailleurs dans\nla fonction appelante (d’ailleurs cette adresse peut changer d’un appel au suivant). D’autrepart, la connaissance de la taille exacte du tableau n’est pas indispensable au compilateur ; ilest en effet capable de déterminer l’adresse d’un élément quelconque, à partir de son rang et del’adresse de début du tableau (nous verrons qu’il n’en ira plus de même pour les tableaux àplusieurs indices). Dans ces conditions, on comprend qu’il soit tout à fait possible de ne pasmentionner la dimension du tableau dans l’en-tête de la fonction. En fait, le \n10 qui ﬁgure dans\nle premier en-tête n’a d’intérêt que pour le lecteur du programme, aﬁn de lui rappeler ladimension effective du tableau sur lequel travaillait notre fonction.\nPar ailleurs, comme d’habitude, quel que soit l’en-tête employé, on peut, dans la déﬁnition de\nla fonction, utiliser indifféremment le formalisme tableau ou le formalisme pointeur. V oiciplusieurs écritures possibles de \nfct qui s’accommodent de n’importe lequel des trois en-têtes\nprécédents (elles supposent que i a été déclaré de type int) :\n   for (i=0 ; i<10 ; i++)  t[i] = 1 ;\n   for (i=0 ; i<10 ; i++, t++) *t = 1 ;\n     for (i=0 ; i<10 ; i++)  *(t+i) = 1 ;\n   for (i=0 ; i<10 ; i++)  t[i] = 1 ;\n(ici encore, l’expression t++ ne pose aucun problème car t représente une copie de l’adresse\nd’un tableau ; t est donc bien une lvalue  et elle peut donc être incrémentée).\nV oici enﬁn une dernière possibilité dans laquelle nous recopions l’adresse t dans un pointeur\np et où nous utilisons les possibilités de comparaison de pointeurs :\n   int * p ;\n   for (p=t ; p<t+10 ; p++) *p = 1 ;\nb) Second exemple : tableau de taille variable\nComme nous venons de le voir, lorsqu’un tableau à un seul indice apparaît en argument d’une\nfonction, le compilateur n’a pas besoin d’en connaître la taille exacte. Il est ainsi facile de réa-liser une fonction capable de travailler avec un tableau de dimension quelconque, à conditionde lui en transmettre la taille en argument. V oici, par exemple, une fonction qui calcule lasomme des éléments d’un tableau d’entiers de taille quelconque :Delannoy Livre.book  Page 138  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 139chapitre n° 7 Les tableaux et les pointeurs\nV oici quelques exemples d’appels de cette fonction :\n   main()\n   {  int t1[30], t2[15], t3[10] ;      int s1, s2, s3 ;         .....      s1 = som(t1, 30) ;      s2 = som(t2, 15) + som(t3, 10) ;       .....   }\nEn C99, l’en-tête peut préciser la dimension d’un tableau, à condition que l’argument corres-\npondant apparaisse auparavant. On peut appliquer cette possibilité à la définition de la fonction\nsom précédente, à condition d’inverser l’ordre de ses arguments, en procédant ainsi :\n  int som (int nb, int t[nb])\nL’en-tête suivant serait rejeté :\n  int som (int t[nb], int nb)  /* incorrect, même en C99 */\n8.2 Cas des tableaux à plusieurs indices\na) Premier exemple : tableau de taille ﬁxe\nV oici un exemple d’une fonction qui place la valeur 1 dans chacun des éléments d’un tableau\nde dimensions 10 et 15 :Fonction travaillant sur un tableau de taille variable\nint som (int t[],int  nb)\n{  int s = 0, i ;   for (i=0 ; i<nb ; i++)         s += t[i] ;   return (s) ;}\nExemple de transmission en argument d’un tableau à deux dimensions (fixes)\nvoid raun (int t[10][15]){  int i, j ;   for (i=0 ; i<10 ; i++)      for (j=0 ; j<15 ; j++)         t[i][j] = 1 ;}Delannoy Livre.book  Page 139  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n140 © Éditions EyrollesIci, on pourrait, par analogie avec ce que nous avons dit pour un tableau à un indice, utiliser\nd’autres formes de l’en-tête. Toutefois, il faut bien voir que, pour trouver l’adresse d’un élé-ment quelconque d’un tableau à deux indices, le compilateur ne peut plus se contenter deconnaître son adresse de début ; il doit également connaître la seconde dimension du tableau(la première n’étant pas nécessaire compte tenu de la manière dont les éléments sont disposésen mémoire : revoyez le paragraphe 2). Ainsi, l’en-tête de notre fonction aurait pu être \nrau\n(int  t[][15]) mais pas rau (int  t[][]) .\nEn revanche, cette fois, quel que soit l’en-tête utilisé, cette fonction ne convient plus pour untableau de dimensions différentes de celles pour lesquelles elle a été prévue. Plus précisément,nous pourrons certes toujours l’appeler, comme dans cet exemple :\n    int mat [12][20] ;\n        .....\n    raun (mat) ;\n        .....\nMais, bien qu’aucun diagnostic ne nous soit fourni par le compilateur, l’exécution de ces ins-\ntructions placera 150 fois la valeur 1 dans certains des 240 emplacements de mat. Qui plus\nest, avec des tableaux dont la deuxième dimension est inférieure à 15, notre fonction placeraitdes \n1... en dehors de l’espace attribué au tableau !\nOn pourrait songer, par analogie avec ce qui a été fait pour les tableaux à un indice, à mélanger\nle formalisme pointeur et le formalisme tableau, à la fois dans l’en-tête et dans la définition de\nla fonction ; cela pose toutefois quelques problèmes que nous allons évoquer dans l’exemplesuivant consacré à un tableau de dimensions variables (et dans lequel le formalisme précédent\nn’est plus applicable).\nb) Second exemple : tableau de dimensions variables\nSupposons que nous cherchions à écrire une fonction qui place la valeur 0 dans chacun des\néléments de la diagonale d’un tableau carré de taille quelconque. Une façon de résoudre ceproblème consiste à adresser les éléments voulus par des pointeurs en effectuant le calculd’adresse approprié. \nFonction travaillant sur un tableau carré de taille variable\nvoid diag (int * p, int n)\n{   int i ;   for (i=0 ; i<n ; i++)     { * p = 0 ;       p += n+1 ;     }}Delannoy Livre.book  Page 140  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 141chapitre n° 7 Les tableaux et les pointeurs\nNotre fonction reçoit donc, en premier argument, l’adresse du premier élément du tableau,\nsous forme d’un pointeur de type int * . Ici, nous avons tenu compte de ce que deux éléments\nconsécutifs de la diagonale sont séparés par n éléments. Si, donc, un pointeur désigne un\nélément de la diagonale, pour pointer sur le suivant il sufﬁt d’incrémenter ce pointeur de n+1\nunités (l’unité étant ici la taille d’un entier).\nUn appel de notre fonction diag  se présentera ainsi :\nint t[30] [30] ;\ndiag (t, 30)\nOr l’argument effectif t est, certes, l’adresse de t, mais d’un type pointeur sur des blocs de\n10 entiers et non pointeur sur des entiers. En fait, la présence d’un prototype pour diag  fera\nqu’il sera converti en un int *. Ici, il n’y a aucun risque de modification d’adresse liée à des\ncontraintes d’alignement, car on passe de l’adresse d’un objet de taille 10n à l’adresse d’un\nobjet de taille n. Il n’en irait pas de même avec la conversion inverse.\nCette fonction pourrait également s’écrire en y déclarant un tableau à une seule dimension\ndont la taille ( n*n) devrait alors être fournie en argument (en plus de n). Le même mécanisme\nd’incrémentation de n+1 s’appliquerait alors, non plus à un pointeur, mais à la valeur d’un\nindice.\n9Utilisation de pointeurs sur des fonctions\nEn C, comme dans la plupart des autres langages, il n’est pas possible de placer le nom d’une\nfonction dans une variable. En revanche, on peut y déﬁnir une variable destinée à pointer surune fonction, c’est-à-dire à contenir son adresse.\nDe plus, en C, le nom d’une fonction (employé seul) est traduit par le compilateur en l’adresse\nde cette fonction. On retrouve là quelque chose d’analogue à ce qui se passait pour les noms detableaux, avec toutefois cette différence que les noms de fonctions sont externes (ils subsiste-ront dans les modules objet).\nCes deux remarques offrent en C des possibilités intéressantes. En voici deux exemples.\n9.1 Paramétrage d’appel de fonctions\nConsidérez cette déclaration :\nint (* adf) (double, int) ;\nElle spéciﬁe que :\n(* adf) est une fonction à deux arguments (de type double  et int) fournissant un\nrésultat de type int,Delannoy Livre.book  Page 141  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n142 © Éditions Eyrollesdonc que :\nadf est un pointeur sur une fonction à deux arguments ( double  et int) fournissant\nun résultat de type int.\nSi, par exemple, fct1  et fct2  sont des fonctions ayant les prototypes suivants :\nint fct1 (double, int) ;\nint fct2 (double, int) ;\nles affectations suivantes ont alors un sens :\nadf = fct1 ;adf = fct2 ;\nElles placent, dans adf, l’adresse de la fonction correspondante ( fct1  ou fct2 ). Dans ces\nconditions, il devient possible de programmer un « appel de fonction variable » (c’est-à-dire\nque la fonction appelée peut varier au ﬁl de l’exécution du programme) par une instructiontelle que :\n(* adf) (5.35, 4) ;\nCelle-ci, en effet, appelle la fonction dont l’adresse ﬁgure actuellement dans adf, en lui trans-\nmettant les valeurs indiquées ( 5.35  et 4). Suivant le cas, cette instruction sera donc équivalente\nà l’une des deux suivantes :\nfct1 (5.35, 4) ;\nfct2 (5.35, 4) ;\n9.2 Fonctions transmises en argument\nSupposez que nous souhaitions écrire une fonction permettant de calculer l’intégrale d’une\nfonction quelconque suivant une méthode numérique donnée. Une telle fonction que noussupposerons nommée \ninteg  posséderait alors un en-tête de ce genre :\nfloat integ ( float(*f)(float), ..... )\nLe premier argument muet correspond ici à l’adresse de la fonction dont on cherche à calculerl’intégrale. Sa déclaration peut s’interpréter ainsi :\n(*f)(float)  est de type float ,\n(*f)  est donc une fonction recevant un argument de type float  et fournissant un résultat\nde type float ,\nf est donc un pointeur sur une fonction recevant un argument de type float  et fournissant\nun résultat de type float .\nAu sein de la déﬁnition de la fonction integ , il sera possible d’appeler la fonction dont on\naura ainsi reçu l’adresse de la façon suivante :\n(*f) (x)Delannoy Livre.book  Page 142  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 143Notez bien qu’il ne faut surtout pas écrire f(x) , car f désigne ici un pointeur contenant\nl’adresse d’une fonction, et non pas directement l’adresse d’une fonction.\nL ’utilisation de la fonction integ  ne présente pas de difﬁcultés particulières. Elle pourrait se\nprésenter ainsi :\nmain()\n{   float fct1(float), fct2(float) ;       .....   res1 = integ (fct1, .....) ;       .....   res2 = integ (fct2, .....) ;       .....}Delannoy Livre.book  Page 143  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n144 © Éditions Eyrolles  Exercices\nTous ces exercices sont corrigés en fin de volume.\n1) Écrire, de deux façons différentes, un programme qui lit 10 nombres entiers dans un tableau\navant d’en rechercher le plus grand et le plus petit :\n●en utilisant uniquement le « formalisme tableau »,\n●en utilisant le « formalisme pointeur », chaque fois que cela est possible.\n2) Écrire une fonction qui ne renvoie aucune valeur et qui détermine la valeur maximale et lavaleur minimale d’un tableau d’entiers (à un indice) de taille quelconque. Il faudra donc prévoir4 arguments : le tableau, sa dimension, le maximum et le minimum.\nÉcrire un petit programme d’essai.\n3) Écrire une fonction permettant de trier par ordre croissant les valeurs entières d’un tableau\nde taille quelconque (transmise en argument). Le tri pourra se faire par réarrangement desvaleurs au sein du tableau lui-même.\n4) Écrire une fonction calculant la somme de deux matrices dont les éléments sont de type\ndouble . Les adresses des trois matrices et leurs dimensions (communes) seront transmises\nen argument.Delannoy Livre.book  Page 144  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 145Chapitre 8\nLes chaînes de caractères \nCertains langages (Java, Basic, anciennement Turbo Pascal) disposent d’un véritable type\nchaîne. Les variables d’un tel type sont destinées à recevoir des suites de caractères qui peu-vent évoluer, à la fois en contenu et en longueur, au ﬁl du déroulement du programme. Ellespeuvent être manipulées d’une manière globale, en ce sens qu’une simple affectation permetde transférer le contenu d’une variable de ce type dans une autre variable de même type.\nD’autres langages (Fortran, Pascal standard) ne disposent pas d’un tel type chaîne. Pour traiter\nde telles informations, il est alors nécessaire de travailler sur des tableaux de caractères dont lataille est nécessairement ﬁxe (ce qui impose à la fois une longueur maximale aux chaînes et cequi, du même coup, entraîne une perte de place mémoire). La manipulation de telles informa-tions est obligatoirement réalisée caractère par caractère et il faut, de plus, prévoir le moyen deconnaître la longueur courante de chaque chaîne.\nEn langage C, il n’existe pas de véritable type chaîne, dans la mesure où l’on ne peut pas y\ndéclarer des variables d’un tel type. En revanche, il existe une convention  de représentation\ndes chaînes. Celle-ci est utilisée à la fois :\n●par le compilateur pour représenter les chaînes constantes (notées entre doubles quotes) ;\n●par un certain nombre de fonctions qui permettent de réaliser :\n•les lectures ou écritures de chaînes ;\n•les traitements classiques tels que concaténation, recopie, comparaison, extraction de\nsous-chaîne, conversions...Delannoy Livre.book  Page 145  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n146 © Éditions EyrollesMais, comme il n’existe pas de variables de type chaîne, il faudra prévoir un emplacement\npour accueillir ces informations. Un tableau de caractères pourra faire l’affaire. C’estd’ailleurs ce que nous utiliserons dans ce chapitre. Mais nous verrons plus tard comment créerdynamiquement des emplacements mémoire, lesquels seront alors repérés par des pointeurs.\n1Représentation des chaînes\n1.1 La convention adoptée\nEn C, une chaîne de caractères est représentée par une suite d’octets correspondant à chacunde ses caractères (plus précisément à chacun de leurs codes), le tout étant terminé par un octetsupplémentaire de code nul. Cela signiﬁe que, d’une manière générale, une chaîne de \nn carac-\ntères occupe en mémoire un emplacement de n+1 octets.\n1.2 Cas des chaînes constantes\nC’est cette convention qu’utilise le compilateur pour représenter les « constantes chaîne »(sous-entendu que vous les introduisez dans vos programmes), sous des notations de la forme :\n\"bonjour\"      \nDe plus, une telle notation sera traduite par le compilateur en un pointeur (sur des éléments detype \nchar ) sur la zone mémoire correspondante.\nV oici un programme illustrant ces deux particularités :\nLa déclaration :\nchar * adr ;Convention de représentation des chaînes\n#include <stdio.h>\nmain(){  char * adr ;                                   bonjour   adr = \"bonjour\" ;   while (*adr)    { printf (\"%c\", *adr) ;      adr++ ;    } }Delannoy Livre.book  Page 146  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 147chapitre n° 8 Les chaînes de caractères\nréserve simplement l’emplacement pour un pointeur sur un caractère (ou une suite de caractères).\nEn ce qui concerne la constante :\n\"bonjour\"\nle compilateur a créé en mémoire la suite d’octets correspondants mais, dans l’affectation :\nadr = \"bonjour\"\nla notation bonjour  a comme valeur, non pas la valeur de la chaîne elle-même, mais son\nadresse ; on retrouve là le même phénomène que pour les tableaux.\nV oici un schéma illustrant ce phénomène. La ﬂèche en trait plein correspond à la situation\naprès l’exécution de l’affectation : adr = \"bonjour\"  ; les autres ﬂèches correspondent à\nl’évolution de la valeur de adr, au cours de la boucle.\n1.3 Initialisation de tableaux de caractères\nComme nous l’avons dit, vous serez souvent amené, en C, à placer des chaînes dans destableaux de caractères.\nMais, si vous déclarez, par exemple :\nchar ch[20] ;\nvous ne pourrez pas pour autant transférer une chaîne constante dans ch, en écrivant une\naffectation du genre :\nch = \"bonjour\" ;\nEn effet, ch est une constante pointeur qui correspond à l’adresse que le compilateur a attri-\nbuée au tableau ch ; ce n’est pas une lvalue ; il n’est donc pas question de lui attribuer une\nautre valeur (ici, il s’agirait de l’adresse attribuée par le compilateur à la constante chaîne\n\"bonjour\" ).\nEn revanche, C vous autorise à initialiser votre tableau de caractères à l’aide d’une chaîne\nconstante. Ainsi, vous pourrez écrire :\nchar ch[20] = \"bonjour\" ;adro \\0 r u o j n bDelannoy Livre.book  Page 147  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n148 © Éditions EyrollesCela sera parfaitement équivalent à une initialisation de ch réalisée par une énumération de\ncaractères (en n’omettant pas le code zéro – noté \\0) :\nchar ch[20] = { 'b','o','n','j','o','u','r','\\0' }\nN’oubliez pas que, dans ce dernier cas, les 12 caractères non initialisés explicitement seront :\n●soit initialisés à zéro (pour un tableau de classe statique) : on voit que, dans ce cas, l’omis-\nsion du caractère \\0 ne serait (ici) pas grave ;\n●soit aléatoires (pour un tableau de classe automatique) : dans ce cas, l’omission du carac-tère \\0 serait nettement plus gênante.\nDe plus, comme le langage C autorise l’omission de la dimension d’un tableau lors de sadéclaration, lorsqu’elle est accompagnée d’une initialisation, il est possible d’écrire uneinstruction telle que :\nchar message[] = \"bonjour\" ;\nCelle-ci réserve un tableau, nommé message , de 8 caractères  (compte tenu du 0 de ﬁn).\n1.4 Initialisation de tableaux de pointeurs sur des chaînes\nNous avons vu qu’une chaîne constante était traduite par le compilateur en une adresse quel’on pouvait, par exemple, affecter à un pointeur sur une chaîne. Cela peut se généraliser à untableau de pointeurs, comme dans :\nchar * jour[7] = { \"lundi\", \"mardi\", \"mercredi\", \"jeudi\",\n                   \"vendredi\", \"samedi\", \"dimanche\" } ;\nCette déclaration réalise donc à la fois la création des 7 chaînes constantes correspondant aux\n7 jours de la semaine et l’initialisation du tableau jour  avec les 7 adresses de ces 7 chaînes.\nV oici un exemple employant cette déclaration (nous y avons fait appel, pour l’afﬁchage d’unechaîne, au code de format \n%s, dont nous reparlerons un peu plus loin) :\nInitialisation d’un tableau de pointeurs sur des chaînes\nmain()\n{  char * jour[7] = { \"lundi\", \"mardi\", \"mercredi\", \"jeudi\",                      \"vendredi\", \"samedi\", \"dimanche\" } ;   int i ;   printf (\"donnez un entier entre 1 et 7 : \") ;   scanf (\"%d\", &i) ;   printf (\"le jour numéro %d de la semaine est %s\", i, jour[i-1] ) ;}\ndonnez un entier entre 1 et 7 : 3\nle jour numéro 3 de la semaine est mercrediDelannoy Livre.book  Page 148  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 149chapitre n° 8 Les chaînes de caractères\nLa situation présentée ne doit pas être confondue avec la précédente. Ici, nous avons affaire à\nun tableau de sept pointeurs, chacun d’entre eux désignant une chaîne constante (comme le\nfaisait adr dans le paragraphe 1.1). Le schéma ci- après récapitule les deux situations.\n2Pour lire et écrire des chaînes\nLe langage C offre plusieurs possibilités de lecture ou d’écriture de chaînes :\n●l’utilisation du code de format %s dans les fonctions printf  et scanf  ;\n●les fonctions spéciﬁques de lecture ( gets ) ou d’afﬁchage ( puts ) d’une chaîne (une seule\nà la fois).\nV oyez cet exemple de programme :jour\\0 i d e e r c r ma \\0 i d r mmessage\nu \\0 i d n lo \\0 r u o j n b\nEntrées-sorties classiques de chaînes \n#include <stdio.h>\nmain(){  char nom[20], prenom[20], ville[25] ;   printf (\"quelle est votre ville : \") ;   gets (ville) ;Delannoy Livre.book  Page 149  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n150 © Éditions EyrollesLes fonctions printf  et scanf  permettent de lire ou d’afﬁcher simultanément plusieurs\ninformations de type quelconque. En revanche, gets  et puts  ne traitent qu’une chaîne à la\nfois.\nDe plus, la délimitation de la chaîne lue ne s’effectue pas de la même façon avec scanf  et\ngets . Plus précisément :\n●avec le code %s de scanf , on utilise les délimiteurs habituels (l’espace ou la ﬁn de ligne).\nCela interdit donc la lecture d’une chaîne contenant des espaces. De plus, le caractère déli-\nmiteur n’est pas consommé : il reste disponible pour une prochaine lecture ;\n●avec gets , seule la ﬁn de ligne sert de délimiteur. De plus, contrairement à ce qui se produit\navec scanf , ce caractère est effectivement consommé : il ne risque pas d’être pris en\ncompte lors d’une nouvelle lecture.\nDans tous les cas, vous remarquerez que la lecture de n caractères implique le stockage enmémoire de n+1 caractères, car le caractère de ﬁn de chaîne (\n\\0) est généré automatiquement\npar toutes les fonctions de lecture (notez toutefois que le caractère séparateur – ﬁn de ligne ouautre – n’est pas recopié en mémoire).\nAinsi, dans notre précédent programme, il n’est pas possible (du moins pas souhaitable !) que\nle nom fourni en donnée contienne plus de 19 caractères.\nDans les appels des fonctions scanf  et puts , les identificateurs de tableau comme nom, pre-\nnom ou ville  n’ont pas besoin d’être précédés de l’opérateur & puisqu’ils représentent déjà\ndes adresses. La norme prévoit toutefois que si l’on applique l’opérateur & à un nom de\ntableau, on obtient l’adresse du tableau. Autrement dit, &nom  est équivalent à nom.\nLa fonction gets  fournit en résultat soit un pointeur sur la chaîne lue (c’est donc en fait la valeur\nde son argument), soit le pointeur nul en cas d’anomalie.\nLa fonction puts  réalise un changement de ligne à la fin de l’affichage de la chaîne, ce qui n’est\npas le cas de printf  avec le code de format %s.   printf (\"donnez votre nom et votre prénom : \") ;\n   scanf (\"%s %s\", nom, prenom) ;   printf (\"bonjour cher %s %s qui habitez à \", prenom, nom) ;   puts (ville) ;}\nquelle est votre ville : Parisdonnez votre nom et votre prénom : Dupont Yvesbonjour cher Yves Dupont qui habitez à ParisEntrées-sorties classiques de chaînes (suite)Delannoy Livre.book  Page 150  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 151chapitre n° 8 Les chaînes de caractères\nNous nous sommes limité ici aux entrées-sorties conversationnelles. Les autres possibilités\nseront examinées dans le chapitre consacré aux fichiers.\nSi, dans notre précédent programme, l’utilisateur introduit une fin de ligne entre le nom et le\nprénom, la chaîne affectée à prenom n’est rien d’autre que la chaîne vide ! Ceci provient de ce\nque la fin de ligne servant de délimiteur pour le premier %s n’est pas consommée et se trouve\ndonc reprise par le %s suivant...\nÉtant donné que gets  consomme la fin de ligne servant de délimiteur, alors que le code %s de\nscanf  ne le fait pas, il n’est guère possible, dans le programme précédent, d’inverser les utili-\nsations de scanf  et de gets  (en lisant la ville  par scanf  puis le nom et le prénom  par gets ) :\ndans ce cas, la fin de ligne non consommée par scanf  amènerait gets  à introduire une chaîne\nvide comme nom. D’une manière générale, d’ailleurs, il est préférable, autant que possible, de\nfaire appel à gets  plutôt qu’au code %s pour lire des chaînes.\n3Pour ﬁabiliser la lecture au clavier : \nle couple gets sscanf  \nNous avons vu, dans le chapitre concernant les entrées-sorties conversationnelles, les problè-\nmes posés par scanf  en cas de réponse incorrecte de la part de l’utilisateur.\nIl est possible de régler la plupart de ces problèmes en travaillant en deux temps :\n●lecture d’une chaîne de caractères par gets  (c’est-à-dire d’une suite de caractères quel-\nconques validés par « return ») ;\n●décodage de cette chaîne suivant un format, à l’aide de la fonction sscanf . En effet, une\ninstruction telle que :\nsscanf (adresse, format, liste_variables)\neffectue sur l’emplacement dont on lui fournit l’adresse (premier argument de type char  *)\nle même travail que scanf  effectue sur son tampon. La différence est qu’ici nous sommes\nmaître de ce tampon ; en particulier, nous pouvons décider d’appeler à nouveau sscanf  sur\nune nouvelle zone de notre choix (ou sur la même zone dont nous avons modiﬁé le contenupar \ngets ), sans  être tributaire de la position du pointeur, comme cela était le cas avec scanf .Delannoy Livre.book  Page 151  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n152 © Éditions EyrollesV oici un exemple d’instructions permettant de questionner l’utilisateur jusqu’à ce qu’il ait\nfourni une réponse satisfaisante\nNous avons prévu ici des lignes de 80 caractères au maximum. Nous risquons donc de voir le\ntableau ligne  « déborder » si l’utilisateur fournit une réponse plus longue. Dans la pratique, on\npeut augmenter la valeur de LG, notamment lorsque, comme c’est souvent le cas, on a affaire\nà une implémentation où les lignes frappées au clavier ont une taille maximale. Si l’on cherche\nà réaliser un programme« portable », on préférera une solution qui consiste à remplacer gets\npar fgets  (stdin ,...) dont nous parlerons dans le chapitre consacré aux fichiers. La démarche\nrestera identique à celle présentée ici.Contrôle des entrées avec gets et sscanf\n#include <stdio.h>\n#define LG 80main()\n{\n   int n, compte ;   char c ;   char ligne [LG+1] ;   do      { printf (\"donnez un entier et un caractère : \") ;        gets (ligne) ;        compte = sscanf (ligne, \"%d %c\", &n, &c) ;      }   while (compte < 2 ) ;   printf (\"merci pour %d %c\\n\", n, c) ;}\ndonnez un entier et un caractère : bofdonnez un entier et un caractère : a 125donnez un entier et un caractère : 12 bonjourmerci pour 12 bDelannoy Livre.book  Page 152  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 153chapitre n° 8 Les chaînes de caractères\n4Généralités sur les fonctions portant sur des chaînes\nC dispose de nombreuses fonctions de manipulation de chaînes. Avant d’en voir les principales\n(les autres étant, de toute façon, présentées dans l’annexe), voyons quelques principes généraux.\n4.1 Ces fonctions travaillent toujours sur des adresses\nTout d’abord, rappelons qu’il n’y a pas de véritable type chaîne en C, mais simplement uneconvention de représentation. On ne peut donc jamais transmettre la valeur d’une chaîne, maisseulement son adresse, ou plus précisément un pointeur sur son premier caractère. Ainsi, pourcomparer deux chaînes, on transmettra à la fonction concernée (ici, \nstrcmp ) deux pointeurs\nde type char * .\nMieux, pour recopier une chaîne d’un emplacement à un autre, on fournira à la fonctionvoulue (ici, \nstrcpy ) l’adresse de la chaîne à copier et l’adresse de l’emplacement où devra\nse faire la copie. Encore faudra-t-il avoir prévu de disposer de sufﬁsamment de place à cetendroit ! En effet, rien ne permet à la fonction de reconnaître qu’elle a écrit au-delà de ce quevous vouliez. En fait, vous disposerez cependant d’une façon de vous prémunir contre de telsrisques ; en effet, toutes les fonctions qui placent ainsi une information (susceptible d’êtred’une longueur quelconque) à un emplacement d’adresse donnée possèdent deux variantes :l’une travaillant sans contrôle, l’autre possédant un argument supplémentaire permettant delimiter le nombre de caractères effectivement copiés à l’adresse concernée.\n4.2 La fonction strlen\nLa fonction strlen  fournit en résultat la longueur d’une chaîne dont on lui a transmis\nl’adresse en argument. Cette longueur correspond tout naturellement au nombre de caractèrestrouvés depuis l’adresse indiquée jusqu’au premier caractère de code nul, ce caractère n’étantpas pris en compte dans la longueur. \nPar exemple, l’expression :\nstrlen (\"bonjour\") \nvaudra 7 ; de même, avec :\nchar * adr = \"salut\" ;\nl’expression :\nstrlen (adr)\nvaudra 5.Delannoy Livre.book  Page 153  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n154 © Éditions Eyrolles4.3 Le cas des fonctions de concaténation\nIl existe des fonctions dites de concaténation, c’est-à-dire de mise bout à bout de deux chaînes.\nA priori, de telles fonctions créent une nouvelle chaîne à partir de deux autres. Elles devraientdonc recevoir en argument trois adresses ! En fait, C a prévu de se limiter à deux adresses enconvenant arbitrairement que la chaîne résultante serait obtenue en ajoutant la seconde à la ﬁnde la première, laquelle se trouve donc détruite en tant que chaîne (en fait, seul son \n\\0 de ﬁn a\ndisparu...). Là encore, on trouvera deux variantes dont l’une permet de limiter la longueur dela chaîne résultante.\nPour vous familiariser avec cette façon guère naturelle de manipuler les chaînes, nous vous\nprésenterons d’abord en détail les fonctions de concaténation et de copie (ce sont les plus uti-lisées). Les indications fournies ensuite, ainsi que l’annexe, devraient vous permettre de pouvoirfaire appel aux autres sans difﬁculté.\n5Les fonctions de concaténation de chaînes\n5.1 La fonction strcat\nV oyez cet exemple :\nNotez la différence entre les deux déclarations (avec initialisation) de chacune des deux chaînes\nch1 et ch2. La première permet de réserver un emplacement plus grand que la constante\nchaîne qu’on y place initialement.Fonction strcat\n#include <stdio.h>\n#include <string.h>main(){   char ch1[50] = \"bonjour\" ;   char * ch2 = \" monsieur\" ;                    printf (\"avant : %s\\n\", ch1) ;                strcat (ch1, ch2) ;   printf (\"après : %s\", ch1) ;}\navant : bonjouraprès : bonjour monsieurDelannoy Livre.book  Page 154  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 155chapitre n° 8 Les chaînes de caractères\nL ’appel de strcat  se présente ainsi (nous placerons souvent en regard de la présentation de\nl’appel d’une fonction le nom du ﬁchier qui en contient le prototype) :\nstrcat ( but, source )          (string.h)\nCette fonction recopie la seconde chaîne ( source ) à la suite de la première ( but), après en\navoir effacé le caractère de ﬁn.\nstrcat  fournit en résultat :\n• l’adresse de la chaîne correspondant à la concaténation des deux chaînes fournies en argu-\nment, lorsque l’opération s’est bien déroulée ; cette adresse n’est rien d’autre que celle de ch1\n(laquelle n’a pas été modifiée – c’est d’ailleurs une constante pointeur),\n• le pointeur nul lorsque l’opération s’est mal déroulée.\nIl est nécessaire que l’emplacement réservé pour la première chaîne soit suffisant pour y\nrecevoir la partie à lui concaténer.\n5.2 La fonction strncat\nCette fonction dont l’appel se présente ainsi :\nstrncat (but, source, lgmax)          (string.h)\ntravaille de façon semblable à strcat  en offrant en outre un contrôle sur le nombre de carac-\ntères qui seront concaténés à la chaîne d’arrivée ( but).\nEn voici un exemple d’utilisation :\nFonction strncat\n#include <stdio.h>\n#include <string.h>main(){   char ch1[50] = \"bonjour\" ;   char * ch2 = \" monsieur\" ;   printf (\"avant : %s\\n\", ch1) ;   strncat (ch1, ch2, 6) ;   printf (\"après : %s\", ch1) ;}\navant : bonjour\naprès : bonjour monsiDelannoy Livre.book  Page 155  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n156 © Éditions EyrollesNotez bien que le contrôle ne porte pas directement sur la longueur de la chaîne ﬁnale.\nFréquemment, on déterminera ce nombre maximal de caractères à recopier comme étant ladifférence entre la taille totale de la zone réceptrice et la longueur courante de la chaîne quis’y trouve. Cette dernière s’obtiendra par la fonction \nstrlen  présentée à la section 4.2.\n6Les fonctions de comparaison de chaînes\nIl est possible de comparer deux chaînes en utilisant l’ordre des caractères déﬁnis par leur code.\na) La fonction :\nstrcmp ( chaîne1, chaîne2 )\ncompare deux chaînes dont on lui fournit l’adresse et elle fournit une valeur entière déﬁnie\ncomme étant :\n●positive si chaîne1 > chaîne2  (c’est-à-dire si chaîne1  arrive après chaîne2 , au\nsens de l’ordre déﬁni par le code des caractères) ;\n●nulle si chaîne1 = chaîne2  (c’est-à-dire si ces deux chaînes contiennent exactement\nla même suite de caractères) ;\n●négative si chaîne1 < chaîne2 .\nPar exemple (quelle que soit l’implémentation) :\nstrcmp (\"bonjour\", \"monsieur\")\nest négatif et :\nstrcmp (\"paris2\", \"paris10\")\nest positif.\nb) La fonction :\nstrncmp ( chaîne1, chaîne2, lgmax )\ntravaille comme strcmp  mais elle limite la comparaison au nombre maximal de caractères\nindiqués par l’entier lgmax .\nPar exemple :\nstrncmp (\"bonjour\", \"bon\", 4)\nest positif tandis que :\nstrncmp (\"bonjour\", \"bon\", 2)\nvaut zéro.Delannoy Livre.book  Page 156  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 157chapitre n° 8 Les chaînes de caractères\nc) Enﬁn, deux fonctions :\nstricmp ( chaîne1, chaîne2 )                  ( string.h )\nstrnicmp ( chaîne1, chaîne2, lgmax )          ( string.h )\ntravaillent respectivement comme strcmp  et strncmp , mais sans tenir compte de la diffé-\nrence entre majuscules et minuscules (pour les seuls caractères alphabétiques).\n7 Les fonctions de copie de chaînes\na) La fonction :\nstrcpy ( but, source )          (string.h)\nrecopie la chaîne située à l’adresse source  dans l’emplacement d’adresse destin . Là\nencore, il est nécessaire que la taille du second emplacement soit sufﬁsante pour accueillir la\nchaîne à recopier, sous peine d’écrasement intempestif.\nCette fonction fournit comme résultat l’adresse de la chaîne but.\nb) La fonction :\nstrncpy ( but, source, lgmax )          (string.h)\nprocède de manière analogue à strcpy , en limitant la recopie au nombre de caractères précisés\npar l’expression entière lgmax .\nNotez bien que, si la longueur de la chaîne source est inférieure à cette longueur maximale,\nson caractère de ﬁn ( \\0) sera effectivement recopié. Mais, dans le cas contraire, il ne le sera\npas. L ’exemple suivant illustre les deux situations :\nFonctions de recopie de chaînes : strcpy et strncpy\n#include <stdio.h>\n#include <string.h>main(){   char ch1[20] = \"xxxxxxxxxxxxxxxxxxx\" ;   char ch2[20] ;   printf (\"donnez un mot : \") ;   gets (ch2) ;   strncpy (ch1, ch2, 6) ;   printf (\"%s\", ch1) ;}Delannoy Livre.book  Page 157  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n158 © Éditions Eyrolles8 Les fonctions de recherche dans une chaîne\nOn trouve, en langage C, des fonctions classiques de recherche de l’occurrence dans une\nchaîne d’un caractère ou d’une autre chaîne (nommée alors sous-chaîne). Elles fournissentcomme résultat un pointeur de type \nchar  * sur l’information cherchée en cas de succès, et\nle pointeur nul dans le cas contraire. V oici les principales.\nstrchr ( chaîne, caractère )          (string.h)\nrecherche, dans chaîne , la première position où apparaît le caractère mentionné.\nstrrchr ( chaîne, caractère )        (string.h)\nréalise le même traitement que strchr , mais en explorant la chaîne concernée à partir de la\nﬁn. Elle fournit donc la dernière occurrence du caractère mentionné.\nstrstr ( chaîne, sous-chaîne )          (string.h)\nrecherche, dans chaîne , la première occurrence complète de la sous-chaîne mentionnée.\n9Les fonctions de conversion\n9.1 Conversion d’une chaîne en valeurs numériques\nIl existe trois fonctions permettant de convertir une chaîne de caractères en une valeur numériquede type \nint, long  ou double . Ces fonctions ignorent les éventuels espaces de début de chaîne\net, à l’image de ce que font les codes de format %d, %ld et %f, utilisent les caractères suivants\npour fabriquer une valeur numérique. Le premier caractère invalide arrête l’exploration. Enrevanche, ici, si aucun caractère n’est exploitable, ces fonctions fournissent un résultat nul.\natoi ( chaîne )          (stdlib.h)\nfournit un résultat de type int.Fonctions de recopie de chaînes : strcpy et strncpy (suite)\ndonnez un mot : bon\nbon\n_______\ndonnez un mot : bonjour\nbonjouxxxxxxxxxxxxx Delannoy Livre.book  Page 158  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 159chapitre n° 8 Les chaînes de caractères\natol ( chaîne )          (stdlib.h)\nfournit un résultat de type long .\natof ( chaîne )           (stdlib.h)\nfournit un résultat de type double .\nNotez que ces fonctions effectuent le même travail que sscanf  appliquée à une seule variable,\navec le code de format approprié. Par exemple (si n est de type int et adr de type char *)  :\nn = atoi (adr) ;\nfait la même chose que :\nsscanf (adr, \"%d\", &n) ;\n9.2 Conversion de valeurs numériques en chaîne\nLa norme ne prévoit pas de fonctions de conversion d’une valeur numérique en chaîne, c’est-\nà-dire de fonctions jouant le rôle symétrique des fonctions atoi , atol , atof  et atod . En\nrevanche, elle prévoit une fonction sprintf , symétrique de sscanf . Elle permet de conver-\ntir en chaîne une succession de valeurs numériques, en y incorporant, le cas échéant, d’autrescaractères. Par exemple, si \nn, de type int, contient 15 et si p, de type float , contient\n785.35  et si tab est un tableau de caractères de taille sufﬁsante, l’instruction suivante :\nsprintf (tab, \"%d articles coutent %f8.2 F\", n, p) ;\nplacera dans tab, la chaîne suivante (elle sera bien terminée par un caractère \\0) :\n15 articles coutent   785.35 F\n10Quelques précautions à prendre avec les chaînes\nDans ce chapitre, nous avons examiné bon nombre des conséquences de la manière artiﬁcielledont le langage C gère les chaînes. Cependant, par souci de clarté, nous nous sommes limitéaux situations les plus courantes. V oici ici quelques compléments d’information concernantdes situations moins usitées mais dont la méconnaissance peut nuire à la bonne mise au pointdes programmes.\n10.1 Une chaîne possède une vraie ﬁn, mais pas de vrai début\nComme nous l’avons vu, il existe effectivement une convention de représentation de la ﬁnd’une chaîne ; en revanche, rien de comparable n’est prévu pour son début. En fait, touteadresse de type \nchar  * peut toujours faire ofﬁce d’adresse de début de chaîne.Delannoy Livre.book  Page 159  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n160 © Éditions EyrollesPar exemple, avec cette déclaration :\nchar * adr = \"bonjour\" ;\nune expression telle que :\nstrlen (adr+2)\nserait acceptée : elle aurait pour valeur 5 (longueur de la chaîne commençant en adr+2 ).\nDe même, dans l’exemple de programme du paragraphe 5.1, il serait tout à fait possible de\nremplacer :\nstrcat (ch1, ch2) ;\npar :\nstrcat (ch1, ch2+4) ;\nLe programme afﬁcherait alors simplement :\nbonjoursieur\nPlus curieusement, si l’on remplace cette fois cette même instruction par :\nstrcat (ch1+2, ch2) ;\non obtiendra le même résultat qu’avec le programme initial ( bonjour  monsieur ) puisque\nch2 sera toujours concaténée à partir du même 0 de ﬁn !\nEn revanche, avec :\nstrcat (ch1+10, ch2) ;\nles choses seraient nettement catastrophiques : on viendrait écraser un emplacement situé endehors de la chaîne d’adresse \nch1.\n10.2 Les risques de modiﬁcation des chaînes constantes\nNous avons vu que, dans une instruction telle que :\nchar * adr = \"bonjour\" ;\nle compilateur remplace la notation \"bonjour\"  par l’adresse d’un emplacement dans lequel\nil a rangé la succession de caractères voulus.\nDans ces conditions, on peut se demander ce qui va se produire si l’on tente de modiﬁer l’un\nde ces caractères par une banale affectation telle que :\n*adr = 'x' ;      /* bonjour va-t-il se transformer en xonjour ? */\n* (adr+2) = 'x' ; /* bonjour va-t-il se transformer en boxjour ? */Delannoy Livre.book  Page 160  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 161chapitre n° 8 Les chaînes de caractères\nA priori, la norme interdit la modiﬁcation de quelque chose de constant. En pratique, beau-\ncoup de compilateurs l’acceptent, de sorte que l’on aboutit à la modiﬁcation de notre constante\nbonjour  en xonjour  ou boxjour  ! Nous pourrions, par exemple, le constater en exécutant\nune instruction telle que puts (adr) .\nSignalons qu’une constante chaîne apparaît également dans une instruction telle que :\nprintf (\"bonjour\") ;\nIci, on pourrait penser que sa modiﬁcation n’est guère possible puisque nous n’avons pasaccès à son adresse. Cependant, lorsque cette même constante (\nbonjour ) apparaît en plu-\nsieurs emplacements d’un programme, certains compilateurs peuvent ne la créer qu’une fois ;dans ces conditions, la chaîne transmise à \nprintf  peut très bien se trouver modiﬁée par le\nprocessus décrit précédemment...\nDans une déclaration telle que :\nchar ch[20] = \"bonjour\" ;\nil n’apparaît pas de chaîne constante, et ceci malgré la notation employée ( \"...\" ) laquelle, ici,\nn’est qu’une facilité d’écriture remplaçant l’initialisation des premiers caractères du tableau ch.\nEn particulier, toute modification de l’un des éléments de ch, par une instruction telle que :\n* (ch + 3) = 'x' ;\nest parfaitement licite (nous n’avons aucune raison de vouloir que le contenu du tableau ch\nreste constant).\n11 Les arguments transmis à la fonction main\n11.1 Comment passer des arguments à un programme\nLa fonction main  peut récupérer les valeurs des arguments fournis au programme lors de son\nlancement. Le mécanisme utilisé par l’utilisateur pour fournir ces informations dépend de\nl’environnement. Il peut s’agir de commandes de menus pour des environnements dits graphi-ques ou intégrés. Dans les environnements fonctionnant en mode texte (tels DOS ou Unix), ils’agit de valeurs associées à la commande de lancement du programme (d’où le terme d’argu-ments de la ligne de commande encore utilisé parfois pour décrire ce mécanisme). En voici unexemple où l’on demande l’exécution du programme nommé \ntest , en lui transmettant les\narguments arg1 , arg2  et arg3  :\ntest arg1 arg2 arg3Delannoy Livre.book  Page 161  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n162 © Éditions Eyrolles11.2 Comment récupérer ces arguments dans la fonction main\nCes paramètres sont toujours des chaînes de caractères (lorsqu’ils sont fournis dans une com-\nmande de lancement du programme, ils sont séparés par des espaces). Leur transmission à lafonction \nmain  (réalisée par le système) se fait selon les conventions suivantes :\n●le premier argument reçu par main  sera de type int et il représentera le nombre total de\nparamètres fournis dans la ligne de commande (le nom du programme compte lui-mêmepour un paramètre),\n●le second argument reçu par main  sera l’adresse d’un tableau de pointeurs, chaque poin-\nteur désignant la chaîne correspondant à chacun des paramètres.\nAinsi, en remplaçant l’en-tête de la fonction main  par celle-ci :\nmain (int nbarg, char * argv[])\nnous obtiendrons :\n●dans nbarg , le nombre total de paramètres ;\n●à l’adresse argv[0] , le premier paramètre, c’est-à-dire le nom du programme (dans notre\nexemple précédent, il s’agirait donc de la chaîne test ) ;\n●à l’adresse argv[1] , le second paramètre (dans notre exemple, il s’agirait donc de la\nchaîne arg1 ) ;\n●etc.\nV oici un exemple de programme utilisant ces possibilités. Il est accompagné de trois exemplesd’exécution. Nous avons supposé que notre programme se nommait LIGCOM et nous avonsnoté en gras ce que pourraient être les commandes correspondantes de lancement dans unenvironnement en mode texte (suivant les implémentations, le nom de programme afﬁché enrésultat pourra différer quelque peu ; par exemple, il pourra être précédé d’une indication dechemin ou de répertoire et suivi d’une extension) :\nExemple de programme récupérant les arguments de la ligne de commande \n#include <stdio.h>\n#include <stdarg.h>\nmain(int nbarg, char * argv[])\n{   int i ;   printf (\"mon nom de programme est : %s\\n\", argv[0]) ;   if (nbarg>1) for (i=1 ; i<nbarg ; i++)                printf (\"argument numéro %d : %s\\n\", i, argv[i]) ;       else printf (\"pas d’arguments\\n\") ;}Delannoy Livre.book  Page 162  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 163chapitre n° 8 Les chaînes de caractères\nExemple de programme récupérant les arguments de la ligne de commande (suite)\nLIGCOM\nmon nom de programme est : LIGCOMpas d’arguments                    ______________________________________\nLIGCOM parametre\nmon nom de programme est : LIGCOMargument numéro 1 : parametre                    ______________________________________\nLIGCOM entree.dat sortie 25CX9\nmon nom de programme est : LIGCOMargument numéro 1 : entree.datargument numéro 2 : sortieargument numéro 3 : 25CX9Delannoy Livre.book  Page 163  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n164 © Éditions EyrollesExercices\nTous ces exercices sont corrigés en fin de volume.\n1) Écrire un programme déterminant le nombre de lettres « e » (minuscules) présentes dans\nun texte de moins d’une ligne (supposée ne pas dépasser 132 caractères) fourni au clavier.\n2) Écrire un programme qui supprime toutes les lettres « e » (minuscules) d’un texte de moins\nd’une ligne (supposée ne pas dépasser 132 caractères) fourni au clavier. Le texte ainsi modifiésera créé, en mémoire, à la place de l’ancien.\n3) Écrire un programme qui lit au clavier un mot (d’au plus 30 caractères) et qui l’affiche à\nl’envers.\n4) Écrire un programme qui lit un verbe du premier groupe et qui en affiche la conjugaison au\nprésent de l’indicatif, sous la forme :\nje chante\ntu chantesil chantenous chantonsvous chantezils chantent\nLe programme devra vérifier que le mot fourni se termine bien par « er ». On supposera qu’il\nne peut comporter plus de 26 lettres et qu’il s’agit d’un verbe régulier. Autrement dit, onadmettra que l’utilisateur ne fournira pas un verbe tel que « manger » (le programme afficheraitalors : « nous mangons » ).Delannoy Livre.book  Page 164  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 165Chapitre 9\nLes structures \net les énumérations\nNous avons déjà vu comment le tableau permettait de désigner sous un seul nom un ensemble\nde valeurs de même type, chacune d’entre elles étant repérée par un indice.\nLa structure, quant à elle, va nous permettre de désigner sous un seul nom un ensemble de\nvaleurs pouvant être de types différents. L ’accès à chaque élément de la structure (nomméchamp) se fera, cette fois, non plus par une indication de position, mais par son nom au sein dela structure.\nQuant au type énumération, il s’agit d’un cas particulier de type entier. Sa présentation (tardive)\ndans ce chapitre ne se justiﬁe que parce que sa déclaration et son utilisation sont très prochesde celles du type structure.Delannoy Livre.book  Page 165  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n166 © Éditions Eyrolles1Déclaration d’une structure\nV oyez tout d’abord cette déclaration :\n     struct enreg \n            {  int numero ;               int qte ;               float prix ;            } ;\nCelle-ci déﬁnit un modèle de structure  mais ne réserve pas de variables correspondant à cette\nstructure. Ce modèle s’appelle ici enreg  et il précise le nom et le type de chacun des champs\nconstituant la structure ( numero , qte et prix ).\nUne fois un tel modèle déﬁni, nous pouvons déclarer des variables du type correspondant\n(souvent, nous parlerons de structure pour désigner une variable dont le type est un modèle destructure).\nPar exemple :\n     struct enreg art1 ;\nréserve un emplacement nommé art1  « de type enreg » destiné à contenir deux entiers et un\nﬂottant.De manière semblable :\n     struct enreg art1, art2 ;\nréserve deux emplacements art1  et art2  du type enreg .\nBien que ce soit peu recommandé, sachez qu’il est possible de regrouper la définition du\nmodèle de structure et la déclaration du type des variables dans une seule instruction comme\ndans cet exemple :\n     struct enreg\n            {  int numero ;               int qte ;               float prix ;            } art1, art2 ;\nDans ce dernier cas, il est même possible d’omettre le nom de modèle (\nenreg ), à condition,\nbien sûr, que l’on n’ait pas à déclarer par la suite d’autres variables de ce type.Delannoy Livre.book  Page 166  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 167chapitre n° 9 Les structures et les énumérations\n2Utilisation d’une structure\nEn C, on peut utiliser une structure de deux manières :\n●en travaillant individuellement sur chacun de ses champs ;\n●en travaillant de manière globale sur l’ensemble de la structure.\n2.1 Utilisation des champs d’une structure\nChaque champ d’une structure peut être manipulé comme n’importe quelle variable du type\ncorrespondant. La désignation d’un champ se note en faisant suivre le nom de la variablestructure de l’opérateur « point » (\n.) suivi du nom de champ tel qu’il a été déﬁni dans le\nmodèle (le nom de modèle lui-même n’intervenant d’ailleurs pas).\nV oici quelques exemples utilisant le modèle  enreg  et les variables art1  et art2  déclarées\nde ce type.\nart1.numero = 15 ;\naffecte la valeur 15 au champ numero  de la structure art1 .\nprintf (\"%e\", art1.prix) ;\nafﬁche, suivant le code format %e, la valeur du champ prix de la structure art1 .\nscanf (\"%e\", &art2.prix) ;\nlit, suivant le code format %e, une valeur qui sera affectée au champ prix de la structure\nart2 . Notez bien la présence de l’opérateur &.\nart1.numero++\nincrémente de 1 la valeur du champ numero  de la structure art1 .\nLa priorité de l’opérateur « . » est très élevée, de sorte qu’aucune des expressions ci-dessus\nne nécessite de parenthèses (voyez le tableau du chapitre 3, « Les opérateurs et les expres-\nsions en langage C »).\n2.2 Utilisation globale d’une structure\nIl est possible d’affecter à une structure le contenu d’une structure déﬁnie à partir du même\nmodèle . Par exemple, si les structures art1  et art2  ont été déclarées suivant le modèle\nenreg  déﬁni précédemment, nous pourrons écrire :\nart1 = art2 ;Delannoy Livre.book  Page 167  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n168 © Éditions EyrollesUne telle affectation globale remplace avantageusement :\nart1.numero = art2.numero ;\nart1.qte    = art2.qte ;art1.prix   = art2.prix ;\nNotez bien qu’une affectation globale n’est possible que si les structures ont été déﬁnies avec\nle même nom de modèle ; en particulier, elle sera impossible avec des variables ayant une\nstructure analogue mais déﬁnies sous deux noms différents.\nL ’opérateur d’affectation et, comme nous le verrons un peu plus loin, l’opérateur d’adresse &\nsont les seuls opérateurs s’appliquant à une structure (de manière globale).\nL’affectation globale n’est pas possible entre tableaux. Elle l’est, par contre, entre structures.\nAussi est-il possible, en créant artificiellement une structure contenant un seul champ qui est\nun tableau, de réaliser une affectation globale entre tableaux.\n2.3 Initialisations de structures\nOn retrouve pour les structures les règles d’initialisation qui sont en vigueur pour tous les\ntypes de variables, à savoir :\n●En l’absence d’initialisation explicite, les structures de classe statique sont, par défaut, ini-tialisées à zéro ; celles possédant la classe automatique ne sont pas initialisées par défaut(elles contiendront donc des valeurs aléatoires).\n●Il est possible d’initialiser explicitement une structure lors de sa déclaration. On ne peuttoutefois employer que des constantes ou des expressions constantes et cela aussi bien pourles structures statiques que pour les structures automatiques,alors que, pour les variablesscalaires automatiques, il était possible d’employer une expression quelconque (onretrouve là les mêmes restrictions que pour les tableaux).\nV oici un exemple d’initialisation de notre structure \nart1 , au moment de sa déclaration :\n     struct enreg art1 = { 100, 285, 2000 } ;\nV ous voyez que la description des différents champs se présente sous la forme d’une liste devaleurs séparées par des virgules, chaque valeur étant une constante ayant le type du champcorrespondant. Là encore, il est possible d’omettre certaines valeurs.Delannoy Livre.book  Page 168  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 169chapitre n° 9 Les structures et les énumérations\n3Pour simpliﬁer la déclaration de types : déﬁnir des synonymes \navec typedef\nLa déclaration typedef  permet de déﬁnir ce que l’on nomme en langage C des types synony-\nmes. A priori, elle s’applique à tous les types et pas seulement aux structures. C’est pourquoi\nnous commencerons par l’introduire sur quelques exemples avant de montrer l’usage que l’onpeut en faire avec les structures.\n3.1 Exemples d’utilisation de typedef\nLa déclaration :\ntypedef  int  entier ;\nsigniﬁe que entier  est synonyme de int, de sorte que les déclarations suivantes sont équivalentes :\n    int n, p ;           entier n, p ;\nDe même :\ntypedef  int * ptr ;\nsigniﬁe que ptr est synonyme de int *. Les déclarations suivantes sont équivalentes :\n    int * p1, * p2 ;             ptr p1, p2 ;\nNotez bien que cette déclaration est plus puissante qu’une substitution telle qu’elle pourraitêtre réalisée par la directive \n#define . Nous n’en ferons pas ici de description exhaustive, et\ncela d’autant plus que son usage tend à disparaître. À titre indicatif, sachez, par exemple,qu’avec la déclaration :\ntypedef  int vecteur [3] ;\nles déclarations suivantes sont équivalentes :\n    int v[3], w[3] ;          vecteur v, w ;\n3.2 Application aux structures\nEn faisant usage de typedef , les déclarations des structures art1  et art2  du paragraphe 1\npeuvent être réalisées comme suit :\n     struct enreg\n            { int numero ;              int qte ;              float prix ;            } ;Delannoy Livre.book  Page 169  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n170 © Éditions Eyrolles     typedef struct enreg s_enreg ;\n     s_enreg art1, art2 ;\nou encore, plus simplement :\n     typedef struct              { int numero ;               int qte ;               float prix ;             } s_enreg ;                   s_enreg art1, art2 ;\nPar la suite, nous ne ferons appel qu’occasionnellement à typedef , aﬁn de ne pas vous enfer-\nmer dans un style de notations que vous ne retrouverez pas nécessairement dans les programmes\nque vous serez amené à utiliser.\n4Imbrication de structures\nDans nos exemples d’introduction des structures, nous nous sommes limité à une structuresimple ne comportant que trois champs d’un type de base. Mais chacun des champs d’unestructure peut être d’un type absolument quelconque : pointeur, tableau, structure... Il peutmême s’agir de pointeurs sur des structures du type de la structure dans laquelle ils apparais-sent. Nous en reparlerons dans le chapitre 11, « Gestion dynamique de la mémoire », à proposde la constitution de listes chaînées. De même, un tableau peut être constitué d’éléments quisont eux-mêmes des structures. V oyons ici quelques situations classiques.\n4.1 Structure comportant des tableaux\nSoit la déclaration suivante :\n     struct personne {  char nom[30] ;\n                        char prenom [20] ;                        float heures [31] ;                      } employe, courant ;\nCelle-ci réserve les emplacements pour deux structures nommées employe  et courant . Ces\ndernières comportent trois champs :\n●nom qui est un tableau de 30 caractères ;\n●prenom  qui est un tableau de 20 caractères ;\n●heures  qui est un tableau de 31 ﬂottants.Delannoy Livre.book  Page 170  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 171chapitre n° 9 Les structures et les énumérations\nOn peut, par exemple, imaginer que ces structures permettent de conserver pour un employé\nd’une entreprise les informations suivantes :\n●nom ;\n●prénom ;\n●nombre d’heures de travail effectuées pendant chacun des jours du mois courant.\nLa notation :\nemploye.heures[4]\ndésigne le cinquième élément du tableau heures  de la structure employe . Il s’agit d’un\nélément de type float . Notez que, malgré les priorités identiques des opérateurs . et [], leur\nassociativité de gauche à droite évite l’emploi de parenthèses.\nDe même :\nemploye.nom[0]\nreprésente le premier caractère du champ nom de la structure employe .\nPar ailleurs :\n&courant.heures[4]\nreprésente l’adresse du cinquième élément du tableau heures  de la structure courant .\nNotez que, la priorité de l’opérateur & étant inférieure à celle des deux autres, les parenthèses\nne sont, là encore, pas nécessaires.Enﬁn :\ncourant.nom\nreprésente le champ nom de la structure courant , c’est-à-dire plus précisément l’adresse de\nce tableau.À titre indicatif, voici un exemple d’initialisation d’une structure de type \npersonne  lors de sa\ndéclaration :\nstruct personne emp = {\"Dupont\", \"Jules\", { 8, 7, 8, 6, 8, 0, 0, 8}};\n4.2 Tableaux de structures\nV oyez ces déclarations :\n     struct point { char nom ;\n                    int x ;                    int y ;                  } ;\n     struct point courbe [50] ;Delannoy Livre.book  Page 171  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n172 © Éditions EyrollesLa structure point  pourrait, par exemple, servir à représenter un point d’un plan, point qui\nserait déﬁni par son nom (caractère) et ses deux coordonnées.\nNotez bien que point  est un nom de modèle de structure, tandis que courbe  représente\neffectivement un tableau de 50 éléments du type point .\nSi i est un entier, la notation :\ncourbe[i].nom \nreprésente le nom du point de rang i du tableau courbe . Il s’agit donc d’une valeur de type\nchar . Notez bien que la notation :\ncourbe.nom[i]\nn’aurait pas de sens.De même, la notation :\ncourbe[i].x\ndésigne la valeur du champ x de l’élément de rang i du tableau courbe .\nPar ailleurs :\ncourbe[4]\nreprésente la structure de type point  correspondant au cinquième élément du tableau\ncourbe . \nEnﬁn courbe  est un identiﬁcateur de tableau, et, comme tel, désigne son adresse de début.\nLà encore, voici, à titre indicatif, un exemple d’initialisation (partielle) de notre variable\ncourbe , lors de sa déclaration :\nstruct point courbe[50]= { {'A', 10, 25}, {'M', 12, 28},, {'P', 18,2} };\n4.3 Structures comportant d’autres structures\nSupposez que, à l’intérieur de nos structures employe  et courant déﬁnies dans le para-\ngraphe 4.1, nous ayons besoin d’introduire deux dates : la date d’embauche et la date\nd’entrée dans le dernier poste occupé. Si ces dates sont elles-mêmes des structures compor-tant trois champs correspondant au jour, au mois et à l’année, nous pouvons alors procéderaux déclarations suivantes :\n     struct date\n            { int jour ;              int mois ;              int annee ;            } ;Delannoy Livre.book  Page 172  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 173chapitre n° 9 Les structures et les énumérations\n     struct personne  \n            { char nom[30] ;              char prenom[20] ;              float heures [31] ;              struct date date_embauche ;              struct date date_poste ;            } employe, courant ;\nV ous voyez que la seconde déclaration fait intervenir un modèle de structure ( date ) précé-\ndemment déﬁni.\nLa notation :\nemploye.date_embauche.annee\nreprésente l’année d’embauche correspondant à la structure employe . Il s’agit d’une valeur\nde type int.\ncourant.date_embauche\nreprésente la date d’embauche correspondant à la structure courant . Il s’agit cette fois d’une\nstructure de type date . Elle pourra éventuellement faire l’objet d’affectations globales\ncomme dans :\ncourant.date_embauche = employe.date_poste ;\n5À propos de la portée du modèle de structure\n À l’image de ce qui se produit pour les identiﬁcateurs de variables, la portée d’un modèle de\nstructure dépend de l’emplacement de sa déclaration :\n●si elle se situe au sein d’une fonction (y compris, la fonction main ), elle n’est accessible\nque depuis cette fonction ;\n●si elle se situe en dehors d’une fonction, elle est accessible de toute la partie du ﬁchiersource qui suit sa déclaration ; elle peut ainsi être utilisée par plusieurs fonctions.\nV oici un exemple d’un modèle de structure nommé \nenreg  déclaré à un niveau global et acces-\nsible depuis les fonctions main et fct.\n     struct enreg    \n             { int numero ;               int qte ;               float prix ;             } ;Delannoy Livre.book  Page 173  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n174 © Éditions Eyrolles     main ()\n     {   struct enreg x ;           ....     }     fct ( ....)      {   struct enreg y, z ;           ....     }\nEn revanche, il n’est pas possible, dans un ﬁchier source donné, de faire référence à un modèle\ndéﬁni dans un autre ﬁchier source. Notez bien qu’il ne faut pas assimiler le nom de modèled’une structure à un nom de variable ; notamment, il n’est pas possible, dans ce cas, d’utiliserde déclaration \nextern . En effet, la déclaration extern  s’applique à des identiﬁcateurs\nsusceptibles d’être remplacés par des adresses au niveau de l’édition de liens. Or un modèle destructure représente beaucoup plus qu’une simple information d’adresse et il n’a de signiﬁcationqu’au moment de la compilation du ﬁchier source où il se trouve.\nIl est néanmoins toujours possible de placer un certain nombre de déclarations de modèles de\nstructures dans un ﬁchier séparé que l’on incorpore par \n#include  à tous les ﬁchiers source\noù l’on en a besoin. Cette méthode évite la duplication des déclarations identiques avec lesrisques d’erreurs qui lui sont inhérents.\nLe même problème de portée se pose pour les synonymes déﬁnis par \ntypedef . Les mêmes\nsolutions peuvent y être apportées par l’emploi de #include .\n6Transmission d’une structure en argument \nd’une fonction\nJusqu’ici, nous avons vu qu’en C la transmission des argument se fait par valeur, ce qui impli-\nque une recopie de l’information transmise à la fonction. Par ailleurs, il est toujours possiblede transmettre la valeur d’un pointeur sur une variable, auquel cas la fonction peut, si besoinest, en modiﬁer la valeur. Ces remarques s’appliquent également aux structures (notez qu’iln’en allait pas de même pour un tableau, dans la mesure où la seule chose qu’on puisse transmettredans ce cas soit la valeur de l’adresse de ce tableau). \n6.1 Transmission de la valeur d’une structure\nAucun problème particulier ne se pose. Il s’agit simplement d’appliquer ce que nous connaissonsdéjà. V oici un exemple simple :Delannoy Livre.book  Page 174  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 175chapitre n° 9 Les structures et les énumérations\nNaturellement, les valeurs de la structure x sont recopiées localement dans la fonction fct\nlors de son appel ; les modiﬁcations de s au sein de fct n’ont aucune incidence sur les valeurs\nde x.\n6.2 Transmission de l’adresse d’une structure : l’opérateur ->\nCherchons à modiﬁer notre précédent programme pour que la fonction fct reçoive effective-\nment l’adresse d’une structure et non plus sa valeur. L ’appel de fct devra donc se présenter\nsous la forme :\nfct (&x) ;\nCela signiﬁe que son en-tête sera de la forme :\nvoid fct (struct enreg * ads) ;Transmission en argument des valeurs d’une structure\n#include <stdio.h>\nstruct enreg { int a ;               float b ;             } ;main(){  struct enreg x ;  void fct (struct enreg y) ;  x.a = 1; x.b = 12.5;  printf (\"\\navant appel fct : %d %e\",x.a,x.b);  fct (x) ;  printf (\"\\nau retour dans main : %d %e\", x.a, x.b);}\nvoid fct (struct enreg s)\n{  s.a = 0; s.b=1;  printf (\"\\ndans fct  : %d %e\", s.a, s.b);}\navant appel fct : 1 1.25000e+01dans fct  : 0 1.00000e+00au retour dans main : 1 1.25000e+01Delannoy Livre.book  Page 175  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n176 © Éditions EyrollesComme vous le constatez, le problème se pose alors d’accéder, au sein de la déﬁnition de fct,\nà chacun des champs de la structure d’adresse ads. L ’opérateur « . » ne convient plus, car il\nsuppose comme premier opérande un nom de structure et non une adresse. Deux solutions\ns’offrent alors à vous :\n●adopter une notation telle que (*ads).a  ou (*ads).b  pour désigner les champs de la\nstructure d’adresse ads ;\n●faire appel à un nouvel opérateur noté ->, lequel permet d’accéder aux différents champs d’une\nstructure à partir de son adresse de début. Ainsi, au sein de fct, la notation ads -> b\ndésignera le second champ de la structure reçue en argument ; elle sera équivalente à\n(*ads) .b.\nV oici ce que pourrait devenir notre précédent exemple en employant l’opérateur noté -> :\nTransmission en argument de l’adresse d’une structure\n#include <stdio.h>\nstruct enreg { int a ;               float b ;             } ;main(){  struct enreg x ;\n  void fct (struct enreg *) ;\n  x.a = 1; x.b = 12.5;  printf (\"\\navant appel fct : %d %e\",x.a,x.b);  fct (&x) ;  printf (\"\\nau retour dans main : %d %e\", x.a, x.b);}void fct (struct enreg * ads){  ads->a = 0 ; ads->b = 1;  printf (\"\\ndans fct  : %d %e\", ads->a, ads->b);} \navant appel fct : 1 1.25000e+01dans fct  : 0 1.00000e+00au retour dans main : 0 1.00000e+00Delannoy Livre.book  Page 176  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 177chapitre n° 9 Les structures et les énumérations\n7Transmission d’une structure en valeur de retour d’une fonction\nBien que cela soit peu usité, sachez que C vous autorise à réaliser des fonctions qui fournissent\nen retour la valeur d’une structure. Par exemple, avec le modèle enreg  précédemment déﬁni,\nnous pourrions envisager une situation de ce type :\nstruct enreg fct (...) \n{   struct enreg s ;     /* structure locale à fct */\n     .....    return s ;           /* dont la fonction renvoie la valeur */\n}\nNotez bien que s aura dû soit être créée localement par la fonction (comme c’est le cas ici),\nsoit éventuellement reçue en argument.\nNaturellement, rien ne vous interdit, par ailleurs, de réaliser une fonction qui renvoie comme\nrésultat un pointeur sur une structure. Toutefois, il ne faudra pas oublier qu’alors la structureen question ne peut plus être locale à la fonction ; en effet, dans ce cas, elle n’existerait plusdès l’achèvement de la fonction... (mais le pointeur continuerait à pointer sur quelque chosed’inexistant !). Notez que cette remarque vaut pour n’importe quel type autre qu’une structure.\n8Les énumérations\nUn type énumération est un cas particulier de type entier et donc un type scalaire (ou simple).Son seul lien avec les structures présentées précédemment est qu’il forme, lui aussi, un typedéﬁni par le programmeur.\n8.1 Exemples introductifs\nConsidérons cette déclaration :\nenum couleur {jaune, rouge, bleu, vert} ;\nElle déﬁnit un type énumération nommé couleur  et précise qu’il comporte quatre valeurs\npossibles désignées par les identiﬁcateurs jaune , rouge , bleu  et vert . Ces valeurs consti-\ntuent les constantes du type couleur .\nIl est possible de déclarer des variables de type couleur  :\nenum couleur c1, c2 ;    /* c1 et c2 sont deux variables */\n                         /* de type enum couleur         */Delannoy Livre.book  Page 177  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n178 © Éditions EyrollesLes instructions suivantes sont alors tout naturellement correctes :\nc1 = jaune ;    /* affecte à c1 la valeur jaune            */\nc2 = c1 ;       /* affecte à c2 la valeur contenue dans c1 */\nComme on peut s’y attendre, les identiﬁcateurs correspondant aux constantes du type couleur\nne sont pas des lvalue  et ne sont donc pas modiﬁables :\njaune = 3 ;     /* interdit : jaune n’est pas une lvalue */\n8.2 Propriétés du type énumération\nNature des constantes ﬁgurant dans un type énumération\nLes constantes ﬁgurant dans la déclaration d’un type énumération sont des entiers ordinaires.\nAinsi, la déclaration précédente :\nenum couleur {jaune, rouge, bleu, vert} ;\nassocie simplement une valeur de type int à chacun des quatre identiﬁcateurs cités. Plus précisé-\nment, elle attribue la valeur 0 au premier identiﬁcateur jaune , la valeur 1 à l’identiﬁcateur rouge ,\netc. Ces identiﬁcateurs sont utilisables en lieu et place de n’importe quelle constante entière :\nint n ; \nlong p, q ;   .....n = bleu ;               /* même rôle que   n = 2          */p = vert * q + bleu ;    /* même rôle que   p = 3 * q + 2  */\nUne variable d’un type énumération peut recevoir une valeur quelconque\nContrairement à ce qu’on pourrait espérer, il est possible d’affecter à une variable de type énu-\nméré n’importe quelle valeur entière (pour peu qu’elle soit représentable dans le type int) :\nenum couleur {jaune, rouge, bleu, vert} ;\nenum couleur c1, c2 ;    .....c1 = 2 ;    /* même rôle que c1 = bleu ;                 */c1 = 25 ;   /* accepté, bien que 25 n’appartienne pas au */            /* type type enum couleur                    */\nQui plus est, on peut écrire des choses aussi absurdes que :\nenum booleen { faux, vrai } ;enum couleur {jaune, rouge, bleu, vert} ;enum booleen drapeau ;enum couleur c ;    .....Delannoy Livre.book  Page 178  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 179chapitre n° 9 Les structures et les énumérations\nc = drapeau ;  /* OK bien que drapeau et c ne soit pas d’un même type */\ndrapeau = 3 * c + 4 ;    /* accepté */\nLes constantes d’un type énumération peuvent être quelconques\nDans les exemples précédents, les valeurs des constantes attribuées aux identiﬁcateurs appa-\nraissant dans un type énumération étaient déterminées automatiquement par le compilateur.Mais il est possible d’inﬂuer plus ou moins sur ces valeurs, comme dans :\nenum couleur_bis { jaune = 5, rouge, bleu, vert = 12, rose } ;\n     /* jaune = 5, rouge = 6, bleu = 7, vert = 12, rose = 13 */\nLes entiers négatifs sont permis comme dans :\nenum couleur_ter { jaune = -5, rouge, bleu, vert = 12 , rose } ;     /* jaune = -5, rouge = -4, bleu = -3, vert = 12, rose = 13 */\nEn outre, rien n’interdit qu’une même valeur puisse être attribuée à deux identiﬁcateurs\ndifférents :\nenum couleur_ter { jaune = 5, rouge, bleu, vert = 6, noir, violet } ;\n   /* jaune = 5, rouge = 6, bleu = 7, vert = 6, noir = 7, violet = 8 */\nComme dans le cas des structures ou des unions, on peut mixer la définition d’un type énu-\nméré et la déclaration de variables utilisant le type. Par exemple, ces deux instructions :\nenum couleur {jaune, rouge, bleu, vert} ;enum couleur c1, c2 ; \npeuvent être remplacées par :\nenum couleur {jaune, rouge, bleu, vert} c1, c2 ;\nDans ce cas, on peut même utiliser un type anonyme, en éliminant l’identificateur de type :\nenum {jaune, rouge, bleu, vert} c1, c2 ;\nCette dernière possibilité présente moins d’inconvénients que dans le cas des structures ou\ndes unions, car aucun problème de compatibilité de type ne risque de se poser.\nCompte tenu de la manière dont sont utilisées les structures, il était permis de donner deux noms\nidentiques à des champs de structures différentes. En revanche, une telle possibilité ne peut pluss’appliquer à des identificateurs définis dans une instruction \nenum . Considérez cet exemple :\nenum couleur {jaune, rouge, bleu, vert} ;\nenum bois_carte { rouge, noir } ;  /* erreur : rouge déjà défini */int rouge ;                        /* erreur : rouge déjà défini */\nBien entendu, la portée de tels identificateurs est celle correspondant à leur déclaration (fonction\nou partie du fichier source suivant cette déclaration).Delannoy Livre.book  Page 179  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n180 © Éditions EyrollesExercices\nTous ces exercices sont corrigés en fin de volume.\n1) Écrire un programme qui :\n●lit au clavier des informations dans un tableau de structures du type point  défini comme\nsuit :\n    struct point { int num ;\n                   float x ;                   float y ;                 }\nLe nombre d’éléments du tableau sera fixé par une instruction \n#define .\n●affiche à l’écran l’ensemble des informations précédentes.\n2) Réaliser la même chose que dans l’exercice précédent, mais en prévoyant, cette fois, une\nfonction pour la lecture des informations et une fonction pour l’affichage.Delannoy Livre.book  Page 180  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 181Chapitre 10\nLes ﬁchiers\nNous avons déjà eu l’occasion d’étudier les « entrées-sorties conversationnelles », c’est-à-dire\nles fonctions permettant d’échanger des informations entre le programme et l’utilisateur. Nousvous proposons ici d’étudier les fonctions permettant au programme d’échanger des informa-tions avec des ﬁchiers. A priori, ce terme de ﬁchier désigne plutôt un ensemble d’informationssitué sur une « mémoire de masse » telle que le disque ou la disquette. Nous verrons toutefoisqu’en C, comme d’ailleurs dans d’autres langages, tous les périphériques, qu’ils soientd’archivage (disque, disquette...) ou de communication (clavier, écran, imprimante...), peuventêtre considérés comme des ﬁchiers. Ainsi, en déﬁnitive, les entrées-sorties conversationnelles\napparaîtront comme un cas particulier de la gestion de ﬁchiers.\nRappelons que l’on distingue traditionnellement deux techniques de gestion de ﬁchiers :\n●l’accès séquentiel consiste à traiter les informations séquentiellement, c’est-à-dire dans\nl’ordre où elles apparaissent (ou apparaîtront) dans le ﬁchier ;\n●l’accès direct consiste à se placer immédiatement sur l’information souhaitée, sans avoir àparcourir celles qui la précèdent.\nEn fait, pour des ﬁchiers disque (ou disquette), la distinction entre accès séquentiel et accèsdirect n’a plus véritablement de raison d’être. D’ailleurs, comme vous le verrez, en langage C,vous utiliserez les mêmes fonctions dans les deux cas (exception faite d’une fonction de déplace-ment de pointeur de ﬁchier). Qui plus est, rien ne vous empêchera de mélanger les deux modesd’accès pour un même ﬁchier. Cependant, pour assurer une certaine progressivité à notre propos,nous avons préféré commencer par vous montrer comment travailler de manière séquentielle. Delannoy Livre.book  Page 181  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n182 © Éditions Eyrolles1Création séquentielle d’un ﬁchier\nV oici un programme qui se contente d’enregistrer séquentiellement dans un ﬁchier une suite\nde nombres entiers saisis au clavier.\nNous avons déclaré un tableau de caractères nomfich  destiné à contenir, sous forme d’une\nchaîne, le nom du ﬁchier que l’on souhaite créer.\nLa déclaration :\nFILE * sortie ;\nsigniﬁe que sortie  est un pointeur sur un objet de type FILE . Ce nom désigne en fait un\nmodèle de structure déﬁni dans le ﬁchier stdio.h  (par une instruction typedef , ce qui\nexplique l’absence du mot struct ).\nN’oubliez pas que cette déclaration ne réserve qu’un emplacement pour un pointeur. C’est la\nfonction fopen  qui créera effectivement une telle structure et qui en fournira l’adresse en\nrésultat.Création séquentielle d’un fichier d’entiers\n#include <stdio.h>\nmain(){    char nomfich[21] ;   int n ;   FILE * sortie ;\n   printf (\"nom du fichier à créer : \") ;\n   scanf (\"%20s\", nomfich) ;   sortie = fopen (nomfich, \"w\") ;     do { printf (\"donnez un entier : \") ;        scanf (\"%d\", &n) ;        if (n) fwrite (&n, sizeof(int), 1, sortie) ;      }  while (n) ;    fclose (sortie) ;}Delannoy Livre.book  Page 182  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 183chapitre n° 10 Les fichiers\nLa fonction fopen  est ce que l’on nomme une fonction d’ouverture de ﬁchier. Elle possède\ndeux arguments :\n●Le nom du ﬁchier concerné, fourni sous forme d’une chaîne de caractères ; ici, nous avons\nprévu que ce nom ne dépassera pas 20 caractères (le chiffre 21 tenant compte du caractère\n\\0) ; notez qu’en général ce nom pourra comporter une information (chemin, répertoire...)\npermettant de préciser l’endroit où se trouve le ﬁchier.\n●Une indication, fournie elle aussi sous forme d’une chaîne, précisant ce que l’on souhaitefaire avec ce ﬁchier. Ici, on trouve \nw (abréviation de write ) qui permet de réaliser une\nouverture en écriture. Plus précisément, si le ﬁchier cité n’existe pas, il sera créé par\nfopen . S’il existe déjà, son ancien contenu deviendra inaccessible. Autrement dit, après\nl’appel de cette fonction, on se retrouve dans tous les cas en présence d’un ﬁchier vide.\nLe remplissage du ﬁchier est réalisé par la répétition de l’appel :\nfwrite (&n, sizeof(int), 1, sortie) ;\nLa fonction fwrite  possède quatre arguments précisant :\n●l’adresse d’un bloc d’informations (ici &n) ;\n●la taille d’un bloc, en octets : ici sizeof(int)  ; notez l’emploi de l’opérateur sizeof\nqui assure la portabilité du programme ;\n●le nombre de blocs de cette taille que l’on souhaite transférer dans le ﬁchier (ici 1) ;\n●l’adresse de la structure décrivant le ﬁchier ( sortie ).\nNotez que, d’une manière générale, fwrite  permet de transférer plusieurs blocs consécutifs\nde même taille à partir d’une adresse donnée.\nEnﬁn, la fonction fclose  réalise ce que l’on nomme une fermeture de ﬁchier. Elle force l’écriture\nsur disque du tampon associé au ﬁchier. En effet, chaque appel à fwrite  provoque un entasse-\nment d’informations dans le tampon associé au ﬁchier. Ce n’est que lorsque ce dernier est plein\nqu’il est « vidé » sur disque. Dans ces conditions, on voit qu’après le dernier appel de fwrite\nil est nécessaire de forcer le transfert des dernières informations accumulées dans le tampon.\nOn emploie souvent le terme flux (en anglais stream) pour désigner un pointeur sur une struc-\nture de type FILE . Ici, par exemple, sortie  est un flux que la fonction fopen  aura associé à un\ncertain fichier. D’une manière générale, par souci de simplification, lorsqu’aucune ambiguïté ne\nsera possible, nous utiliserons souvent le mot fichier à la place de flux.\nLa fonction fopen  fournit un pointeur nul en cas d’impossibilité d’ouverture du fichier. Ce sera\nle cas, par exemple, si l’on cherche à ouvrir en lecture un fichier inexistant ou encore si l’oncherche à créer un fichier sur une disquette saturée.\nLa fonction fwrite  fournit le nombre de blocs effectivement écrits. Si cette valeur est inférieure\nau nombre prévu, cela signifie qu’une erreur est survenue en cours d’écriture. Cela peut être,par exemple, une disquette pleine, mais cela peut se produire également lorsque l’ouverture du\nfichier s’est mal déroulée (et que l’on n’a pas pris soin d’examiner le code de retour de fopen ).Delannoy Livre.book  Page 183  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n184 © Éditions Eyrolles2Liste séquentielle d’un ﬁchier\nV oici maintenant un programme qui permet de lister le contenu d’un ﬁchier quelconque tel\nqu’il a pu être créé par le programme précédent.\nLes déclarations sont identiques à celles du programme précédent. En revanche, on trouve\ncette fois, dans l’ouverture du ﬁchier, l’indication r (abréviation de read ). Elle précise que le\nﬁchier en question ne sera utilisé qu’en lecture. Il est donc nécessaire qu’il existe déjà (nousverrons un peu plus loin comment traiter convenablement le cas où il n’existe pas).\nLa lecture dans le ﬁchier se fait par un appel de la fonction \nfread  :\nfread (&n, sizeof(int), 1, entree) \ndont les arguments sont comparables à ceux de fwrite . Mais, cette fois, la condition d’arrêt\nde la boucle est :\nfeof (entree)\nCelle-ci prend la valeur vrai (c’est-à-dire 1) lorsque la ﬁn du ﬁchier a été rencontrée. Notez\nbien qu’il n’est pas sufﬁsant d’avoir lu le dernier octet du ﬁchier pour que cette condition\nprenne la valeur vrai. Il est nécessaire d’avoir tenté de lire au-delà  (contrairement à ce qui seListe séquentielle d’un fichier\n#include <stdio.h>\nmain(){    char nomfich[21] ;   int n ;   FILE * entree ;\n   printf (\"nom du fichier à lister : \") ;\n   scanf (\"%20s\", nomfich) ;   entree = fopen (nomfich, \"r\") ;\n   while ( fread (&n, sizeof(int), 1, entree), ! feof(entree) )\n              printf (\"\\n%d\", n) ;\n  fclose (entree) ;\n}Delannoy Livre.book  Page 184  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 185chapitre n° 10 Les fichiers\npasse, par exemple, en Turbo Pascal, dans lequel la détection de ﬁn de ﬁchier fonctionne en\nquelque sorte par anticipation) ; c’est ce qui explique que nous ayons examiné cette conditionaprès l’appel de \nfread  et non avant. \nOn pourrait remplacer la boucle while  par la construction (moins concise) suivante :\n     do\n        { fread (&n, sizeof(int), 1, entree) ;          if ( !feof(entree) ) printf (\"\\n%d\", n) ;        }     while ( !feof(entree) ) ;\nN’oubliez pas que le premier argument des fonctions fwrite  et fread  est une adresse. Ainsi,\nlorsque vous aurez affaire à un tableau, il faudra utiliser simplement son nom (sans le faire pré-\ncéder de &), tandis qu’avec une structure il faudra effectivement utiliser l’opérateur & pour en\nobtenir l’adresse. Dans ce dernier cas, même si l’on ne cherche pas à rendre son programmeportable, il sera préférable d’utiliser l’opérateur \nsizeof  pour déterminer avec certitude la taille\ndes blocs correspondants.\nfread  fournit le nombre de blocs effectivement lus (et non pas le nombre d’octets lus). Ce\nrésultat peut être inférieur au nombre de blocs demandés soit lorsque l’on a rencontré une finde fichier, soit lorsqu’une erreur de lecture est apparue. Dans notre précédent exemple d’exécution,\nfread  fournit toujours 1, sauf la dernière fois où elle fournit 0.\n3L’accès direct\nLes fonctions fread  et fwrite  lisent ou écrivent un certain nombre d’octets dans un ﬁchier,\nà partir d’une position courante. Cette dernière n’est rien d’autre qu’un « pointeur » dans le\nﬁchier, c’est-à-dire un nombre précisant le rang du prochain octet à lire ou à écrire. (Le termede « pointeur » n’a pas exactement le même sens que celui de pointeur tel qu’il apparaît enlangage C. En effet, il ne désigne pas, à proprement parler, une adresse en mémoire, mais unemplacement dans un ﬁchier. Pour éviter des confusions, nous parlerons de « pointeur deﬁchier »). Après chaque opération de lecture ou d’écriture, ce pointeur se trouve incrémentédu nombre d’octets transférés. C’est ainsi que l’on réalise un accès séquentiel au ﬁchier.\nMais il est également possible d’agir directement sur ce pointeur de ﬁchier à l’aide de la fonc-\ntion \nfseek . Cela permet ainsi de réaliser des lectures ou des écritures en n’importe quel point\ndu ﬁchier, sans avoir besoin de parcourir toutes les informations qui précèdent. On peut ainsiréaliser ce que l’on nomme généralement un « accès direct ».Delannoy Livre.book  Page 185  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n186 © Éditions Eyrolles3.1 Accès direct en lecture sur un ﬁchier existant\nLe programme ci-dessus permet d’accéder à n’importe quel entier d’un ﬁchier du type de ceux\nque pouvait créer notre programme de la section 2.1.\nLa principale nouveauté réside essentiellement dans l’appel de la fonction fseek  :\nfseek ( entree, sizeof(int)*(num-1), SEEK_SET) ;\nCette dernière possède trois arguments :\n●le ﬁchier concerné (désigné par le pointeur sur une structure de type FILE , tel qu’il a été\nfourni par fopen ) ;\n●un entier de type long  spéciﬁant la valeur que l’on souhaite donner au pointeur de ﬁchier.\nIl faut noter que l’on dispose de trois manières d’agir effectivement sur le pointeur, le\nchoix entre les trois étant fait par l’argument suivant ;\n●le choix du mode d’action sur le pointeur de ﬁchier : il est déﬁni par une constante entière.Les valeurs suivantes sont prédéﬁnies dans \n<stdio.h>  :\n•SEEK_SET  (en général 0) : le second argument désigne un déplacement (en octets)\ndepuis le début du ﬁchier ;\n•SEEK_CUR  (en général 1) : le second argument désigne un déplacement exprimé à partir\nde la position courante ; il s’agit donc en quelque sorte d’un déplacement relatif dont la\nvaleur peut, le cas échéant, être négative ;\n•SEEK_END  (en général 2) : le second argument désigne un déplacement depuis la ﬁn du\nﬁchier .Accès direct en lecture sur un fichier existant\n#include <stdio.h>\nmain(){  char nomfich[21] ;   int n ;   long num ;   FILE * entree ;   printf (\"nom du fichier à consulter : \") ;   scanf (\"%20s\", nomfich) ;   entree = fopen (nomfich, \"r\") ;   while ( printf (\" numéro de l’entier recherché : \"),           scanf (\"%ld\", &num), num )      { fseek (entree, sizeof(int)*(num-1), SEEK_SET) ;        fread (&n, sizeof(int), 1, entree) ;        printf (\"  valeur : %d \\n\", n) ;      }   fclose (entree) ;Delannoy Livre.book  Page 186  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 187chapitre n° 10 Les fichiers\nEn général, ces constantes auront la valeur indiquée (0, 1 et 2). Toutefois, la norme n’impose\npas précisément ces valeurs ; elle se contente d’imposer l’existence des trois constantes sym-\nboliques que l’on aura donc intérêt à utiliser si l’on souhaite assurer la portabilité des programmes\nconcernés.\nIci, il s’agit de donner au pointeur de ﬁchier une valeur correspondant à l’emplacement d’un\nentier (sizeof(int)  octets) dont l’utilisateur fournit le rang. Il est donc naturel de donner\nau troisième argument la valeur 0. Notez, au passage, la formule :\nsizeof(int) * (num-1)\nqui se justiﬁe par le fait que nous avons convenu que, pour l’utilisateur, le premier entier duﬁchier porterait le rang \n1 et non 0.\n3.2 Les possibilités de l’accès direct\nOutre les possibilités de consultation immédiate qu’il procure, l’accès direct facilite et accélèreles opérations de mise à jour d’un ﬁchier.\nMais, de surcroît, l’accès direct permet de remplir un ﬁchier de façon quelconque. Ainsi, nous\npourrions constituer notre ﬁchier d’entiers en laissant l’utilisateur fournir ces entiers dansl’ordre de son choix, comme dans cet exemple de programme :\nCréation d’un fichier en accès direct\n#include <stdio.h>\nmain(){  char nomfich[21] ;   FILE * sortie ;   long num ;   int n ;\n   printf (\"nom fichier : \") ;\n   scanf  (\"%20s\",nomfich) ;   sortie = fopen (nomfich, \"w\") ;\n   while (printf(\"\\nrang de l’entier : \"), scanf(\"%ld\",&num), num)\n         {  printf (\"valeur de l’entier : \") ;            scanf (\"%d\", &n) ;            fseek (sortie, sizeof(int)*(num-1), SEEK_SET)  ;            fwrite (&n, sizeof(int), 1, sortie) ;         }\n   fclose(sortie) ;Delannoy Livre.book  Page 187  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n188 © Éditions EyrollesOr il faut savoir qu’avec beaucoup de systèmes, dès que vous écrivez le énième octet d’un\nﬁchier, il y a automatiquement réservation de la place de tous les octets précédents ; leurcontenu, par contre, doit être considéré comme étant aléatoire. De toute façon, tous lessystèmes réservent toujours la place d’un nombre minimal d’octets, de sorte que le problèmeévoqué existe toujours, au moins pour certains octets du ﬁchier.\nDans ces conditions, vous voyez que, à partir du moment où rien n’impose à l’utilisateur de ne\npas « laisser de trous » lors de la création du ﬁchier, il faudra être en mesure de repérer cestrous lors d’éventuelles consultations ultérieures du ﬁchier. Plusieurs techniques existent à ceteffet :\n●on peut, par exemple, avant d’exécuter le programme précédent, commencer par initialisertous les emplacements du ﬁchier à une valeur spéciale , dont on sait qu’elle ne pourra pas\napparaître comme valeur effective ;\n●on peut aussi gérer une table des emplacements inexistants, cette table devant alors êtreconservée (de préférence) dans le ﬁchier lui-même.\nD’autre part, il faut bien voir que l’accès direct n’a d’intérêt que lorsque l’on est en mesurede fournir le rang de l’emplacement concerné. Ce n’est pas toujours possible. Ainsi, si l’onconsidère ne serait-ce qu’un simple ﬁchier de type répertoire téléphonique, on voit qu’en géné-ral on cherchera à accéder à une personne par son nom plutôt que par son numéro d’ordre dansle ﬁchier. Cette contrainte qui semble imposer une recherche séquentielle peut être contournéepar la création de ce que l’on nomme un index, c’est-à-dire une table de correspondance entre\nun nom d’individu et sa position dans le ﬁchier. \nNous n’en dirons pas plus sur ces méthodes spéciﬁques de gestion de ﬁchiers qui sortent du\ncadre de cet ouvrage.\n3.3 En cas d’erreur\na) Erreur de pointage\nIl faut bien voir que le positionnement dans le ﬁchier se fait sur un octet de rang donné, et non,comme on pourrait le préférer, sur un bloc (ou enregistrement) de rang donné. D’ailleurs,n’oubliez pas qu’en général cette notion d’enregistrement n’est pas exprimée de manièreintrinsèque au sein du ﬁchier. Ainsi, dans notre programme précédent, vous pourriez, parmégarde, utiliser la formule suivante :\nsizeof(int) * num -1\nlaquelle vous positionnerait systématiquement « à cheval » entre le dernier octet d’un entier etle premier du suivant. Bien entendu, les résultats obtenus seraient quelque peu fantaisistes.\nCette remarque prend encore plus d’acuité lorsque vous créez un ﬁchier à partir de structures.\nDans ce cas, nous ne saurions trop vous conseiller d’avoir systématiquement recours à l’opé-rateur \nsizeof pour déterminer la taille réelle de ces structures.Delannoy Livre.book  Page 188  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 189chapitre n° 10 Les fichiers\nb) Tentative de positionnement hors ﬁchier\nLorsque l’on accède ainsi directement à l’information d’un ﬁchier, le risque existe de tenter de\nse positionner... en dehors du ﬁchier. En principe, la fonction fseek  fournit :\n●la valeur 0 lorsque le positionnement s’est déroulé correctement ;\n●une valeur quelconque dans le cas contraire.\nToutefois, beaucoup d’implémentations ne respectent pas la norme à ce sujet. Dans ces condi-tions, il nous paraît plus raisonnable de programmer une protection efﬁcace en déterminant, endébut de programme, la taille effective du ﬁchier à consulter. Pour cela, il sufﬁt de vous posi-tionner en ﬁn de ﬁchier avec \nfseek , puis de faire appel à la fonction ftell  qui restitue la\nposition courante du pointeur de ﬁchier. Ainsi, dans notre précédent programme, nous pourrionsintroduire les instructions :\n     long taille ;\n         .....     fseek (entree, 0, SEEK_END) ;\n     taille = ftell (entree) ;\nIl sufﬁt alors de vériﬁer que la position de l’enregistrement demandé (ici : sizeof(int*\n(num-1) ) est bien inférieure à la valeur de taille  pour éviter tout problème.\n4Les entrées-sorties formatées et les ﬁchiers de texte\nNous venons de voir que les fonctions fread  et fwrite  réalisent un transfert d’information\n(entre mémoire et ﬁchier) que l’on pourrait qualiﬁer de brut, dans le sens où il se fait sans\naucune transformation de l’information. Les octets qui ﬁgurent dans le ﬁchier sont des copiesconformes de ceux qui apparaissent en mémoire.\nMais, en langage C, il est également possible d’accompagner ces transferts d’information\nd’opérations de formatage analogues à celles que réalisent \nprintf  ou scanf .\nLes ﬁchiers concernés par ces opérations de formatage sont alors ce que l’on a coutumed’appeler des « ﬁchiers de type texte » ou encore des « ﬁchiers de texte ». Ce sont des ﬁchiersque vous pouvez manipuler avec un éditeur ou un traitement de texte quelconques ou, encoreplus simplement, lister par les commandes appropriées du système d’exploitation (\nTYPE  ou\nPRINT  sous DOS, pr ou more  sous UNIX...).\nDans de tels ﬁchiers, chaque octet représente un caractère. Généralement, on y trouve descaractères de ﬁn de ligne (\n\\n), de sorte qu’ils apparaissent comme une suite de lignes. Les\nfonctions permettant de travailler avec des ﬁchiers de texte ne sont rien d’autre qu’une généra-lisation de celles que nous avons déjà rencontrées pour les entrées-sorties conversationnelles. Delannoy Livre.book  Page 189  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n190 © Éditions EyrollesNous nous contenterons donc d’en fournir une brève liste :\nfscanf ( fichier, format, liste_d’adresses )\nfprintf ( fichier, format, liste_d’expressions )fgetc ( fichier )  fputc ( entier, fichier )  fgets ( chaîne, lgmax, fichier ) fputs ( chaîne, fichier )\nLa signiﬁcation de leurs arguments est la même que pour les fonctions conversationnelles\ncorrespondantes. Seule fgets  comporte un argument entier ( lgmax ) de contrôle de lon-\ngueur. Il précise le nombre maximal de caractères (y compris le \\0 de ﬁn) qui seront placés\ndans la chaîne.\nLeur valeur de retour est la même que pour les fonctions conversationnelles. Cependant, il\nnous faut apporter quelques indications supplémentaires qui ne se justiﬁaient pas pour desentrées-sorties conversationnelles (mais qui auraient un intérêt en cas de simple « redirec-tion » des entrées-sorties), à savoir que la valeur de retour fournie par \nfgetc  est du type int\n(et non, comme on pourrait le croire, de type char ). Lorsque la ﬁn de ﬁchier est atteinte, cette\nfonction fournit la valeur EOF (constante prédéﬁnie dans <stdio.h>  – en général -1). La ﬁn\nde ﬁchier n’est détectée que lorsque l’on cherche à lire un caractère alors qu’il n’y en a plus dedisponible, et non pas, dès que l’on a lu le dernier caractère (ce qui, ici, serait assez mal appro-prié puisque alors on ne pourrait obtenir à la fois le code de ce caractère et une indication deﬁn de ﬁchier). D’autre part, notez bien que cette convention fait, en quelque sorte, doubleemploi avec la fonction \nfeof .\nD’une manière générale, toutes les fonctions présentées ci-dessus fournissent une valeur deretour bien déﬁnie en cas de ﬁn de ﬁchier ou d’erreur. V ous trouverez tous les détails utilesdans l’annexe.\nImportant. A priori, on peut toujours dire que n’importe quel fichier, quelle que soit la manière\ndont l’information y a été représentée, peut être considéré comme une suite de caractères. Bien\nentendu, si l’on cherche à lister, par exemple, le contenu d’un fichier tel que celui créé dans lasection 2.1 (suite d’entiers), le résultat risque d’être sans signification (on obtiendra une suite decaractères apparemment quelconques, sans rapport aucun avec les nombres enregistrés).\nMais, sans aller jusqu’à le lister, on peut se demander s’il ne serait pas possible de le recopier,\nà l’aide d’une répétition de \nfgetc  et de fputc . Or cela semble effectivement possible puisque\nces fonctions se contentent de prélever un caractère (donc un octet) et de le recopier tel quel .\nAinsi, quel que soit le contenu de l’octet lu, on le retrouvera dans le fichier de sortie.\nEn réalité, cela n’est que partiellement vrai car certains environnements distinguent les\nfichiers de texte des autres (qu’ils appellent parfois « fichiers binaires », alors qu’au bout du\ncompte tout fichier est binaire !) ; plus précisément, lors de l’ouverture du fichier, on peut spé-cifier si l’on souhaite ou non considérer le contenu du fichier comme du texte. Cette distinctionest en fait motivée par le fait que le caractère de fin de ligne (\n\\n) possède, dans ces environ-\nnements, une représentation particulière obtenue par la succession de deux caractères (retourDelannoy Livre.book  Page 190  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 191chapitre n° 10 Les fichiers\nchariot \\r, suivi de fin de ligne \\n). Or, dans ce cas, pour qu’un programme C puisse ne voir\nqu’un seul caractère de fin de ligne et qu’il s’agisse bien de \\n, il faut opérer un traitement\nparticulier consistant à :\n• remplacer chaque occurrence de ce couple de caractères par \\n, dans le cas d’une lecture,\n• remplacer chaque demande d’écriture de \\n par l’écriture de ce couple de caractères.\nBien entendu, de telles substitutions ne doivent pas être réalisées sur de vrais fichiers binaires.\nIl faut donc bien pouvoir opérer une distinction au sein du programme. Cette distinction se faitau moment de l’ouverture du fichier, en ajoutant l’une des lettres \nt (pour « texte ») ou b (pour\n« binaire ») au mode d’ouverture. \nEn général, dans les implémentations où l’on distingue les fichiers de texte des autres, les\nfonctions d’entrées-sorties formatées refusent de travailler avec un fichier qui n’a pas été\nspécifié de ce type lors de son ouverture.\n5Les différentes possibilités d’ouverture d’un ﬁchier\nDans nos précédents exemples, nous n’avons utilisé que les modes w et r. Nous vous fournis-\nsons ici la liste des différentes possibilités offertes par fopen .\nr : lecture  seulement ; le ﬁchier doit exister.\nw : écriture  seulement. Si le ﬁchier n’existe pas, il est créé. S’il existe, son (ancien) contenu est\nperdu.\na : écriture en ﬁn de ﬁchier  (append). Si le ﬁchier existe déjà, il sera étendu. S’il n’existe pas,\nil sera créé – on se ramène alors au mode w.\nr+ : mise à jour (lecture et écriture). Le ﬁchier doit exister. Notez qu’alors il n’est pas possible\nde réaliser une lecture à la suite d’une écriture ou une écriture à la suite d’une lecture, sans\npositionner le pointeur de ﬁchier par fseek . Il est toutefois possible d’enchaîner plusieurs\nlectures ou écritures consécutives (de façon séquentielle).\nw+ : création pour mise à jour . Si le ﬁchier existe, son (ancien) contenu sera détruit. S’il\nn’existe pas, il sera créé. Notez que l’on obtiendrait un mode comparable à w+ en ouvrant un\nﬁchier vide (mais existant) en mode r+.\na+ : extension et mise à jour . Si le ﬁchier n’existe pas, il sera créé. S’il existe, le pointeur sera\npositionné en ﬁn de ﬁchier.\nt ou b : lorsque l’implémentation distingue les ﬁchiers de texte des autres, il est possible\nd’ajouter l’une de ces deux lettres à chacun des 6 modes précédents. La lettre t précise que\nl’on a affaire à un ﬁchier de texte ; la lettre b précise que l’on a affaire à un ﬁchier binaire. (On\ndit aussi que t correspond au mode « translaté », pour spéciﬁer que certaines substitutions\nauront lieu).Delannoy Livre.book  Page 191  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n192 © Éditions Eyrolles6Les ﬁchiers prédéﬁnis\nUn certain nombre de ﬁchiers sont connus du langage C, sans qu’il soit nécessaire ni de les\nouvrir ni de les fermer :\n●stdin :  unité d’entrée (par défaut, le clavier) ;\n●stdout : unité de sortie (par défaut, l’écran) ;\n●stderr :  unité d’afﬁchage des messages d’erreurs (par défaut, l’écran).\nOn trouve parfois également :\n●stdaux : unité auxiliaire ;\n●stdprt :  imprimante\nLes deux premiers ﬁchiers correspondent aux unités standard d’entrée et de sortie d’un pro-gramme. Lorsque vous exécutez un programme depuis le système, vous pouvez éventuellementrediriger ces ﬁchiers. Par exemple, la commande système suivante (valable à la fois sous UNIXet sous DOS) :\nTRUC   <DONNEES   >RESULTATS\nexécute le programme TRUC , en utilisant comme unité d’entrée le ﬁchier DONNEES  et comme\nunité de sortie le ﬁchier RESULTATS .\nDans ces conditions, une instruction telle que, par exemple, fgetchar  deviendrait équi-\nvalente à fgetc(fich ) où fich  serait un ﬂux obtenu par appel à fopen . De même,\nscanf(...)  deviendrait équivalent à fscanf(fich,  ..), etc.\nNotez bien qu’au sein du programme même il n’est pas possible de savoir si un ﬁchier prédé-ﬁni a été redirigé au moment du lancement du programme ; autrement dit, lorsqu’une fonctioncomme \nfgetchar  ou scanf  lit des informations, elle ne peut absolument pas savoir si ces\ndernières proviennent du clavier ou d’un ﬁchier.\npour lire en toute tranquillité sur  stdin. Dans la section 2.3 du chapitre consacré aux chaî-\nnes de caractères, nous vous avons montré comment régler les problèmes posés par scanf ,\nen faisant appel à l’association des deux fonctions gets  et sscanf . Pour ce faire, nous avions\ndû toutefois supposer que les lignes lues par gets  ne dépasseraient pas une certaine longueur.\nCette hypothèse est déjà restrictive dans le cas d’informations provenant du clavier : même si\ncela peut paraître naturel à la plupart des utilisateurs de ne pas dépasser, par exemple, unelargeur d’écran, le risque existe d’en voir certains entrer une ligne trop longue qui « plantera »le programme. Cette même hypothèse devient franchement intolérable dans le cas de lecturedans un fichier (sur lequel peut avoir été redirigée l’entrée standard !).\nEn fait, il est très simple de régler définitivement ce problème. Il suffit d’employer (revoyez\nl’exemple de la section 2.3 du chapitre consacré aux chaînes), à la place de  :\n    gets (ligne) ;\nune instruction telle que ( LG désignant le nombre maximal de caractères acceptés) :\n    fgets (ligne, LG, stdin)Delannoy Livre.book  Page 192  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 193chapitre n° 10 Les fichiers\nExercices\nTous ces exercices sont corrigés en fin de volume.\n1) Écrire un programme permettant d’afficher le contenu d’un fichier texte en numérotant les\nlignes. Ces lignes ne devront jamais comporter plus de 80 caractères.\n2) Écrire un programme permettant de créer séquentiellement un fichier « répertoire » compor-\ntant pour chaque personne :\n●nom (20 caractères maximum) ;\n●prénom (15 caractères maximum) ;\n●âge (entier) ;\n●numéro de téléphone (11 caractères maximum).\nLes informations relatives aux différentes personnes seront lues au clavier.\n3) Écrire un programme permettant, à partir du fichier créé par l’exercice précédent, de\nretrouver les informations correspondant à une personne de nom donné.\n4) Écrire un programme permettant, à partir du fichier créé dans l’exercice 2, de retrouver les\ninformations relatives à une personne de rang donné (par accès direct).Delannoy Livre.book  Page 193  Mercredi, 6. mai 2009  4:26 16\nDelannoy Livre.book  Page 194  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 195Chapitre 11\nLa gestion dynamique \nde la mémoire\nNous avons déjà eu l’occasion de faire la distinction entre les données statiques (variables\nglobales ou locales statiques) et les données automatiques (variables locales). D’autre part,nous avons évoqué les possibilités d’allocation dynamique d’espace mémoire.\nCela signiﬁe qu’en langage C un programme comporte en déﬁnitive trois types de données :\n●statiques ;\n●automatiques ;\n●dynamiques.\nLes données statiques  occupent un emplacement parfaitement déﬁni lors de la compilation.\nLes données automatiques , en revanche, n’ont pas une taille déﬁnie a priori. En effet, elles ne\nsont créées et détruites qu’au fur et à mesure de l’exécution du programme. Elles sont souvent\ngérées sous forme de ce que l’on nomme une pile (stack en anglais), laquelle croît ou décroît\nsuivant les besoins du programme. Plus précisément, elle croît à chaque entrée dans une fonc-tion pour faire place à toutes les variables locales nécessaires pendant la durée de vie de lafonction ; elle décroît d’autant à chaque sortie.\nLes données dynamiques  n’ont pas non plus de taille déﬁnie a priori. Leur création ou leur\nlibération dépend, cette fois, de demandes explicites faites lors de l’exécution du programme.Delannoy Livre.book  Page 195  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n196 © Éditions EyrollesLeur gestion, qui ne saurait se faire à la manière d’une pile, est indépendante de celle des\ndonnées automatiques. Plus précisément, elle se fait généralement dans ce que l’on nomme untas (heap en anglais) dans lequel on cherche à allouer ou à libérer de l’espace en fonction des\nbesoins.\nEn déﬁnitive, les données d’un programme se répartissent en trois catégories : statiques, auto-\nmatiques et dynamiques. Les données statiques sont déﬁnies dès la compilation ; la gestiondes données automatiques reste transparente au programmeur et seules les données dynamiquessont véritablement créées sur son initiative.\nD’une manière générale, l’emploi de données statiques présente certains défauts intrinsèques.\nCitons deux exemples :\n●Les données statiques ne permettent pas de déﬁnir des tableaux de dimensions variables,c’est-à-dire dont les dimensions peuvent être ﬁxées lors de l’exécution et non dès la com-pilation. Il est alors nécessaire d’en ﬁxer arbitrairement une taille limite, ce qui conduitgénéralement à une mauvaise utilisation de l’ensemble de la mémoire.\n●La gestion statique ne se prête pas aisément à la mise en œuvre de listes chaînées, d’arbresbinaires,... objets dont ni la structure ni l’ampleur ne sont généralement connues lors de lacompilation du programme.\nLes données dynamiques vont permettre de pallier ces défauts en donnant au programmeurl’opportunité de s’allouer et de libérer de la mémoire dans le « tas », au fur et à mesure de sesbesoins.\n1Les outils de base de la gestion dynamique : malloc  et free\nCommençons par étudier les deux fonctions les plus classiques de gestion dynamique de lamémoire, à savoir \nmalloc  et free .\n1.1 La fonction malloc\na) Premier exemple\nConsidérez ces instructions :\n     #include <stdlib.h>\n        .....      char * adr ;        .....     adr = malloc (50) ;        .....     for (i=0 ; i<50 ; i++) *(adr+i) = 'x' ;Delannoy Livre.book  Page 196  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 197chapitre n° 11 La gestion dynamique de la mémoire\nL ’appel :\nmalloc (50)\nalloue un emplacement de 50 octets dans le tas et en fournit l’adresse en retour. Ici, cette\ndernière est placée dans le pointeur adr.\nL ’instruction for qui vient à la suite n’est donnée qu’à titre d’exemple d’utilisation de la zone\nainsi créée.\nb) Second exemple \n     long * adr ;\n        .....     adr = malloc (100 * sizeof(long)) ;        .....     for (i=0 ; i<100 ; i++) *(adr+i) = 1 ;\nCette fois, nous nous sommes alloué une zone de  100 * sizeof(long)  octets (notez\nl’emploi de sizeof qui assure la portabilité). Mais nous l’avons considérée comme une suite\nde 100 entiers de type long . Pour ce faire, vous voyez que nous avons pris soin de placer le\nrésultat de malloc dans un pointeur sur des éléments de type long . N’oubliez pas que les\nrègles de l’arithmétique des pointeurs font que :\nadr + i\ncorrespond à l’adresse contenue dans adr, augmentée de sizeof(long) fois la valeur de i\n(puisque adr pointe sur des objets de longueur sizeof(long) ).\nc) D’une manière générale \nLe prototype de malloc  (qui ﬁgure dans stdlib.h ) est précisément :\nvoid * malloc (size_t taille)        (stdlib.h) \nIl montre tout d’abord que le résultat fourni par malloc  est un pointeur générique (revoyez\néventuellement le paragraphe correspondant du chapitre relatif aux pointeurs). Il pourra donc\nêtre converti implicitement en pointeur de n’importe quel type (c’est-à-dire sans qu’il soitnécessaire de faire appel explicitement à l’opérateur de \ncast ) ; ainsi, dans nos précédents\nexemples, il a pu être converti en char *  ou en  long * . Une telle conversion peut apparaître\nrelativement ﬁctive, dans la mesure où l’adresse correspondante n’est pas modiﬁée par laconversion. Elle n’en a pas moins une grande importance puisque, comme nous l’avons déjàmentionné à diverses reprises, la connaissance du type d’un pointeur intervient dans lescalculs arithmétiques portant sur ce pointeur.\nD’autre part, nous constatons que l’unique argument de \nmalloc  est d’un type a priori inat-\ntendu (nous aurions pu penser à int ou long ). En fait, size_t  est un nom de type prédéﬁni\npar typedef  size_t  est précisément déﬁni dans le ﬁchier stddef.h , mais vous n’avez pasDelannoy Livre.book  Page 197  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n198 © Éditions Eyrollesbesoin d’inclure vous-même ce ﬁchier car cela est déjà prévu dans stdlib.h . Le type exact\nlui correspondant dépend de l’implémentation. Cela signiﬁe donc que la taille maximale des\nobjets que l’on peut s’allouer par malloc  dépend de l’implémentation. (En pratique, toute-\nfois, on peut toujours compter sur un minimum de 64 Ko).\nEnﬁn, il faut savoir que malloc  fournit un pointeur nul  (NULL ) dans le cas où l’allocation\nmémoire a échoué. Bien entendu, dans un programme opérationnel, il sera nécessaire de\ns’assurer qu’aucun problème de cette sorte n’apparaît.\n1.2 La fonction free\nL ’un des intérêts essentiels de la gestion dynamique est de pouvoir récupérer des emplace-ments dont on n’a plus besoin. Le rôle de la fonction \nfree  est de libérer un emplacement\npréalablement alloué.\nV oici un exemple de programme, exécuté ici dans un environnement DOS. Il vous montre\ncomment malloc  peut proﬁter d’un espace préalablement libéré sur le tas.\nNotez que la dernière allocation a pu se faire dans l’espace libéré par le précédent appel de\nfree .Exemple d’utilisation de la fonction free\n#include <stdio.h>\n#include <stdlib.h>main(){   char * adr1, * adr2, * adr3 ;   adr1 = malloc (100) ;   printf (\"allocation de 100 octets en %p\\n\", adr1) ;   adr2 = malloc (50) ;   printf (\"allocation de  50 octets en %p\\n\", adr2) ;\n   free (adr1) ;\n   printf (\"libération de 100 octets en %p\\n\", adr1) ;   adr3 = malloc (40) ;   printf (\"allocation de  40 octets en %p\\n\", adr3) ;}\nallocation de 100 octets en 06ACallocation de  50 octets en 0714libération de 100 octets en 06AC\nallocation de  40 octets en 06E8Delannoy Livre.book  Page 198  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 199chapitre n° 11 La gestion dynamique de la mémoire\nDans cet exemple, vous pouvez constater que l’allocation d’une zone de 100 octets nécessite\nen fait un peu plus de place mémoire (exactement 104 octets). La différence (4 octets) corres-\npond à des « octets de service » dans lesquels le système place les informations nécessairesà sa gestion dynamique de la mémoire.\nLa norme prévoit que malloc  alloue convenablement de l’espace, en tenant compte d’éventuelles\ncontraintes d’alignement de l’objet concerné. Or, en toute rigueur, malloc  n’a pas d’information\nprécise sur le type de l’objet (elle n’en a que la longueur !). Dans ces conditions, le respect dela norme peut prendre des allures différentes suivant l’implémentation :\n• alignement basé sur la taille demandée,• alignement systématique tenant compte de la contrainte d’alignement la plus forte.Dans tous les cas, bien sûr, aucun risque n’existe. Simplement, la taille mémoire réellement\nutilisée pourra, pour un type donné, différer d’une implémentation à une autre (notez qu’entoute rigueur c’est déjà ce qui se produit avec les octets de service dont le nombre peut varier\navec l’implémentation).\n2D’autres outils de gestion dynamique : calloc  et realloc\nBien qu’elles soient moins fondamentales que les précédentes, les deux fonctions calloc  et\nrealloc  peuvent s’avérer pratiques dans certaines circonstances.\n2.1 La fonction calloc\nLa fonction :\nvoid * calloc ( size_t nb_blocs, size_t taille )    (stdlib.h)\nalloue l’emplacement nécessaire à nb_blocs  consécutifs, ayant chacun une taille de taille\noctets.\nContrairement à ce qui se passait avec malloc , où le contenu de l’espace mémoire alloué était\nimprévisible, calloc  remet à zéro chacun des octets de la zone ainsi allouée.\nLa taille de chaque bloc, ainsi que leur nombre sont tous deux de type size_t . On voit ainsi\nqu’il est possible d’allouer en une seule fois une place mémoire (de plusieurs blocs) beaucoup\nplus importante que celle allouée par malloc  (la taille limite théorique étant maintenant\nsize_t*size_t  au lieu de size_t ).Delannoy Livre.book  Page 199  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n200 © Éditions EyrollesEn général, l’allocation par calloc  de p blocs de n octets conduira à utiliser un peu moins de\nmémoire que p allocations de n octets par malloc  ; cela provient de ce que les éventuels\noctets de service ne seront attribués qu’une fois dans le premier cas (pour le système, il n’y a\nbien qu’une seule zone, même si nous avons formulé notre demande à malloc  sous la forme\nde plusieurs blocs), alors qu’ils le seront p fois dans le second.\nLa remarque faite précédemment à propos des contraintes d’alignement s’applique également\nà calloc .\nUne zone allouée par calloc  ne peut être libérée qu’en une seule fois par free . Il n’est pas\nquestion d’essayer de n’en libérer qu’un morceau (comme nous l’avons déjà dit, les octets\nalloués par calloc  forment un tout pour le système).\n2.2 La fonction realloc\nLa fonction :\nvoid * realloc (void * pointeur, size_t taille )     (stdlib.h) \npermet de modiﬁer la taille d’une zone préalablement allouée (par malloc , calloc  ou\nrealloc ).\nLe pointeur doit être l’adresse de début de la zone dont on veut modiﬁer la taille. Quant à\ntaille , de type size_t , elle représente la nouvelle taille souhaitée.\nCette fonction restitue l’adresse de la nouvelle zone ou un pointeur nul dans le cas où l’alloca-\ntion a échoué.\nLorsque la nouvelle taille demandée est supérieure à l’ancienne, le contenu de l’ancienne zone\nest conservé (quitte à le recopier si la nouvelle adresse est différente de l’ancienne). Dans lecas où la nouvelle taille est inférieure à l’ancienne, le début de l’ancienne zone (c’est-à-dire\ntaille  octets) verra son contenu inchangé.\n3Exemple d’application de la gestion dynamique : création \nd’une liste chaînée\nComme nous l’avons déjà évoqué en introduction de ce chapitre, il n’est pas possible de décla-rer un tableau dont le nombre d’éléments n’est pas connu lors de la compilation. En revanche,les possibilités de gestion dynamique du langage C nous permettent d’envisager d’allouer desemplacements aux différents éléments du tableau au fur et à mesure des besoins.Delannoy Livre.book  Page 200  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 201chapitre n° 11 La gestion dynamique de la mémoire\nSi l’on n’a pas besoin d’accéder directement à chacun des éléments, on peut se contenter de\nconstituer ce que l’on nomme une « liste chaînée », dans laquelle :\n●un pointeur désigne le premier élément ;\n●chaque élément comporte un pointeur sur l’élément suivant.\nDans ce cas, les emplacements des différents éléments peuvent être alloués de façon dynamique,au fur et à mesure des besoins. Il n’est plus nécessaire de connaître d’av ance leur nombre ou une\nvaleur maximale (ce qui serait le cas si l’on créait un tableau de tels éléments).\nAppliquons cela à des éléments de type \npoint , structure comportant les champs suivants :\nstruct point { int num ;\n               float x ;               float y ;             } ;\nChaque élément doit donc contenir un pointeur sur un élément de même type. Il y a là une\nrécursivité des déclarations qui est autorisée en C. Ainsi, nous pourrons adapter notre précédentestructure de la manière suivante :\n    struct element { int num ;\n                     float x ;                     float y ;                     struct element * suivant ;                   } ;\nV ous voyez que nous avons été amené à utiliser dans la description du modèle element  un\npointeur sur ce même modèle.\nSupposons que nous cherchions à constituer notre liste chaînée à partir d’informations fournies\nen données. Deux possibilités s’offrent à nous :\n●ajouter chaque nouvel élément à la ﬁn de la liste. Le parcours ultérieur de la liste se feraalors dans le même ordre que celui dans lequel les données ont été introduites.\n●ajouter chaque nouvel élément au début de la liste. Le parcours ultérieur de la liste se feraalors dans l’ordre inverse de celui dans lequel les données ont été introduites.\nNous avons choisi ici de programmer la seconde méthode, laquelle se révèle légèrement plussimple que la deuxième.\nNotez que le dernier élément de la liste (donc, dans notre cas, le premier lu) ne pointera sur\nrien. Or, lorsque nous chercherons ensuite à utiliser notre liste, il nous faudra être en mesurede savoir où elle s’arrête . Certes, nous pourrions, à cet effet, conserver l’adresse de son der-\nnier élément. Mais il est plus simple d’attribuer au champ suivant  de ce dernier élément une\nvaleur ﬁctive dont on sait qu’elle ne peut apparaître par ailleurs. La valeur \nNULL  (0) fait très\nbien l’affaire.Delannoy Livre.book  Page 201  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n202 © Éditions EyrollesIci, nous avons décidé de faire effectuer la création de la liste par une fonction. Le programme\nprincipal se contente de réserver l’emplacement d’un pointeur destiné à désigner le premierélément de la liste. Sa valeur effective sera fournie par la fonction \ncreation . Dans ces\nconditions, il est nécessaire que le programme principal lui fournisse, non pas la valeur,mais l’adresse de ce pointeur (du moins si l’on souhaite pouvoir disposer ultérieurement decette valeur au sein du programme principal).\nC’est ce qui justiﬁe la forme de l’en-tête de la fonction \ncreation  :\nvoid creation (struct element * * adeb)\ndans laquelle adeb  est effectivement du type « pointeur sur un pointeur sur un élément de type\nstruct element  ».\nCréation d’une liste chaînée\n#include <stdio.h>\n#include <stdlib.h>struct element { int num ;                 float x ;                 float y ;                 struct element * suivant ;               } ;void creation (struct element * * adeb) ;main(){   struct element *  debut ;   creation (&debut) ;}void creation (struct element * * adeb){   int num ;   float x, y ;   struct element * courant ;   * adeb = NULL ;   while ( printf(\"numéro x y : \"),           scanf (\"%d %f %f\", &num, &x, &y), num)       { courant = (struct element *) malloc (sizeof(struct element)) ;         courant -> num     = num ;         courant -> x       = x ;         courant -> y       = y ;         courant -> suivant = * adeb ;         * adeb = courant ;       }}Delannoy Livre.book  Page 202  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 203chapitre n° 11 La gestion dynamique de la mémoire\nBien entendu, la constitution d’une telle liste n’est souvent que le préalable à un traitement\nplus sophistiqué. En particulier, dans un cas réel, on pourrait être amené à réaliser des opérationstelles que :\n●insertion d’un nouvel élément dans la liste ;\n●suppression d’un élément de la liste.\nExercice\nCet exercice est corrigé en fin de volume.\nAjouter au programme de création d’une liste chaînée du paragraphe 3 une fonction permet-\ntant d’afficher le contenu de la liste chaînée précédemment créée. Cette fonction posséderacomme unique argument l’adresse de début de la liste.Delannoy Livre.book  Page 203  Mercredi, 6. mai 2009  4:26 16\nDelannoy Livre.book  Page 204  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 205Chapitre 12\nLe préprocesseur\nNous avons déjà été amené à évoquer l’existence d’un « préprocesseur ». Il s’agit d’un pro-\ngramme qui est exécuté automatiquement avant la compilation et qui transforme votre ﬁchiersource à partir d’un certain nombre de directives. Ces dernières, contrairement à ce qui seproduit pour les instructions du langage C, sont écrites sur des lignes distinctes du reste duprogramme ; elles sont toujours introduites par un mot précis commençant par le caractère #.\nParmi ces directives, nous avons déjà utilisé \n#include  et #define . Nous nous proposons\nici d’étudier les diverses possibilités offertes par le préprocesseur, à savoir :\n●l’incorporation de ﬁchiers source (directive #include ) ;\n●la déﬁnition de symboles et de macros (directive #define ) ;\n●la compilation conditionnelle.\n1La directive #include\nElle permet d’incorporer, avant compilation, le texte ﬁgurant dans un ﬁchier quelconque.Jusqu’ici, nous n’avions incorporé de cette manière que les contenus de ﬁchiers en-tête requispour le bon usage des fonctions standard. Mais cette directive peut s’appliquer également àdes ﬁchiers de votre cru. Cela peut s’avérer utile, par exemple pour écrire une seule fois lesDelannoy Livre.book  Page 205  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n206 © Éditions Eyrollesdéclarations communes à plusieurs ﬁchiers source différents, en particulier dans le cas des\nprototypes de fonctions.\nRappelons que cette directive possède deux syntaxes voisines :\n#include <nom_fichier>\nrecherche le ﬁchier mentionné dans un emplacement (chemin, répertoire) déﬁni par l’implé-\nmentation.\n#include \"nom_fichier\"\nrecherche le ﬁchier mentionné dans le même emplacement (chemin, répertoire) que celui oùse trouve le programme source.\nGénéralement, la première est utilisée pour les ﬁchiers en-tête correspondant à la bibliothèque\nstandard, tandis que la seconde l’est plutôt pour les ﬁchiers que vous créez vous-même.\nUn fichier incorporé par #include  peut lui-même comporter, à son tour, des directives #include  ;\nc’est d’ailleurs le cas de certains fichiers en-tête relatifs à la bibliothèque standard. D’une\nmanière générale, le nombre maximal de niveaux d’imbrication des directives #include  dépend\nde l’implémentation ; toutefois, en pratique, il n’est jamais inférieur à 5.\nLorsque vous créez vos propres fichiers en-tête, il vous faut prendre garde à ne pas introduire\nplusieurs fois des déclarations identiques, ce qui risquerait de conduire à des erreurs de com-pilation. Ce point est particulièrement crucial dans le cas d’imbrication des directives \n#include .\nD’une manière générale, ce genre de problème, qui se pose d’ailleurs fréquemment avec lesfichiers en-tête standard, se résout par l’emploi de directives conditionnelles, associé à la\ndéfinition de symboles particuliers (nous y reviendrons dans le paragraphe 3).\n2La directive #define\nElle offre en fait deux possibilités :\n●déﬁnition de symboles (c’est sous cette forme que nous l’avons employée jusqu’ici) ;\n●déﬁnition de macros.\n2.1 Déﬁnition de symboles\nUne directive telle que :\n     #define  nbmax  5\ndemande de substituer au symbole nbmax  le texte 5, et cela chaque fois que ce symbole appa-\nraîtra dans la suite du ﬁchier source.Delannoy Livre.book  Page 206  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 207chapitre n° 12 Le préprocesseur\nUne directive :\n     #define  entier  int\nplacée en début de programme, permettra d’écrire en français les déclarations de variables\nentières. Ainsi, par exemple, ces instructions :\nentier a, b ;\nentier * p ;\nseront remplacées par :\nint a, b ;int * p ;\nIl est possible de demander de faire apparaître dans le texte de substitution un symbole déjà\ndéﬁni. Par exemple, avec ces directives :\n     #define  nbmax  5\n      ....     #define  taille  nbmax + 1\nChaque mot  taille  apparaissant dans la suite du programme sera systématiquement rem-\nplacé par 5+1. Notez bien que taille  ne sera pas remplacé exactement par 6 mais, étant\ndonné que le compilateur accepte les expressions constantes là où les constantes sont autorisées,\nle résultat sera comparable (après compilation).\nIl est même possible de demander de substituer à un symbole un texte vide. Par exemple, avec\ncette directive :\n     #define  rien\ntous les symboles rien  ﬁgurant dans la suite du programme seront remplacés par un texte\nvide. Tout se passera donc comme s’ils ne ﬁguraient pas dans le programme.\nNous verrons qu’une telle possibilité n’est pas aussi fantaisiste qu’il y paraît au premier abord\npuisqu’elle pourra intervenir dans la compilation conditionnelle.\nV oici quelques derniers exemples vous montrant comment résumer en un seul mot une ins-\ntruction C :\n     #define  bonjour  printf(\"bonjour\") \n     #define  affiche  printf(\"resultat %d\\n\", a)     #define  ligne    printf(\"\\n\")\nNotez que nous aurions pu inclure le point-virgule de ﬁn dans le texte de substitution.\nD’une manière générale, la syntaxe de cette directive fait que le symbole à remplacer ne peut\ncontenir d’espace (puisque le premier espace sert de délimiteur entre le symbole à substituer etle texte de substitution). Le texte de substitution, quant à lui, peut contenir autant d’espacesDelannoy Livre.book  Page 207  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n208 © Éditions Eyrollesque vous le souhaitez puisque c’est la ﬁn de ligne qui termine la directive. Il est même possible\nde le prolonger au-delà, en terminant la ligne par \\ et en poursuivant sur la ligne suivante.\nV ous voyez que, compte tenu des possibilités d’imbrication des substitutions, cette instruction\ns’avère très puissante au point qu’elle pourrait permettre à celui qui le souhaiterait de réécriretotalement le langage C (on pourrait, par exemple, le franciser). Cette puissance a toutefois sespropres limites dans la mesure où tout abus dans ce sens conduit inexorablement à une pertede lisibilité des programmes.\nSi vous introduisez, par mégarde, un signe = dans une directive #define , aucune erreur ne\nsera, bien sûr, détectée par le préprocesseur lui-même. Par contre, en général, cela conduira\nà une erreur de compilation. Ainsi, par exemple, avec :\n#define N = 5\nune instruction telle que :\nint t[N] ;\ndeviendra, après traitement par le préprocesseur :\nint t[= 5] ;\nlaquelle est manifestement erronée. Notez bien, toutefois, que, la plupart du temps, vous neconnaîtrez pas le texte généré par le préprocesseur et vous serez simplement en présenced’un diagnostic de compilation concernant apparemment l’instruction \nint t[N] . Le diagnostic\nde l’erreur en sera d’autant plus délicat.\nUne autre erreur aussi courante que la précédente consiste à terminer (à tort) une directive\n#include  par un point-virgule. Les considérations précédentes restent valables dans ce cas.\nCertaines implémentations permettent d’avoir connaissance du texte généré par le préproces-\nseur, c’est-à-dire, du texte qui sera véritablement compilé ; cette facilité peut rendre plus aisé\nle diagnostic d’erreurs telles que celles que nous venons d’envisager.\n2.2 Déﬁnition de macros\nLa déﬁnition de macros ressemble à la déﬁnition de symboles mais elle fait intervenir la\nnotion de paramètres.\nPar exemple, avec cette directive :\n#define  carre(a)  a*a\nle préprocesseur remplacera dans la suite tous les textes de la forme :\ncarre(x)Delannoy Livre.book  Page 208  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 209chapitre n° 12 Le préprocesseur\ndans lesquels x représente en fait un symbole quelconque par :\nx*x\nPar exemple :\ncarre(z)        deviendra   z*z\ncarre(valeur)   deviendra   valeur*valeur\ncarre(12)       deviendra   12*12\nLa macro précédente ne disposait que d’un seul paramètre, mais il est possible d’en faire inter-\nvenir plusieurs en les séparant, classiquement, par des virgules. Par exemple, avec :\n     #define  dif(a,b)  a-b\ndif(x,z)         deviendrait    x-z\ndif(valeur+9,n)  deviendrait    valeur+9-n\nLà encore, les déﬁnitions peuvent s’imbriquer. Ainsi, avec les deux déﬁnitions précédentes, le\ntexte :\ndif(carre(p),carre(q))   \nsera, dans un premier temps, remplacé par :\ndif(p*p,q*q)\npuis, dans un second temps, par :\np*p-q*q\nNéanmoins, malgré la puissance de cette directive, il ne faut pas oublier que, dans tous les cas,il ne s’agit que de substitution de texte. Il est souvent nécessaire de prendre quelques précau-tions, notamment lorsque le texte de substitution fait intervenir des opérateurs. Par exemple,avec ces instructions :\n#define DOUBLE(x) x + x\n     .....DOUBLE(a)/bDOUBLE(x+2*y)DOUBLE(x++)\nLe texte généré par le préprocesseur sera le suivant :\na + a/bx+2*y + x+2*yx++ + x++Delannoy Livre.book  Page 209  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n210 © Éditions EyrollesV ous constatez que, si le premier appel de macro conduit à un résultat correct, le deuxième ne\nfournit pas, comme on aurait pu l’escompter, le double de l’expression ﬁgurant en paramètre.Quant au troisième, il fait apparaître ce que l’on nomme souvent un « effet de bord ». En effet,la notation :\nDOUBLE(x++)\nconduit à incrémenter deux fois la variable x. De plus, elle ne fournit pas vraiment son double.\nPar exemple, si x contient la valeur 5, l’exécution du programme ainsi généré conduira à\ncalculer 5+6.\nLe premier problème, lié aux priorités relatives des opérateurs, peut être facilement résolu enintroduisant des parenthèses dans la déﬁnition de la macro. Ainsi, avec :\n#define DOUBLE(x) ((x)+(x))\n   ...DOUBLE(a)/bDOUBLE(x+2*y)DOUBLE(x++)\nLe texte généré par le préprocesseur sera :\n((a)+(a))/b((x+2*y)+(x+2*y))((x++)+(x++))\nLes choses sont nettement plus satisfaisantes pour les deux premiers appels de la macro DOUBLE .\nPar contre, bien entendu, l’effet de bord introduit par le troisième n’a pas pour autant disparu.\nPar ailleurs, il faut savoir que les substitutions de paramètres ne se font pas à l’intérieur des\nchaînes de caractères. Ainsi, avec ces instructions :\n#define AFFICHE(y) printf(\"valeur de y %d\",y)\n   ...AFFICHE(a) ;AFFICHE(c+5) ;\nle texte généré par le préprocesseur sera :\nprintf(\"valeur de y %d\",a) ;printf(\"valeur de y %d\",c+5) ;\nDans la définition d’une macro, il est impératif de ne pas prévoir d’espace dans la partie spéci-\nfiant le nom de la macro et les différents paramètres. En effet, là encore, le premier espace sert\nà délimiter la macro à définir. Par exemple, avec :\n    #define somme (a,b) a+b\n       ...    z = somme(x+5) ;Delannoy Livre.book  Page 210  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 211chapitre n° 12 Le préprocesseur\nle préprocesseur générerait le texte :\n    z = (a,b) a+b(x+5) ;\n    La norme C99 permet de définir des « fonctions en ligne ». Elles sont repérées par le mot\ninline  figurant devant leur en-tête et leurs instructions sont incorporées à chaque appel, comme\nle sont celles des macros. Mais les fonctions en ligne présentent l’avantage sur les macros de\nne plus induire d’effets de bords.\n3 La compilation conditionnelle\nUn certain nombre de directives permettent d’incorporer ou d’exclure des portions du ﬁchier\nsource dans le texte qui est analysé par le préprocesseur. Ces directives se classent en deuxcatégories en fonction de la condition qui régit l’incorporation :\n●existence ou inexistence de symboles ;\n●valeur d’une expression.\n3.1 Incorporation liée à l’existence de symboles\n     #ifdef symbole\n       .....     #else       .....     #endif\ndemande d’incorporer le texte ﬁgurant entre les deux lignes #ifdef  et #else  si le symbole\nindiqué est effectivement déﬁni au moment où l’on rencontre #ifdef . Dans le cas contraire,\nc’est le texte ﬁgurant entre #else  et #endif  qui sera incorporé. La directive #else  peut,\nnaturellement, être absente.\nDe façon comparable :\n     #ifndef symbole\n      .....     #else      .....     #endifDelannoy Livre.book  Page 211  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n212 © Éditions Eyrollesdemande d’incorporer le texte ﬁgurant entre les deux lignes #ifndef  et #else  si le symbole\nindiqué n’est pas déﬁni. Dans le cas contraire, c’est le texte ﬁgurant entre #else  et #endif\nqui sera incorporé.\nNotez bien que, pour qu’un tel symbole soit effectivement déﬁni pour le préprocesseur, il doit\nfaire l’objet d’une directive #define . Notamment, ne confondez pas ces symboles avec\nd’éventuelles variables qui pourraient être déclarées par des instructions C classiques, et qui,quant à elles, ne sont absolument pas connues du préprocesseur.\nV oici un exemple d’utilisation de ces directives :\n#define MISEAUPOINT\n   .....#ifdef MISEAUPOINT   instructions 1#else   instructions 2#endif\nIci, les instructions 1 seront incorporées par le préprocesseur, tandis que les instructions 2 ne\nle seront pas. En revanche, il sufﬁrait de supprimer la directive #define MISEAUPOINT\npour aboutir au résultat contraire. \nCes définitions de symboles sont fréquemment utilisées dans les fichiers en-tête standard.\nIls permettent notamment d’inclure, depuis un fichier en-tête donné, un autre fichier en-tête,\nen s’assurant que ce dernier n’a pas déjà été inclus (afin d’éviter la duplication de certainesinstructions risquant de conduire à des erreurs de compilation). La même technique peut, bien\nsûr, s’appliquer à vos propres fichiers en-tête.\n3.2 Incorporation liée à la valeur d’une expression\nLa construction ci-après :\n     #if condition\n      .....     #else      .....     #endif\npermet d’incorporer l’une des deux parties du texte, suivant la valeur de la condition indiquée. Delannoy Livre.book  Page 212  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 213chapitre n° 12 Le préprocesseur\nEn voici un exemple d’utilisation :\n#define CODE 1\n   .....#if CODE == 1   instructions 1#endif#if CODE == 2   instructions 2#endif\nIci, ce sont les instructions 1 qui seront incorporées par le préprocesseur. Mais il s’agirait des\ninstructions 2 si nous remplacions la première directive par :\n#define CODE 2\nNotez qu’il existe également une directive #elif  qui permet de condenser les choix imbri-\nqués. Par exemple, nos précédentes instructions pourraient s’écrire :\n#define CODE 1   .....#if CODE == 1   instructions 1#elif CODE == 2   instructions 2#endif\nD’une manière générale, la condition mentionnée dans ces directives #if et #elif  peut faire\nintervenir n’importe quels symboles déﬁnis pour le préprocesseur et des opérateurs relation-\nnels, arithmétiques ou logiques. Ces derniers se notent exactement de la même manière qu’enlangage C.\nEn outre, il existe un opérateur noté \ndefined , utilisable uniquement dans les conditions desti-\nnées au préprocesseur ( if et elif ). Ainsi, l’exemple donné à la ﬁn de la section 3.1 pourrait\négalement s’écrire :\n#define MISEAUPOINT\n   .....#if defined(MISEAUPOINT)   instructions 1#else   instructions 2#endifDelannoy Livre.book  Page 213  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n214 © Éditions EyrollesD’une manière générale, les  directives de test de la valeur d’une expression peuvent s’avérer\nprécieuses :\n●pour introduire dans un ﬁchier source des instructions de mise au point que l’on pourraainsi introduire ou supprimer à volonté du module objet correspondant. Par une inter-vention mineure au niveau du source lui-même, il est possible de contrôler la présence oul’absence de ces instructions dans le module objet correspondant, et ainsi, de ne pas lepénaliser en taille mémoire lorsque le programme est au point.\n●pour adapter un programme unique à différents environnements. Les paramètres déﬁnissantl’environnement sont alors exprimés dans des symboles du préprocesseur.Delannoy Livre.book  Page 214  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 215Chapitre 13 \nLes possibilités du langage C \nproches de la machine\nL ’une des caractéristiques du langage C est précisément d’offrir des possibilités de program-\nmation comparables à celles de l’assembleur (ou du langage machine). Ce chapitre se pro-pose de vous les présenter. Après avoir effectué quelques rappels sur le codage des nombresen binaire, nous apporterons quelques précisions sur le « qualiﬁcatif de signe » (\nsigned/\nunsigned ) que nous avions éludé jusqu’ici et nous verrons comment, dans ce cas, se géné-\nralisent les règles de conversion. Nous étudierons ensuite les opérateurs de manipulation debits puis nous verrons comment, dans une structure, déﬁnir des champs ayant une taille infé-rieure à un octet (à l’aide de « champs de bits »). Enﬁn, nous aborderons ce que l’on nommeles « unions ».\nD’une manière générale, sachez que tous les points évoqués dans ce chapitre sont, par essence\nmême, peu portables. Leur emploi devra généralement soit être limité à des programmesdestinés à un matériel donné, soit être parfaitement « localisé » au sein du programme, aﬁn depermettre, le cas échéant, l’adaptation du programme à une autre machine.Delannoy Livre.book  Page 215  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n216 © Éditions Eyrolles1 Compléments sur les types d’entiers\n1.1 Rappels concernant la représentation\ndes nombres entiers en binaire\nPour ﬁxer les idées, nous raisonnerons ici sur des nombres entiers représentés sur 16 bits, mais\nil va de soi qu’il serait facile de généraliser notre propos à une taille quelconque.\nQuelle que soit la machine (et donc, a fortiori, le langage !), les entiers sont codés en utilisant\nun bit pour représenter le signe (0 pour positif et 1 pour négatif).\na) Lorsqu’il s’agit d’un nombre positif  (ou nul), sa valeur absolue est écrite en base 2, à la suite\ndu bit de signe. V oici quelques exemples de codages de nombres (à gauche, le nombre en décimal,\nau centre, le codage binaire correspondant, à droite, le même codage exprimé en hexadécimal) :\n        1                0000000000000001                0001\n        2                0000000000000010                0002        3                0000000000000011                0003       16                0000000000010000                0010      127                0000000001111111                007F      255                0000000011111111                00FF\nb) Lorsqu’il s’agit d’un nombre  négatif, sa valeur absolue est alors codée suivant ce que l’on\nnomme la « technique du complément à deux ». Pour ce faire, cette valeur est d’abord exprimée\nen base 2 puis tous les bits sont inversés (1 devient 0 et 0 devient 1) et, enﬁn, on ajoute uneunité au résultat. V oici quelques exemples (avec la même présentation que précédemment) :\n       -1                1111111111111111                FFFF\n       -2                1111111111111110                FFFE       -3                1111111111111101                FFFD       -4                1111111111111100                FFFC      -16                1111111111110000                FFF0     -256                1111111100000000                FF00\nLe nombre 0 est codé d’une seule manière (0000000000000000).\nSi l’on ajoute 1 au plus grand nombre positif (ici 0 111111111111111, soit 7FFF en hexadécimal\nou 32768 en décimal) et que l’on ne tient pas compte de la dernière retenue (ou, ce qui revient\nau même, si l’on ne considère que les 16 derniers bits du résultat), on obtient... le plus petitnombre négatif possible (ici 1000000000000000, soit 8000 en hexadécimal ou -32768 en déci-mal). C’est ce qui explique le phénomène de modulo bien connu de l’arithmétique entière (les\ndépassements de capacité n’étant jamais signalés, quel que soit le langage considéré).Delannoy Livre.book  Page 216  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 217chapitre n° 13 Les possibilités du langage C proches de la machine\n1.2 Prise en compte d’un attribut de signe\nCe que nous venons d’exposer s’applique, en C, aux types short , int et long  (avec diffé-\nrents nombres de bits). Mais le langage C vous autorise à déﬁnir trois autres types voisins des\nprécédents en utilisant le qualiﬁcatif unsigned . Dans ce cas, on ne représente plus que des\nnombres positifs pour lesquels aucun bit de signe n’est nécessaire. Cela permet de doubler lataille des nombres représentables ; par exemple, avec 16 bits, on passe de l’intervalle [-32768;32767] à l’intervalle [0 ; 65535].\nToutefois, il ne faut pas perdre de vue que la notion de type n’est pas intrinsèque, autrement\ndit, lorsqu’on voit un motif binaire donné, on ne peut pas lui attribuer de valeur précise, tantqu’on ne sait pas comment il a été codé. Précisément, à un entier de 16 bits on pourra attribuerdeux valeurs différentes, suivant qu’on le considère comme « signé » ou « non signé ». Parexemple, \n1111111111111111  vaut -1 quand on le considère comme signé et 65535  quand\non le considère comme non signé.\nD’une manière similaire, avec printf (\"%u\", n)  on obtiendra (n étant le même dans les\ndeux cas) une valeur différente de celle fournie par printf (\"%d\", n)  ; en effet, rappelons\nque la fonction printf  n’a plus connaissance du type exact des valeurs qu’elle reçoit et que\nseul le code de format lui permet d’effectuer le « bon décodage ».\n1.3 Extension des règles de conversions\nTant qu’une expression ne mélange pas des types signés et des types non signés, les choses\nrestent naturelles. Il sufﬁt simplement de compléter les conversions short -> int -> long\npar les conversions unsigned short -> unsigned int -> unsigned long , mais\naucun problème nouveau ne se pose (on peut, certes, toujours obtenir des dépassements decapacité qui ne seront pas détectés).\nEn revanche, le mélange des types signés et des types non signés est (hélas !) accepté par le\nlangage ; mais il conduit à mettre en place des conversions (généralement de signé vers nonsigné) n’ayant guère de sens et ne respectant pas, de toute façon, l’intégrité des données (quepourrait d’ailleurs bien valoir \n-5 converti en non signé ?). Une telle liberté est donc à proscrire.\nÀ simple titre indicatif, sachez que les conversions prévues par la norme, dans ce cas, se contententde préserver le motif binaire (par exemple, la conversion de \nsigned  int en unsigned  int\nrevient à conserver tel quel le motif binaire concerné).\nLa même remarque prévaut pour les conversions forcées par une affectation ou par un opéra-\nteur de « cast ».\n1.4 La notation octale ou hexadécimale des constantes\nPour écrire une constante entière, vous pouvez utiliser une notation octale (base 8) ou hexa-décimale (base 16). La forme octale se note en faisant précéder le nombre écrit en base 8 duchiffre 0. Delannoy Livre.book  Page 217  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n218 © Éditions EyrollesPar exemple :\n            014 correspond à la valeur décimale 12,\n            037 correspond à la valeur décimale 31.\nLa forme hexadécimale se note en faisant précéder le nombre écrit en hexadécimal (les dix\npremiers chiffres se notent 0 à 9, A correspond à dix, B à onze,... F à quinze) des deux carac-tères \n0x (ou 0X). Par exemple :\n            0x1A  correspond à la valeur décimale 26 (16+10 )\nLes deux dernières notations doivent cependant être réservées aux situations dans lesquelleson s’intéresse plus au motif binaire qu’à la valeur numérique de la constante en question.D’ailleurs, tout se passe comme si l’on avait affaire, dans ce cas, à une valeur non signée et, làencore, il sera préférable d’éviter tout mélange (dans une même expression) avec des valeurssignées.\n2Compléments sur les types de caractères\n2.1 Prise en compte d’un attribut de signe\nA priori, le type char  peut, lui aussi, recevoir un attribut de signe ; en outre, la norme ne dit\npas si char  tout court correspond à unsigned  char  ou à signed char  (alors que, par\ndéfaut, tous les types entiers sont considérés comme signés).\nL ’attribut de signe d’une variable de type caractère n’a aucune incidence sur la manière dont\nun caractère donné est représenté (codé) : il n’y a qu’un seul jeu de codes sur 8 bits, soit256 combinaisons possibles en comptant le \n\\0. En revanche, cet attribut va intervenir dès lors\nqu’on s’intéresse à la valeur numérique associée au caractère et non plus au caractère lui-même. C’est le cas, par exemple, dans des expressions telles que les suivantes (\nc étant supposé\nde type caractère) :\nc + 1 \nc++printf (\"%d\", c) ;\nPour ﬁxer les idées, supposons, ici encore, que les entiers de type int sont représentés sur\n16 bits et voyons comment se déroule précisément la conversion char -> int  en question.Delannoy Livre.book  Page 218  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 219chapitre n° 13 Les possibilités du langage C proches de la machine\na) Si le caractère n’est pas signé, on ajoute à gauche de son code 8 bits égaux à 0. Par exemple :\n01001110  devient  0000000001001110\nb) Si le caractère est signé, on ajoute à gauche de son code 8 bits égaux au premier bit du code\ndu caractère. Par exemple :\n01001110  devient  0000000001001110\n11011001  devient  1111111111011001\nCette démarche revient, en fait, à considérer que les 8 bits du code du caractère représententun (petit) entier codé lui aussi suivant la technique du complément à deux, avec bit de signeà gauche. L ’opération de conversion alors décrite correspond à ce que l’on nomme la« propagation du bit de signe » ; elle permet d’obtenir un nombre entier sur 16 bits identique àcelui qui était représenté sur 8 bits. On peut dire que, vu comme cela, l’intégrité des donnéesest préservée, exactement comme elle l’était dans une conversion telle que \nint -> long\n(qui, au demeurant, emploie exactement la même technique de propagation du bit de signe).\nAinsi, si n est de type int et que c est de type caractère, l’instruction :\nn = c ;\nconduira à affecter à n :\n●une valeur comprise entre -128  et 127 si c est de type unsigned  char  ;\n●une valeur comprise entre 0 et 255 si c est de type signed char .\nLa même remarque s’applique à la valeur afﬁchée par :\nprintf (\"%d\", c) ;\n2.2 Extension des règles de conversion\nNotez qu’il n’y a aucune conversion d’un type caractère vers un autre type caractère, compte\ntenu des conversions systématiques. En revanche, les conversions d’un entier vers un caractèresont autorisées (dans les affectations ou avec l’opérateur de « cast »). Dans ce cas, elles sontsimplement mises en œuvre en ne conservant de l’entier que les bits les moins signiﬁcatifs : lemotif binaire obtenu est le même, que le caractère en question soit signé ou non signé.\nThéoriquement, de telles conversions apparaissent dans de banales affectations telles que :\nc = c + 1 ;      /* ou c++ ; */\nEn pratique, et quel que soit l’attribut de signe de c, compte tenu de ce qui vient d’être dit, tout\nse passe ﬁnalement comme si l’on avait ajouté 1 à 8 bits, sans tenir compte d’un éventuel\ndépassement de capacité (et d’ailleurs, il n’est pas dit que certains compilateurs ne fassent pas\ncela directement, sans passer par des conversions entier -> caractère -> entier).Delannoy Livre.book  Page 219  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n220 © Éditions Eyrolles3Les opérateurs de manipulation de bits\n3.1 Présentation des opérateurs de manipulation de bits\nLe langage C dispose d’opérateurs permettant de travailler directement sur le motif binaire\nd’une valeur. Ceux-ci lui procurent ainsi des possibilités traditionnellement réservées à la pro-grammation en langage assembleur.\nA priori, ces opérateurs ne peuvent porter que sur des types entiers . Toutefois, compte\ntenu des règles de conversion implicite, ils pourront également s’appliquer à des caractères\n(mais le résultat en sera entier).\nLe tableau ci-après fournit la liste de ces opérateurs qui se composent de cinq opérateurs binaires\net d’un opérateur unaire.\n3.2 Les opérateurs bit à bit\nLes 3 opérateurs &, | et ^ appliquent en fait la même opération à chacun des bits des deux opé-\nrandes. Leur résultat peut ainsi être déﬁni à partir d’une table (dite « table de vérité ») fournis-sant le résultat de cette opération lorsqu’on la fait porter sur deux bits de même rang de chacundes deux opérandes. Cette table est fournie par le tableau ci-après.\nL ’opérateur unaire \n~ (dit de « complément à un ») est également du type « bit à bit ». Il se\ncontente d’inverser chacun des bits de son unique opérande ( 0 donne 1 et 1 donne 0).Opérateurs de manipulation de bits\n     TYPE        OPÉRATEUR         SIGNIFICATION   ______________________________________________________________\n    binaire        &              ET (bit à bit)                   |              OU inclusif (bit à bit)                   ^              OU exclusif (bit à bit)                   <<             Décalage à gauche                   >>             Décalage à droite   ______________________________________________________________\n    unaire         ~              Complément à un (bit à bit)   ______________________________________________________________\nTable de vérité des opérateurs « bit à bit »\n       OPÉRANDE 1               0       0       1       1\n       OPÉRANDE 2               0       1       0       1      ______________________________________________________\n       ET (&)                   0       0       0       1\n       OU inclusif (|)          0       1       1       1       OU exclusif (^)          0       1       1       0Delannoy Livre.book  Page 220  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 221chapitre n° 13 Les possibilités du langage C proches de la machine\nV oici quelques exemples de résultats obtenus à l’aide de ces opérateurs. Nous avons supposé\nque les variables n et p étaient toutes deux du type int et que ce dernier utilisait 16 bits. Nous\navons systématiquement indiqué les valeurs sous forme binaire, hexadécimale et décimale :\n       n           0000010101101110       056E       1390\n       p           0000001110110011       03B3        947       ______________________________________________________\n       n & p       0000000100100010       0122        290\n       n | p       0000011111111111       07FF       2047       n ^ p       0000011011011101       06DD       1757       ~ n         1111101010010001       FA91      -1391\nNotez que le qualiﬁcatif signed/unsigned  des opérandes n’a pas d’incidence sur le motif\nbinaire créé par ces opérateurs. Cependant, le type même du résultat produit se trouve déﬁni\npar les règles habituelles. Ainsi, dans nos précédents exemples, la valeur décimale de ~n serait\n64145  si n avait été déclaré unsigned int  (ce qui ne change pas son motif binaire).\n3.3 Les opérateurs de décalage\nIls permettent de réaliser des décalages à droite ou à gauche sur le motif binaire correspondantà leur premier opérande. L ’amplitude du décalage, exprimée en nombre de bits, est fournie parle second opérande. Par exemple :\nn << 2\nfournit comme résultat la valeur obtenue en décalant le motif binaire de n de 2 bits vers la\ngauche ; les bits de gauche sont perdus et des bits à zéro apparaissent à droite.\nDe même :\nn >> 3\nfournit comme résultat la valeur obtenue en décalant le motif binaire de n de 3 bits vers la\ndroite. Cette fois, les bits de droite sont perdus, tandis que des bits apparaissent à gauche.Ces derniers dépendent du qualiﬁcatif \nsigned/unsigned  du premier opérande. S’il s’agit\nde unsigned , les bits ainsi créés à gauche sont à zéro. S’il s’agit de signed , les bits ainsi\ncréés seront égaux au bit signe (il y a, ici encore, propagation du bit signe).V oici quelques exemples de résultats obtenus à l’aide de ces opérateurs de décalage. La variable\nn est supposée signed int , tandis que p est supposée unsigned int .\n(signed)   n            0000010101101110       1010110111011110\n(unsigned) p            0000010101101110       1010110111011110         ______________________________________________________\n         n << 2         0001010110111000       1011011101111000\n         n >> 3         0000000010101101       1111011011101111         p >> 3         0000000010101101       0001010110111011Delannoy Livre.book  Page 221  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n222 © Éditions Eyrolles3.4 Exemples d’utilisation des opérateurs de bits\nL ’opérateur & permet d’accéder à une partie des bits d’une valeur en masquant les autres. Par\nexemple, l’expression :\nn & 0xF\npermet de ne prendre en compte que les 4 bits de droite de n (que n soit de type char , short ,\nint ou long ).\nDe même :\nn & 0x8000\npermet d’extraire le « bit signe » de n, supposé de type int dans une implémentation où\ncelui-ci correspond à 16 bits.\nV oici un exemple de programme qui décide si un entier est pair ou impair, en examinant\nsimplement le dernier bit de sa représentation binaire :\n4Les champs de bits\nNous venons de voir que le langage C dispose d’opérateurs de bits très puissants permettant detravailler au niveau du bit. De plus, ce langage permet de déﬁnir, au sein des structures, desvariables occupant un nombre déﬁni de bits.Test de la parité d’un entier\n#include <stdio.h>\nmain(){   int n ;   printf (\"donnez un entier : \") ;    scanf (\"%d\", &n) ;   if ( n & 1 == 1 )         printf (\"il est impair\") ;      else           printf (\"il est pair\") ;}\ndonnez un entier : 58\nil est pair \n_________________\ndonnez un entier : 47\nil est impairDelannoy Livre.book  Page 222  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 223chapitre n° 13 Les possibilités du langage C proches de la machine\nCela peut s’avérer utile :\n●soit pour compacter l’information : par exemple, un nombre entier compris entre 0 et 15\npourra être rangé sur 4 bits au lieu de 16 (encore faudra-t-il utiliser convenablement les bitsrestants) ;\n●soit pour décortiquer le contenu d’un motif binaire, par exemple un mot d’état en prove-nance d’un périphérique spécialisé.\nV oyez cet exemple de déclaration :\n     struct etat\n          { unsigned pret : 1 ;            unsigned ok1  : 1 ;            int donnee1   : 5 ;            int           : 3 ;            unsigned ok2  : 1 ;            int donnee2   : 4 ;          } ;     struct etat mot ;\nLa variable mot ainsi déclarée peut être schématisée comme suit :\nLes indications ﬁgurant à la suite des « deux-points » précisent la longueur du champ en bits.\nLorsque aucun nom de champ ne ﬁgure devant cette indication de longueur, cela signiﬁe quel’on saute le nombre de bits correspondants (ils ne seront donc pas utilisés).\nAvec ces déclarations, la notation :\nmot.donnee1\ndésigne un entier signé pouvant prendre des valeurs comprises entre -16 et +15. Elle pourra\napparaître à n’importe quel endroit où C autorise l’emploi d’une variable de type int.\nLes seuls types susceptibles d’apparaître dans des champs de bits sont int et unsigned int .\nNotez que lorsqu’un champ de type int est de longueur 1, ses valeurs possibles sont 0 et -1\n(et non 0 et 1, comme ce serait le cas avec le type unsigned  int).donnee1 donnee2 pre t ok1 ok2Delannoy Livre.book  Page 223  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n224 © Éditions EyrollesLa norme ne précise pas si la description d’un champ de bits se fait en allant des poids faibles\nvers les poids forts ou dans le sens inverse. Ce point dépend donc de l’implémentation et, en\npratique, on rencontre les deux situations (y compris pour différents compilateurs sur unemême machine !). En outre, lorsqu’un champ de bits occupe plusieurs octets, l’ordre danslequel ces derniers sont décrits dépend, lui aussi, de l’implémentation.\nLa taille maximale d’un champ de bits dépend, elle aussi, de l’implémentation. En pratique, on\nrencontre fréquemment 16 bits ou 32 bits.\nL’emploi des champs de bits est, donc, par nature même, peu ou pas portable. Il doit, par\nconséquent, être réservé à des applications très spécifiques.\n5Les unions\nL ’union, en langage C, permet de faire partager un même emplacement mémoire par des varia-\nbles de types différents. Cela peut s’avérer utile :\n●pour économiser des emplacements mémoire, en utilisant un même emplacement pendant desphases différentes d’un même programme ; d’une manière générale, vous verrez que les pos-sibilités de gestion dynamique du langage C résolvent ce problème d’une façon plus pratique ;\n●pour interpréter de plusieurs façons différentes un même motif binaire. Dans ce cas, il seraalors fréquent que l’union soit elle-même associée à des champs de bits.\nV oyez d’abord cet exemple introductif qui n’a d’intérêt que dans une implémentation danslaquelle les types \nfloat  et  long  ont la même taille :\nUnion entre un entier et un flottant (supposés de même taille)\n#include <stdio.h>\nmain(){   union essai         { long n ;           float x ;         }  u ;   printf (\"donnez un nombre réel : \")  ;   scanf (\"%f\", &u.x) ;   printf (\" en entier, cela fait : %ld\", u.n) ;}\ndonnez un nombre réel : 1.23e4\nen entier, cela fait : 1178611712Delannoy Livre.book  Page 224  Mercredi, 6. mai 2009  4:26 16\n© Éditions Eyrolles 225chapitre n° 13 Les possibilités du langage C proches de la machine\nLa déclaration :\n     union essai\n           { long n ;             float x ;           }  u ;\nréserve un emplacement dont le nombre de bits correspond à la taille (ici supposée commune)\nd’un long  ou d’un float  qui pourra être considéré tantôt comme un entier long qu’on dési-\ngnera alors par u.n, tantôt comme un ﬂottant ( float ) qu’on désignera alors par u.x.\nD’une manière générale, la syntaxe de la description d’une union est analogue à celle d’unestructure. Elle possède un nom de modèle (ici \nessai , nous aurions d’ailleurs pu l’omettre) ;\ncelui-ci peut être ensuite utilisé pour déﬁnir d’autres variables de ce type. Par exemple, dansnotre précédent programme, nous pourrions déclarer d’autres objets du même type que \nu par :\nunion essai z, truc ;\nPar ailleurs, il est possible de réaliser une union portant sur plus de deux objets ; d’autre part,chaque objet peut être non seulement d’un type de base (comme dans notre exemple), maiségalement de type structure. En voici un exemple dans lequel nous réalisons une union entreune structure \netat  telle que nous l’avions déﬁnie dans le paragraphe précédent et un entier\n(cela n’aura d’intérêt que dans des implémentations où le type int occupe 16 bits).\n     struct etat\n          { unsigned pret : 1 ;            unsigned ok1  : 1 ;            int donnee1   : 5 ;            int           : 3 ;            unsigned ok2  : 1 ;            int donnee2   : 4 ;          } ;     union           { int valeur ;            struct etat bits ;          } mot ;\nNotez qu’ici nous n’avons pas donné de nom au modèle d’union et nous y avons déclaré direc-\ntement une variable mot.\nAvec ces déclarations, il est alors possible, par exemple, d’accéder à la valeur de mot, consi-\ndéré comme un entier, en la désignant par :\nmot.valeurDelannoy Livre.book  Page 225  Mercredi, 6. mai 2009  4:26 16\nProgrammer en langage C\n226 © Éditions EyrollesQuant aux différentes parties désignant ce mot, il sera possible d’y accéder en les désignant\npar :\nmot.bits.pret               \nmot.bits.ok1                mot.bits.donnee1etc.Delannoy Livre.book  Page 226  Mercredi, 6. mai 2009  4:26 16\n \n© Éditions Eyrolles \n227 \nAnnexe  \nLes principales fonctions \nde la bibliothèque standard \nComme nous l’avons déjà mentionné, la norme ANSI fournit à la fois la description du\nlangage C et le contenu d’une bibliothèque standard. Plus précisément, cette bibliothèqueest subdivisée en plusieurs sous-bibliothèques ; à chaque sous-bibliothèque est associé unﬁchier « en-tête » (d’extension  \n.h \n) comportant essentiellement :  \n● \nles en-têtes des fonctions correspondantes ; \n● \nles déﬁnitions des macros correspondantes ; \n● \nles déﬁnitions de certains symboles utiles au bon fonctionnement des fonctions ou macrosde la sous-bibliothèque.\nLa présente anne x\ne décrit les  \nprincipales fonctions \n prévues par la norme. Chaque paragraphe\ncorrespond à une sous-bibliothèque et précise quel est le nom du ﬁchier en-tête correspondant. \nL \nes fonctions décrites ici sont classées par fichier en-tête, et non par ordre alphabétique.\nNéanmoins, si vous cherchez la description d’une fonction précise, il vous suffit de vous reporter \nà l’index situé en fin d’ouvrage. \nDelannoy Livre.book  Page 227  Mercredi, 6. mai 2009  4:27 16\n \nProgrammer en langage C \n228 \n© Éditions Eyrolles \n1 Entrées-sorties (stdio.h) \n1.1 Gestion des ﬁchiers \nFOPEN FILE \n  \n* \n  \nfopen \n  \n(const \n  \nchar \n  \n* \n  \nnomfichier, \n  \nconst \n  \nchar \n  \n* \n  \nmode) \nOuvre le ﬁchier dont le nom est fourni, sous forme d’une chaîne, à l’adresse\nindiquée par  \nnomfichier \n. Fournit, en retour, un « ﬂux » (pointeur sur une\nstructure de type prédéﬁni  \nFILE \n), ou un pointeur nul si l’ouverture a échoué.\nLes valeurs possibles de  \nmode \n sont décrites dans le chapitre traitant des\nﬁchiers. \nFCLOSE int \n  \nfclose \n  \n(FILE \n  \n* \n  \nflux) \nVide éventuellement le tampon associé au ﬂux concerné, désalloue l’espacemémoire attribué à ce tampon et ferme le ﬁchier correspondant. Fournit lavaleur  \nEOF \n en cas d’erreur et la valeur  \n0 \n dans le cas contraire. \n1.2 Écriture formatée \nToutes ces fonctions utilisent une chaîne de caractères nommée  \nformat \n, composée à la fois de\ncaractères quelconques et de codes de format dont la signiﬁcation est décrite en détail à la ﬁn\ndu présent paragraphe. \nFPRINTF int \n  \nfprintf \n  \n(FILE \n  \n* \n  \nflux, \n  \nconst \n  \nchar \n  \n* \n  \nformat, \n  \n...) \nConvertit les valeurs éventuellement mentionnées dans la liste d’arguments(...) en fonction du  \nformat \n spéciﬁé, puis écrit le résultat dans le  \nflux \n indi-\nqué. Fournit le nombre de caractères effectivement écrits ou une valeurnégative en cas d’erreur. \nPRINTF int \n  \nprintf \n  \n(const \n  \nchar \n  \n* \n  \nformat, \n  \n...) \nConvertit les valeurs éventuellement mentionnées dans la liste d’arguments(...) en fonction du  \nformat \n spéciﬁé, puis écrit le résultat sur la sortie stan-\ndard ( \nstdout \n). Fournit le nombre de caractères effectivement écrits ou une\nvaleur négative en cas d’erreur.\nNotez que : \n    printf (format, ...) ; \nest équivalent à : \n    fprintf (stdout, format, ...) ; \nDelannoy Livre.book  Page 228  Mercredi, 6. mai 2009  4:27 16\n \n© Éditions Eyrolles \n229 \nannexe Les principales fonctions de la bibliothèque standard \nSPRINTF int \n  \nsprintf \n  \n(char \n  \n* \n  \nch, \n  \nconst \n  \nchar \n  \n* \n format, ...) \nConvertit les valeurs éventuellement mentionnées dans la liste d’arguments\n(...) en fonction du  \nformat \n spéciﬁé et place le résultat dans la chaîne\nd’adresse ch, en le complétant par un caractère \\0. Fournit le nombre de\ncaractères effectivement écrits (sans tenir compte du \\0) ou une valeur néga-\ntive en cas d’erreur.\nLes codes de format utilisables avec ces trois fonctions\nChaque code de format a la structure suivante :\n   % [drapeaux] [largeur] [.précision] [h|l|L] conversion\ndans laquelle les crochets [ et ] signiﬁent que ce qu’ils renferment est facultatif. Les différentes\n« indications » se déﬁnissent comme suit  :\n●drapeaux :\n- : justiﬁcation à gauche\n+ : signe toujours présent\n^ : impression d’un espace au lieu du signe +\n# : forme alternée ; elle n’affecte que les types o, x, X, e, E, f, g et G comme suit :\n•o : fait précéder de 0 toute valeur non nulle\n•x ou X : fait précéder de 0x ou 0X la valeur afﬁchée\n•e, E ou f : le point décimal apparaît toujours\n•g ou G : même effet que pour e ou E, mais de plus les zéros de droite ne seront pas\nsupprimés\n●largeur (n désigne une constante entière positive écrite en notation décimale) :\nn : au minimum, n caractères seront afﬁchés, éventuellement complétés par des blancs à\ngauche\n0n : au minimum, n caractères seront afﬁchés, éventuellement complétés par des zéros\nà gauche\n* : la largeur effective est fournie dans la liste d’expressionsDelannoy Livre.book  Page 229  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n230 © Éditions Eyrolles●précision  (n désigne une constante entière positive écrite en notation décimale) :\n.n : la signiﬁcation dépend du caractère de conversion, de la manière suivante :\n•d, i, o, u, x ou X : au moins n chiffres seront imprimés. Si le nombre comporte moins de\nn chiffres, l’afﬁchage sera complété à gauche par des zéros. Notez que cela n’est pas\ncontradictoire avec l’indication de largeur, si celle-ci est supérieure à n. En effet, dans ce\ncas, le nombre pourra être précédé à la fois d’espaces et de zéros\n•e, E ou f : on obtiendra n chiffres après le point décimal, avec arrondi du dernier\n•g ou G : on obtiendra au maximum n chiffres signiﬁcatifs\n•c : sans effet\n•s : au maximum n caractères seront afﬁchés. Notez que cela n’est pas contradictoire\navec l’indication de largeur\n.0 : la signiﬁcation dépend du caractère de conversion, comme suit :\n•d, i, o, u, x ou X : choix de la valeur par défaut de la précision (voir ci-dessous)\n•e, E ou f : pas d’afﬁchage du point décimal\n* : la valeur effective de n est fournie dans la « liste d’expressions »\nrien : choix de la valeur par défaut, à savoir :\n•1 pour d, i, o, u, x ou X\n•6 pour e, E ou f\n•tous les chiffres signiﬁcatifs pour g ou G\n•tous les caractères pour s\n•sans effet pour c\n●h|l|L  :\nh : l’expression correspondante est d’un type short  int (signé ou non). En fait, il faut voir\nque, compte tenu des conversions implicites, printf  ne peut jamais recevoir de valeur d’un\ntel type. Tout au plus peut-elle recevoir un entier dont on (le programmeur) sait qu’il résulte dela conversion d’un \nshort . Dans certaines implémentations, l’emploi du modiﬁcateur h\nconduit alors à afﬁcher la valeur correspondante suivant un gabarit différent de celui réservé àun \nint (c’est souvent le cas pour le nombre de caractères hexadécimaux). Ce code ne peut,\nde toute façon, avoir une éventuelle signiﬁcation que pour les caractères de conversion : d, i,\no, u, x ou X\nl : Ce code précise que l’expression correspondante est de type  long  int. Il n’a de signiﬁca-\ntion que pour les caractères de conversion : d, i, o, u, x ou X\nL : Ce code précise que l’expression correspondante est de type long  double . Il n’a de signi-\nﬁcation que pour les caractères de conversion : e, E, f, g ou GDelannoy Livre.book  Page 230  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 231annexe Les principales fonctions de la bibliothèque standard\n●conversion : il s’agit d’un caractère qui précise à la fois le type de l’expression (nous\nl’avons noté ici en italique) et la façon de présenter sa valeur. Les types numériques indi-qués correspondent au cas où aucun modiﬁcateur n’est utilisé (voir ci-dessus) :\n•\nd : signed int , afﬁché en décimal\n•o : unsigned int , afﬁché en octal\n•u : unsigned int , afﬁché en décimal\n•x : unsigned int , afﬁché en hexadécimal (lettres minuscules)\n•X : signed int , afﬁché en hexadécimal (lettres majuscules)\n•f : double , afﬁché en notation décimale\n•e : double , afﬁché en notation exponentielle (avec la lettre e)\n•E : double , afﬁché en notation exponentielle (avec la lettre E)\n•g : double , afﬁché suivant le code f ou e (ce dernier étant utilisé lorsque l’exposant\nobtenu est soit supérieur à la précision désirée, soit inférieur à -4)\n•G : double , afﬁché suivant le code f ou E (ce dernier étant utilisé lorsque l’exposant\nobtenu est soit supérieur à la précision désirée, soit inférieur à -4)\n•c : char\n•s : pointeur sur une « chaîne »\n•% : afﬁche le caractère %, sans faire appel à aucune expression de la liste\n•n : place, à l’adresse désignée par l’expression de la liste (du type pointeur sur un entier),\nle nombre de caractères écrits jusqu’ici\n•p : pointeur, afﬁché sous une forme dépendant de l’implémentation\n1.3 Lecture formatée\nCes fonctions utilisent une chaîne de caractères nommée format , composée à la fois de\ncaractères quelconques et de codes de format dont la signiﬁcation est décrite en détail à la ﬁn\ndu présent paragraphe. On y trouvera également les règles générales auxquelles obéissent cesfonctions (arrêt du traitement d’un code de format, arrêt prématuré de la fonction).\nFSCANF int  fscanf  (FILE  * flux,  const  char  * format,  ...)\nLit des caractères sur le ﬂux spéciﬁé, les convertit en tenant compte du\nformat  indiqué et affecte les valeurs obtenues aux différentes variables de\nla liste d’arguments (...). Fournit le nombre de valeurs lues convenable-ment ou la valeur \nEOF si une erreur s’est produite ou si une ﬁn de ﬁchier a\nété rencontrée avant qu’une seule valeur ait pu être lue.Delannoy Livre.book  Page 231  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n232 © Éditions EyrollesSCANF int  scanf  (const  char  * format,  ...)\nLit des caractères sur l’entrée standard ( stdin ), les convertit en tenant\ncompte du format  indiqué et affecte les valeurs obtenues aux différentes\nvariables de la liste d’arguments (...). Fournit le nombre de valeurs lues\nconvenablement ou la valeur EOF si une erreur s’est produite ou si une ﬁn de\nﬁchier a été rencontrée avant qu’une seule valeur ait pu être lue.\nNotez que :\n    scanf (format, ...)\nest équivalent à :\n    fscanf (stdin, format, ...)\nSSCANF  int sscanf  (char  * ch, const  char  * format,  ...)\nLit des caractères dans la chaîne d’adresse ch, les convertit en tenant\ncompte du format  indiqué et affecte les valeurs obtenues aux différentes\nvariables de la liste d’arguments (...). Fournit le nombre de valeurs lues conve-\nnablement.\nRègles communes à ces fonctions\na) Il existe six caractères dits « séparateurs », à savoir : l’espace, la tabulation horizontale\n(\\t), la ﬁn de ligne ( \\n), le retour chariot ( \\r), la tabulation verticale ( \\v) et le changement\nde page (\\f). En pratique, on se limite généralement à l’espace et à la ﬁn de ligne.\nb) L ’information est recherchée dans un tampon, image d’une ligne. Il y a donc une certainedésynchronisation entre ce que l’on frappe au clavier (lorsque l’unité standard est connectée àce périphérique) et ce que lit la fonction . Lorsqu’il n’y a plus d’information disponible dans le\ntampon, il y a déclenchement de la lecture d’une nouvelle ligne. Pour décrire l’exploration dece tampon, il est plus simple de faire intervenir un indicateur de position que nous nommeronspointeur.\nc) La rencontre dans le format d’un caractère séparateur provoque l’avancement du pointeur\njusqu’à la rencontre d’un caractère qui ne soit pas un séparateur.\nd) La rencontre dans le format d’un caractère différent d’un séparateur (et de \n%) provoque la\nprise en compte du caractère courant (celui désigné par le pointeur). Si celui-ci correspond au\ncaractère du format, la fonction  poursuit son exploration du format. Dans le cas contraire, il y\na arrêt prématuré de la fonction .Delannoy Livre.book  Page 232  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 233annexe Les principales fonctions de la bibliothèque standard\ne) Lors du traitement d’un code de format, l’exploration s’arrête :\n•à la rencontre d’un caractère invalide par rapport à l’usage qu’on doit en faire (point\ndécimal pour un entier, caractère différent d’un chif\nfre ou d’un signe pour du numéri-\nque,...). Si la fonction n’est pas en mesure de fabriquer une valeur, il y a arrêt prématuré\nde l’ensemble de la lecture,\n•à la rencontre d’un séparateur,\n•lorsque la longueur (si elle a été spéciﬁée) a été atteinte.\nLes codes de format utilisés par ces fonctions\nChaque code de format a la structure suivante :\n% [*] [largeur] [h|l|L] conversion\ndans laquelle les crochets [ et ] signiﬁent que ce qu’ils renferment est facultatif. Les différen-\ntes « indications » se déﬁnissent comme suit :\n●* : la valeur lue n’est pas prise en compte ; elle n’est donc affectée à aucun élément de la\nliste\n●largeur : nombre maximal de caractères à prendre en compte (on peut en lire moins s’il ya rencontre d’un séparateur ou d’un caractère invalide)\n●h|l|L :\n•h : l’élément correspondant est l’adresse d’un short  int. Ce modiﬁcateur n’a de signi-\nﬁcation que pour les caractères de conversion : d, i, n, o, u, ou x\n•l : l’élément correspondant est l’adresse d’un élément de type :\n- long  int pour les caractères de conversion d, i, n,  o, u  ou x\n- double  pour les caractères de conversion e ou f\n•L : l’élément correspondant est l’adresse d’un élément de type long  double . Ce\nmodiﬁcateur n’a de signiﬁcation que pour les caractères de conversion e, f ou g.\n●conversion : ce caractère précise à la fois le type de l’élément correspondant (nous l’avons\nindiqué ici en italique) et la manière dont sa valeur sera exprimée. Les types numériquesindiqués correspondent au cas où aucun modiﬁcateur n’est utilisé (voir ci-dessus). Il nefaut pas perdre de vue que l’élément correspondant est toujours désigné par son adresse.Ainsi, par exemple, lorsque nous parlons de \nsigned int , il faut lire : « adresse d’un\nsigned int  » ou encore « pointeur sur un signed int  ».\n•d : signed  int exprimé en décimal\n•o : signed  int exprimé en octal\n•i : signed  int exprimé en décimal, en octal ou en hexadécimal\n•u : unsigned  int exprimé en décimal\n•x : int (signed  ou unsigned ) exprimé en hexadécimalDelannoy Livre.book  Page 233  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n234 © Éditions Eyrolles•f, e ou g : float  écrit indifféremment en notation décimale (éventuellement sans\npoint) ou exponentielle (avec e ou E)\n•c : suivant la longueur, correspond à :\n– un caractère  lorsqu’aucune longueur n’est spéciﬁée ou que celle-ci est égale à 1\n– une suite de caractères  lorsqu’une longueur différente de 1 est spéciﬁée. Dans ce cas,\nil ne faut pas perdre de vue que la fonction reçoit une adresse et que donc, dans ce cas,\nelle lira le nombre de caractères spéciﬁés et les rangera à partir de l’adresse indiquée.Il est bien sûr préférable que la place nécessaire ait été réservée. Notez bien qu’il nes’agit pas ici d’une véritable chaîne, puisqu’il n’y aura pas (à l’image de ce qui sepasse pour le code \n%s) d’introduction du caractère \\0 à la suite des caractères rangés\nen mémoire\n•s : chaîne de caractères . Il ne faut pas perdre de vue que la fonction reçoit une adresse et\nque donc, dans ce cas, elle lira tous les caractères jusqu’à la rencontre d’un séparateur(ou un nombre de caractères égal à la longueur éventuellement spéciﬁée) et elle les ran-gera à partir de l’adresse indiquée. Il est donc préférable que la place nécessaire ait étéréservée. Notez bien qu’ici un caractère \n\\0 est stocké à la suite des caractères rangés en\nmémoire et que sa place aura dû être prévue (si l’on lit n caractères, il faudra de la place\nsur n+1)\n•n : int, dans lequel sera placé le nombre de caractères lus correctement jusqu’ici.\nAucun caractère n’est donc lu par cette spéciﬁcation\n•p : pointeur exprimé en hexadécimal, sous la forme employée par printf  (elle dépend\nde l’implémentation)\n1.4 Entrées-sorties de caractères\nFGETC int  fgetc  (FILE  * flux)\nLit le caractère courant du flux  indiqué. Fournit :\n•le résultat de la conversion en int du caractère c (considéré comme\nunsigned  int) si l’on n’était pas en ﬁn de ﬁchier\n•la valeur EOF si la ﬁn de ﬁchier était atteinte\nNotez que fgetc  ne fournit de valeur négative qu’en cas de ﬁn de ﬁchier,\nquel que soit le code employé pour représenter les caractères et quel que soit\nl’attribut de signe attribué par défaut au type char .Delannoy Livre.book  Page 234  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 235annexe Les principales fonctions de la bibliothèque standard\nFGETS char  * fgets  (char  * ch, int n, FILE  * flux)\nLit au maximum n-1 caractères sur le flux  mentionné (en s’interrompant\néventuellement en cas de rencontre d’un caractère \\n), les range dans la\nchaîne d’adresse ch, puis complète le tout par un caractère \\0. Le caractère\n\\n, s’il a été lu, est lui aussi rangé dans la chaîne (donc juste avant le \\0).\nCette fonction fournit en retour :\n•la valeur NULL  si une éventuelle erreur a eu lieu ou si une ﬁn de ﬁchier a\nété rencontrée,\n•l’adresse ch, dans le cas contraire.\nFPUTC int  fputc  (int  c, FILE  * flux)\nÉcrit sur le flux  mentionné la valeur de c, après conversion en unsigned\nchar . Fournit la valeur du caractère écrit (qui peut donc, éventuellement,\nêtre différente de celle du caractère reçu) ou la valeur EOF en cas d’erreur.\nFPUTS int  fputs  (const  char  * ch, FILE  * flux)\nÉcrit la chaîne d’adresse ch sur le flux  mentionné. Fournit la valeur EOF\nen cas d’erreur et une valeur non négative dans le cas contraire.\nGETC int getc  (FILE  * flux)\nMacro effectuant la même chose que la fonction fgetc .\nGETCHAR int  getchar  (void)\nMacro effectuant la même chose que l’appel de la macro :\n    fgetc (stdin)\nGETS char  * gets  (char  * ch)\nLit des caractères sur l’entrée standard ( stdin ), en s’interrompant à la ren-\ncontre d’une ﬁn de ligne ( \\n) ou d’une ﬁn de ﬁchier, et les range dans la\nchaîne d’adresse ch, en remplaçant le \\n par \\0. Fournit :\n•la valeur NULL  si une erreur a eu lieu ou si une ﬁn de ﬁchier a été rencontrée,\nalors qu’aucun caractère n’a encore été lu,\n•l’adresse ch, dans le cas contraire.\nPUTC int putc  (int  c, FILE  * flux)\nMacro effectuant la même chose que la fonction fputc .Delannoy Livre.book  Page 235  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n236 © Éditions EyrollesPUTCHAR int  putchar  (int  c)\nMacro effectuant la même chose que l’appel de la macro putc , avec\nstdout comme adresse de ﬂux. Ainsi :\n    putchar (c)\nest équivalent à :\n    putc (c, stdout)\nPUTS int puts  (const  char  * ch)\nÉcrit sur l’unité standard de sortie ( stdout ) la chaîne d’adresse ch, suivie\nd’une ﬁn de ligne ( \\n). Fournit EOF en cas d’erreur et une valeur non négative\ndans le cas contraire.\nOn n’est pas sûr de pouvoir effectuer plusieurs appels consécutifs de ungetc , sans lectures\nintermédiaires.\n1.5 Entrées-sorties sans formatage\nFREAD size_t  fread  (void  * adr,  size_t  taille,  size_t  nblocs,  FILE\n* flux)\nLit, sur le flux spéciﬁé, au maximum nblocs  de taille  octets chacun\net les range à l’adresse adr. Fournit le nombre de blocs réellement lus.\nFWRITE size_t  fwrite  (const  void  * adr,  size_t  taille,  size_t\nnblocs,  FILE  * flux)\nÉcrit, sur le flux  spéciﬁé, nblocs  de taille  octets chacun, à partir de\nl’adresse adr. Fournit le nombre de blocs réellement écrits.\n1.6 Action sur le pointeur de ﬁchier\nFSEEK int  fseek  (FILE  * flux,  long  noct,  int org)\nPlace le pointeur du flux  indiqué à un endroit déﬁni comme étant situé à\nnoct octets de l’ « origine » spéciﬁée par org :\norg = SEEK_SET  correspond au début du ﬁchier\norg = SEEK_CUR  correspond à la position actuelle du pointeur\norg = SEEK_END  correspond à la ﬁn du ﬁchier\nDans le cas des ﬁchiers de texte (si l’implémentation les différencie des\nautres), les seules possibilités autorisées sont l’une des deux suivantes :\n•noct  = 0\n•noct  a la valeur fournie par ftell  (voir ci-dessous) et org = SEEK_SETDelannoy Livre.book  Page 236  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 237annexe Les principales fonctions de la bibliothèque standard\nFTELL long  ftell  (FILE  *flux)\nFournit la position courante du pointeur du flux  indiqué (exprimée en\noctets par rapport au début du ﬁchier) ou la valeur -1L en cas d’erreur.\n1.7 Gestion des erreurs\nFEOF int feof  (FILE  * flux)\nFournit une valeur non nulle si l’indicateur de ﬁn de ﬁchier du flux  indiqué\nest activé et la valeur 0 dans le cas contraire.\n2Tests de caractères et conversions majuscules-minuscules \n(ctype.h)\nISALNUM int  isalnum  (char  c) \nFournit la valeur 1 (vrai) si c est une lettre ou un chiffre et la valeur 0 (faux)\ndans le cas contraire.\nISALPHA int  isalpha  (char  c)\nFournit la valeur 1 (vrai) si c est une lettre et la valeur 0 (faux) dans le cas\ncontraire.\nISDIGIT int  isdigit  (char  c)\nFournit la valeur 1 (vrai) si c est un chiffre et la valeur 0 (faux) dans le cas\ncontraire.\nISLOWER int  islower  (char  c)\nFournit la valeur 1 (vrai) si c est une lettre minuscule et la valeur 0 (faux)\ndans le cas contraire.\nISSPACE int  isspace  (char c)\nFournit la valeur 1 (vrai) si c est un séparateur (espace, saut de page, ﬁn de\nligne, tabulation horizontale ou verticale) et la valeur 0 (faux) dans le cas\ncontraire.\nISUPPER int  isupper  (char  c)\nFournit la valeur 1 (vrai) si c est une lettre majuscule et la valeur 0 (faux)\ndans le cas contraire.Delannoy Livre.book  Page 237  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n238 © Éditions Eyrolles3Manipulation de chaînes (string.h)\nSTRCPY char  * strcpy  (char  * but,  const  char  * source)\nCopie la chaîne source  à l’adresse but (y compris le \\0 de ﬁn) et fournit\nen retour l’adresse de but.\nSTRNCPY char  * strncpy  (char  * but,  const  char  * source,  int  lgmax)\nCopie au maximum lgmax  caractères de la chaîne source  à l’adresse but\nen complétant éventuellement par des caractères \\0 si cette longueur maxi-\nmale n’est pas atteinte. Fournit en retour l’adresse de but.\nSTRCAT char  * strcat  (char  * but,  const  char  * source)\nRecopie la chaîne source  à la ﬁn de la chaîne but et fournit en retour\nl’adresse de but.\nSTRNCAT char  * strncat  (char  * but,  const  char  * source,  size_t  lgmax)\nRecopie au maximum lgmax  caractères de la chaîne source  à la ﬁn de la\nchaîne but et fournit en retour l’adresse de but.\nSTRCMP int  strcmp  (const  char  * chaine1,  const  char  * chaine2)\nCompare chaine1  et chaine2  et fournit :\n•une valeur négative si chaine1  < chaine2  ;\n•une valeur positive si chaine1  > chaine2  ;\n•zéro si chaine1  = chaine2 .\nSTRNCMP int  strncmp  (const  char  * chaine1,  const   char  * chaine2,\nsize_t  lgmax)\nTravaille comme strcmp , en limitant la comparaison à un maximum de\nlgmax  caractères.\nSTRCHR char  * strchr  (const  char  * chaine,  char  c)\nFournit un pointeur sur la première occurrence du caractère c dans la chaîne\nchaine , ou un pointeur nul si ce caractère n’y ﬁgure pas.\nSTRRCHR char  * strrchr  (const  char  * chaine,  char  c)\nFournit un pointeur sur la dernière occurrence du caractère c dans la chaîne\nchaine  ou un pointeur nul si ce caractère n’y ﬁgure pas.Delannoy Livre.book  Page 238  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 239annexe Les principales fonctions de la bibliothèque standard\nSTRSPN size_t  strspn  (const  char  * chaine1,  const   char  * chaine2)\nFournit la longueur du segment initial de chaine1  formé entièrement de\ncaractères appartenant à chaine2 .\nSTRCSPN size_t  strcspn  (const  char  * chaine1,  const  char  * chaine2)\nFournit la longueur du segment initial de chaine1 formé entièrement de\ncaractères n’appartenant pas à chaine2 .\nSTRSTR char  * strstr  (const  char  * chaine1,  const  char  * chaine2)\nFournit un pointeur sur la première occurrence dans chaine1  de chaine2\nou un pointeur nul si chaine2  ne ﬁgure pas dans chaine1 .\nSTRLEN size_t  strlen  (const  char  * chaine)\nFournit la longueur de chaine .\nMEMCPY void  * memcpy  (void  * but,  const  void  * source,  size_t  lg)\nCopie lg octets depuis l’adresse source  à l’adresse but qu’elle fournit\ncomme valeur de retour (il ne doit pas y avoir de recoupement  entre source\net but).\nMEMMOVE void  * memmove  (void  * but,  const  void  * source,  size_t  lg)\nCopie lg octets depuis l’adresse source à l’adresse but qu’elle fournit\ncomme valeur de retour (il peut y avoir recoupement entre source  et but).\n4 Fonctions mathématiques (math.h)\nSIN double  sin (double  x)\nCOS double  cos (double  x)\nTAN double  tan (double  x)\nASIN double  asin  (double  x)\nACOS double  acos  (double  x)\nATAN double  atan  (double  x)\nATAN2 double  atan2  (double  y, double  x)\nFournit la valeur de arctan( y/x)Delannoy Livre.book  Page 239  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n240 © Éditions EyrollesSINH double  sinh  (double  x)\nFournit la valeur de sh( x)\nCOSH double  cosh  (double  x)\nFournit la valeur de ch( x)\nTANH double  tanh  (double  x)\nFournit la valeur de th( x)\nEXP double  exp  (double  x)\nLOG double  log (double  x)\nFournit la valeur du logarithme népérien de x : Ln( x) (ou Log( x))\nLOG10 double  log10  (double  x)\nFournit la valeur du logarithme à base 10 de x : log( x)\nPOW double  pow  (double  x, double  y)\nFournit la valeur de xy\nSQRT double  sqrt  (double  x)\nCEIL double  ceil  (double  x)\nFournit (sous forme d’un double ) le plus petit entier qui ne soit pas inférieur\nà x.\nFLOOR double  floor  (double  x)\nFournit (sous forme d’un double ) le plus grand entier qui ne soit pas\nsupérieur à x.\nFABS double  fabs  (double  x)\nFournit la valeur absolue de x.\nLa norme C99 introduit d’autres fonctions mathématiques (puissance réelle, logarithme à base 2,\nfonction log(1+x) , fonction « gamma »…) et elle généralise aux types complexes, toutes les\nfonctions mathématiques à argument flottant.\nDe plus, elle introduit des fonctions mathématiques « génériques » ; il est alors possible d’utiliser\nle mê me nom de fonction, quelle que soit la nature de ses arguments ( float , double , \nlongdouble , float complex , double complex  ou long double complex ).Delannoy Livre.book  Page 240  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 241annexe Les principales fonctions de la bibliothèque standard\n5Utilitaires (stdlib.h)\nATOF double  atof  (const  char  * chaine)\nFournit le résultat de la conversion en double  du contenu de chaine .\nCette fonction ignore les éventuels séparateurs de début et, à l’image de ce\nque fait le code format %f, utilise les caractères suivants pour fabriquer une\nvaleur numérique. Le premier caractère invalide arrête l’exploration.\nATOI int  atoi  (const  char  * chaine)\nFournit le résultat de la conversion en int du contenu de chaine . Cette\nfonction ignore les éventuels séparateurs de début et, à l’image de ce que faitle code format \n%d, utilise les caractères suivants pour fabriquer une valeur\nnumérique. Le premier caractère invalide arrête l’exploration.\nATOL long  atol  (const  char  * chaine)\nFournit le résultat de la conversion en long  du contenu de chaine . Cette\nfonction ignore les éventuels séparateurs de début et, à l’image de ce que faitle code format \n%ld, utilise les caractères suivants pour fabriquer une valeur\nnumérique. Le premier caractère invalide arrête l’exploration.\nRAND int rand  (void)\nFournit un nombre entier aléatoire (en fait pseudo-aléatoire), compris dansl’intervalle [0, \nRAND_MAX ]. La valeur prédéﬁnie RAND_MAX  est au moins\négale à 32767 .\nSRAND void  srand  (unsigned  int  graine)\nModiﬁe la « graine » utilisée par le « générateur de nombres pseudo-aléatoires »de \nrand . Par défaut, cette graine a la valeur 1.\nCALLOC void  * calloc  (size_t  nb_blocs,  size_t  taille)\nAlloue l’emplacement nécessaire à nb_blocs  consécutifs de chacun taille\noctets, initialise chaque octet à zéro et fournit l’adresse correspondante lors-que l’allocation a réussi ou un pointeur nul dans le cas contraire.\nMALLOC void  * malloc  (size_t  taille)\nAlloue un emplacement de taille  octets, sans l’initialiser, et fournit l’adresse\ncorrespondante lorsque l’allocation a réussi ou un pointeur nul dans le cascontraire.Delannoy Livre.book  Page 241  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n242 © Éditions EyrollesREALLOC void  realloc  (void  * adr,  size_t  taille)\nModiﬁe la taille d’une zone d’adresse adr préalablement allouée par malloc\nou calloc . Ici, taille  représente la nouvelle taille souhaitée, en octets.\nCette fonction fournit l’adresse de la nouvelle zone ou un pointeur nul dans\nle cas où la nouvelle allocation a échoué (dans ce dernier cas, le contenu dela zone reste inchangé). Lorsque la nouvelle taille est supérieure à l’ancienne,le contenu de l’ancienne zone est conservé (il a pu éventuellement être alorsrecopié). Dans le cas où la nouvelle taille est inférieure à l’ancienne, seul ledébut de l’ancienne zone (c’est-à-dire \ntaille  octets) est conservé.\nFREE void  free  (void  * adr)\nLibère la mémoire d’adresse adr. Ce pointeur doit obligatoirement désigner\nune zone préalablement allouée par malloc , calloc  ou realloc . Si adr\nest nul, cette fonction ne fait rien.\nEXIT void  exit  (int  etat)\nTermine l’exécution du programme. Cette fonction ferme les ﬁchiers ouvertsen vidant les tampons et rend le contrôle au système, en lui fournissant lavaleur \netat . La manière dont cette valeur est effectivement interprétée\ndépend de l’implémentation, toutefois la valeur 0 est considérée comme une\nﬁn normale.\nABS int abs (int  n)\nFournit la valeur absolue de n.\nLABS long  abs  (long  n)\nFournit la valeur absolue de n.Delannoy Livre.book  Page 242  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 243Correction des exercices \nCHAPITRE 3\nExercice 3.1 :\na) long 12\nb) ﬂoat 11,75 c) long 4d) int 0\ne) int 1f) int 1g) long 5h) int 1\ni) int 0j) ﬂoat 1,75k) ﬂoat 8,75\nExercice 3.2 :\nz = a + b ;Delannoy Livre.book  Page 243  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n244 © Éditions EyrollesExercice 3.3 :\nn ? (n>0 ? 1 : -1) : 0)        ou       n>0 ? 1 : (n ? -1 : 0)\nExercice 3.4 :\nA : n = 10  p = 10  q = 10  r = 1\nB : n = 15  p = 10  q = 5C : n = 15  p = 11  q = 10D : n = 16  p = 11  q = 15\nCHAPITRE 4\nExercice 4.1 :\nA : 543 34.567799B : 543 34.567799C : 543 34.567799D :     34.568  3.457e+01E : 543F :     34.56780\nExercice 4.2 :\na) n=12, p=45\nb) n=1234, p=56c) n=1234, p=56d) n=1, p=45e) n=4567, p=89\nCHAPITRE 5\nExercice 5.1 :\na)\n#include <stdio.h>\nmain(){  int i, n, som ;   som = 0 ;    i = 0 ;         /* ne pas oublier cette \"initialisation\" */Delannoy Livre.book  Page 244  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 245Correction des exercices\n   while (i<4)\n      { printf (\"donnez un entier \") ;        scanf (\"%d\", &n) ;        som += n ;        i++ ;               /* ni cette \"incrémentation\" */      }   printf (\"Somme : %d\\n\", som) ;}    \nb)\n#include <stdio.h>main(){  int i, n, som ;   som = 0 ;    i = 0 ;          /* ne pas oublier cette \"initialisation\" */   do      { printf (\"donnez un entier \") ;        scanf (\"%d\", &n) ;        som += n ;        i++ ;             /* ni cette \"incrémentation\" */      }   while (i<4) ;          /* attention, ici, toujours <4 */   printf (\"Somme : %d\\n\", som) ;}    \nExercice 5.2 :\n#include <stdio.h>main(){  float note,       /* note courante */         som,        /* somme des notes */         moy ;       /* moyenne des notes */   int num ;         /* numéro note courante */\n   som=0 ; num=0 ;\n   while ( printf(\"note %d : \",num+1),            scanf (\"%f\", &note), note>=0 )      {  num++ ;         som += note ;      }Delannoy Livre.book  Page 245  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n246 © Éditions Eyrolles   if (num>0)\n      {  moy = som/num ;         printf (\"moyenne de ces %d notes : %5.2f\", num, moy) ;      }    else printf (\"--- aucune note fournie ---\") ;}\nExercice 5.3 :\n#include <stdio.h>main(){  int nbl ;      /* nombre de lignes */   int i, j ;   printf (\"combien de lignes : \") ;   scanf (\"%d\", &nbl) ;   for (i=1 ; i<=nbl ; i++)     { for (j=1 ; j<=i ; j++)          printf (\"*\") ;       printf (\"\\n\") ;     }}\nExercice 5.4 :\n#include <stdio.h>#include <math.h>main(){   int n,      /* nombre entier à examiner */       d ;     /* diviseur courant */   do      { printf (\"donnez un entier supérieur à 2 : \") ;        scanf  (\"%d\", &n) ;      }   while (n<=2) ;   d=2 ;   while ( (n%d) && (d<=sqrt(n)) ) d++ ;   if (n%d) printf (\"%d est premier\", n) ;       else printf (\"%d n’est pas premier\", n) ;}Delannoy Livre.book  Page 246  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 247Correction des exercices\nExercice 5.5 :\nmain()\n{   int u1, u2, u3 ;          /* pour \"parcourir\" la suite */\n   int n ;                   /* rang du terme demandé */\n   int i ;                   /* compteur */\n   do\n     { printf (\"rang du terme demandé (au moins 3) ? \") ;       scanf (\"%d\", &n) ;\n     }\n   while (n<3) ;\n   u2 = u1 = 1 ;     /* les deux premiers termes */\n   i = 2 ;\n   while (i++ < n)   /* attention, l’algorithme ne fonctionne */      { u3 = u1 + u2 ;  /*           que pour n > 2              */\n        u1 = u2 ;\n        u2 = u3 ;      }\n   printf (\"Valeur du terme de rang %d : %d\", n, u3) ;\n}\nExercice 5.6\n#include <stdio.h>#define NMAX 10                 /* nombre de valeurs */\nmain()\n{   int i, j ;         /* affichage ligne en-tête */    printf (\"      I\") ;\n    for (j=1 ; j<=NMAX ; j++) printf (\"%4d\", j) ;\n    printf (\"\\n\") ;    printf (\"-------\") ;\n    for (j=1 ; j<=NMAX ; j++) printf (\"----\") ;\n    printf (\"\\n\") ; Delannoy Livre.book  Page 247  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n248 © Éditions Eyrolles         /* affichage des différentes lignes */\n    for (i=1 ; i<=NMAX ; i++)       { printf (\"%4d  I\", i) ;         for (j=1 ; j<=NMAX ; j++)            printf (\"%4d\", i*j) ;         printf (\"\\n\") ;       }\nCHAPITRE 6\nExercice 6.1\n#include <stdio.h>void f1 (void){  printf (\"bonjour\\n\") ;}void f2 (int n){  int i ;   for (i=0 ; i<n ; i++)       printf (\"bonjour\\n\") ;}int f3 (int n){  int i ;   for (i=0 ; i<n ; i++)       printf (\"bonjour\\n\") ;   return 0 ;}main(){  void f1 (void) ;   void f2 (int) ;   int f3 (int) ;   f1 () ;   f2 (3) ;   f3 (3) ;}\nExercice 6.2\nIl afﬁche : 5  3Delannoy Livre.book  Page 248  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 249Correction des exercices\nExercice 6.3\n#include <stdio.h>\nvoid compte(void){    static long n=0 ;   static long limit=1 ;   n++ ;   if (n>=limit)      { printf (\"** appel %ld fois **\\n\", limit) ;        limit *= 10 ;      }}main(){     void compte(void) ;   long nmax=100000 ;   long i ;   for (i=1 ; i<=nmax ; i++) compte() ;}\nExercice 6.4\n#include <stdio.h>int acker (int m, int n){  if ( (m<0) || (n<0) )        return(0) ;   else if (m==0)        return (n+1) ;   else if  (n==0)        return ( acker(m-1,1) ) ;\n   else        return acker ( m-1, acker(m,n-1) ) ;}main(){  int acker (int, int) ;   int m, n ;   printf (\"donnez m et n : \") ;   scanf (\"%d %d\", &m, &n) ;   printf (\"acker ( %d,%d) = %d\", m, n, acker(m,n) ) ;}Delannoy Livre.book  Page 249  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n250 © Éditions EyrollesCHAPITRE 7\nExercice 7.1\na)\n#include <stdio.h>\n#define NVAL 10                       /* nombre de valeurs du tableau */main(){   int i, min, max ;    int t[NVAL] ;    printf (\"donnez %d valeurs\\n\", NVAL) ;    for (i=0 ; i<NVAL ; i++) scanf (\"%d\", &t[i]) ;       max = min = t[0] ;    for (i=1 ; i<NVAL ; i++)      { if (t[i] > max) max = t[i] ;  /* ou max = t[i]>max ? t[i] : max */        if (t[i] < min) min = t[i] ;  /* ou min = t[i]<min ? t[i] : min */      }    printf (\"valeur max : %d\\n\", max) ;    printf (\"valeur min : %d\\n\", min) ;}\nb)\n#include <stdio.h>#define NVAL 10               /* nombre de valeurs du tableau */main(){   int i, min, max ;    int t[NVAL] ;    printf (\"donnez %d valeurs\\n\", NVAL) ;    for (i=0 ; i<NVAL ; i++) scanf (\"%d\", t+i) ; \n                              /* et non  *(t+i) !! */\n    max = min = *t ;    for (i=1 ; i<NVAL ; i++)      { if (*(t+i) > max) max = *(t+i) ;            if (*(t+i) < min) min = *(t+i) ;         }    printf (\"valeur max : %d\\n\", max) ;    printf (\"valeur min : %d\\n\", min) ;}Delannoy Livre.book  Page 250  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 251Correction des exercices\nExercice 7.2\nvoid maxmin (int t[], int n, int * admax, int * admin)\n{  int i, max, min ;   max = t[0] ;   min = t[0] ;   for (i=1 ; i<n ; i++)      {  if (t[i] > max) max = t[i] ;         if (t[i] < min) min = t[i] ;      }   *admax = max ;   *admin = min ;}    #include <stdio.h>main(){  void maxmin (int [], int, int *, int *) ;   int t[8] = { 2, 5, 7, 2, 9, 3, 9, 4} ;   int max, min ;   maxmin (t, 8, &max, &min) ;   printf (\"valeur maxi : %d\\n\", max) ;   printf (\"valeur mini : %d\\n\", min) ;}\nExercice 7.3\nvoid tri (unsigned char c[] , int nc){  int i,j ;   char ct ;   for (i=0 ; i<nc-1 ; i++)      for (j=i+1 ; j<nc ; j++)         if ( c[i]>c[j] )            { ct = c[i] ;              c[i] = c[j] ;              c[j] = ct ;            }}Delannoy Livre.book  Page 251  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n252 © Éditions EyrollesExercice 7.4\nvoid sommat (double * a, double * b, double * c, int n, int p)\n{  int i ;   for (i=0 ; i<n*p ; i++)     *(c+i) = *(a+i) + *(b+i) ;}\nCHAPITRE 8\nExercice 8.1\n#include <stdio.h>#include <string.h>#define CAR 'e'#define LGMAX 132\nmain()\n{   char texte[LGMAX+1] ;    char * adr ;    int ncar ;    printf (\"donnez un texte terminé par return\\n\") ;    gets (texte) ;    ncar = 0 ;    adr = texte ;    while ( adr=strchr(adr,CAR) )       { ncar++ ;         adr++ ;       }   \n printf (\"votre texte comporte %d fois le caractère %c\", ncar, CAR) ;\n}\nExercice 8.2\n#include <stdio.h>#include <string.h>#define CAR 'e'#define LGMAX 132Delannoy Livre.book  Page 252  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 253Correction des exercices\nmain()\n{   char texte[LGMAX+1] ;    char * adr ;    printf (\"donnez un texte terminé par return\\n\") ;    gets (texte) ;    adr = texte ;    while ( adr=strchr(adr,CAR) )  strcpy (adr, adr+1) ;    printf (\"voici votre texte privé des caractères %c\\n\", CAR) ;    puts (texte) ;}\nExercice 8.3\n#include <stdio.h>#include <string.h>#define NBCAR 30main(){  char nom[NBCAR+1] ;   int i ;   printf (\"donnez un nom d’au plus %d caractères : \", NBCAR) ;   gets(nom) ;   for ( i=strlen(nom) ; i>=0 ; i--)      putchar (nom[i]) ;}\nExercice 8.4\n#include <stdio.h>\n#include <string.h>#define LGMAX 26main(){  char verbe [LGMAX+1] ;  char * adfin ;  char * term[6] = {\"e\",  \"es\", \"e\",  \"ons\",  \"ez\",   \"ent\" } ;  char * deb[6]  = {\"je\", \"tu\", \"il\", \"nous\", \"vous\", \"ils\"} ;  int i ;  do    { printf (\"donnez un verbe du premier groupe : \") ;      gets (verbe) ;      adfin = verbe + strlen(verbe) - 2 ;    }  while ( strcmp (adfin, \"er\") ) ;Delannoy Livre.book  Page 253  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n254 © Éditions Eyrolles  printf (\"\\nIndicatif présent :\\n\") ;\n  for (i=0 ; i<6 ; i++)    { strcpy (adfin, term[i]) ;      printf (\"%s %s\\n\", deb[i], verbe) ;    }}\nCHAPITRE 9\nExercice 9.1\n#include <stdio.h>#define NPOINTS 5main(){  struct point { int num ;                  float x ;                  float y ;                } ;   struct point courbe[NPOINTS] ;   int i ;\n   for (i=0 ; i<NPOINTS ; i++)\n      {  printf (\"numéro : \") ; scanf (\"%d\", &courbe[i].num) ;         printf (\"x      : \") ; scanf (\"%f\", &courbe[i].x) ;         printf (\"y      : \") ; scanf (\"%f\", &courbe[i].y) ;      }\n   printf (\" **** structure fournie ****\\n\") ;\n   for (i=0 ; i<NPOINTS ; i++)        printf (\"numéro : %d   x : %f   y : %f\\n\",                  courbe[i].num, courbe[i].x, courbe[i].y) ;}Delannoy Livre.book  Page 254  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 255Correction des exercices\nExercice 9.2\n#include <stdio.h>\n#define NPOINTS 5struct point { int num ;               float x ;               float y ;             } ;void lit     (struct point  []) ;  /* ou void lit (struct point *) */void affiche (struct point  []) ;  /* ou void lit (struct point *) */\nmain()\n{   struct point courbe[NPOINTS] ;   lit (courbe) ;   affiche (courbe) ;}void lit (struct point courbe []) /* ou void lit (struct point * courbe) */{   int i ;   for (i=0 ; i<NPOINTS ; i++)      {  printf (\"numéro : \") ; scanf (\"%d\", &courbe[i].num) ;         printf (\"x      : \") ; scanf (\"%f\", &courbe[i].x) ;         printf (\"y      : \") ; scanf (\"%f\", &courbe[i].y) ;      }}void affiche (struct point courbe []) /* ou void affiche \n                                      (struct point * courbe) */\n{   int i ;   printf (\" **** structure fournie ****\\n\") ;   for (i=0 ; i<NPOINTS ; i++)      printf (\"%d %f %f\\n\", courbe[i].num, courbe[i].x, courbe[i].y) ;}Delannoy Livre.book  Page 255  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n256 © Éditions EyrollesCHAPITRE 10\nExercice 10.1\n#include <stdio.h>\n#define LGMAX 81main(){  char nomfich[21] ;     /* nom de fichier */   FILE * entree ;   int num = 1 ;          /* numéro de ligne */   char ligne [LGMAX] ;   /* tampon d’une ligne */\n   printf (\"donnez le nom du fichier à lister : \");\n   scanf (\"%20s\", nomfich) ;   entree = fopen (nomfich, \"r\") ;   printf (\"  **** liste du fichier %s ****\\n\", nomfich) ;   while ( fgets (ligne, LGMAX, entree) )       {  printf (\"%5d \", num++) ;\n          printf (\"%s\", ligne) ;       }\n}\nCertaines implémentations demanderont le mode « rt ».\nExercice 10.2\n#include <stdio.h>#define LGNOM    20#define LGPRENOM 15#define LGTEL    11main(){   char nomfich[21] ;     /* nom de fichier */   FILE * sortie ;   struct { char nom [LGNOM+1] ;\n            char prenom [LGPRENOM+1] ;            int  age ;\n            char tel [LGTEL+1] ;          } bloc ;Delannoy Livre.book  Page 256  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 257Correction des exercices\n   printf (\"donnez le nom du fichier à créer : \");\n   gets (nomfich) ;   sortie = fopen (nomfich, \"w\") ;   printf (\" --- pour finir la saisie, donnez un nom ‘vide' ---\\n\") ;   while ( printf (\"nom       : \"), gets (bloc.nom), strlen(bloc.nom) )\n        {  printf (\"prénom    : \") ;           gets (bloc.prenom) ;           printf (\"age       : \") ;           scanf (\"%d\", &bloc.age) ; getchar() ;           printf (\"téléphone : \") ;           gets (bloc.tel) ;           fwrite (&bloc, sizeof(bloc), 1, sortie) ;         }   fclose (sortie) ;}\nExercice 10.3\n#include <stdio.h>#include <string.h>#define LGNOM    20#define LGPRENOM 15#define LGTEL    11main(){   char nomfich[21] ;         /* nom de fichier */   FILE * entree ;   struct { char nom [LGNOM+1] ;            char prenom [LGPRENOM+1] ;            int  age ;            char tel [LGTEL+1] ;          } bloc ;   char nomcher [LGNOM+1] ;   /* nom recherché */   int trouve ;               /* indicateur nom trouvé */\n   printf (\"donnez le nom du fichier à consulter : \");\n   gets (nomfich) ;Delannoy Livre.book  Page 257  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n258 © Éditions Eyrolles   entree = fopen (nomfich, \"r\") ;\n   printf (\" quel nom recherchez-vous : \") ;   gets (nomcher) ;   trouve = 0 ;   do      { fread (&bloc, sizeof(bloc), 1, entree) ;        if ( strcmp (nomcher, bloc.nom)==0 ) trouve = 1 ;      }   while ( (!trouve) && (!feof(entree)) ) ;   if (trouve)       { printf (\"prénom    : %s\\n\", bloc.prenom) ;         printf (\"âge       : %d\\n\", bloc.age) ;         printf (\"téléphone : %s\\n\", bloc.tel) ;       }    else printf (\"-- ce nom ne figure pas au fichier --\") ;}\nExercice 10.4\n#include <stdio.h>#define LGNOM    20#define LGPRENOM 15#define LGTEL    11main(){   char nomfich[21] ;         /* nom de fichier */   FILE * entree ;\n   struct { char nom [LGNOM+1] ;\n            char prenom [LGPRENOM+1] ;            int  age ;            char tel [LGTEL+1] ;          } bloc ;   int num ;                  /* numéro de bloc cherché */   long taille,               /* taille du fichier en octets */        pos ;                 /* position dans le fichier */\n   printf (\"donnez le nom du fichier à consulter : \");\n   gets (nomfich) ;Delannoy Livre.book  Page 258  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 259Correction des exercices\n   entree = fopen (nomfich, \"r\") ;\n   fseek (entree, 0, SEEK_END) ; taille = ftell(entree) ;\n   printf (\" quel numéro recherchez-vous : \") ;\n   scanf (\"%d\",&num) ;\n   pos = num * sizeof(bloc) ;\n   if ( num<0 || pos >= taille )          printf (\"-- ce numéro ne figure pas dans le fichier \") ;      else        { fseek (entree, pos, 0 ) ;          fread (&bloc, sizeof(bloc), 1, entree) ;          printf (\"nom       : %s\\n\", bloc.nom) ;          printf (\"prénom    : %s\\n\", bloc.prenom) ;          printf (\"age       : %d\\n\", bloc.age) ;          printf (\"téléphone : %s\\n\", bloc.tel) ;        }}\nCHAPITRE 11\nExercice 11.1\n#include <stdio.h>#include <stdlib.h>typedef struct element { int num ;                         float x ;                         float y ;                         struct element * suivant ;                       } s_point ;void creation (s_point * * adeb) ;void liste    (s_point *  debut) ;main(){   s_point *  debut ;   creation (&debut) ;   liste(debut) ;}Delannoy Livre.book  Page 259  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C\n260 © Éditions Eyrollesvoid creation (s_point * * adeb)\n{   int num ;   float x, y ;   s_point * courant ;   * adeb = NULL ;   while ( printf(\"numéro x y : \"),           scanf (\"%d %f %f\", &num, &x, &y), num)       { courant = (s_point *) malloc (sizeof(s_point)) ;         courant -> num     = num ;         courant -> x       = x ;         courant -> y       = y ;         courant -> suivant = * adeb ;         * adeb = courant ;       }}\nvoid liste (s_point * debut)\n{   printf (\"  **** liste de la structure ****\\n\") ;   while (debut)\n      { printf (\"%d %f %f\\n\", (debut)->num, (debut)->x, (debut)->y) ;\n        debut = (debut)->suivant ;      }}Delannoy Livre.book  Page 260  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 261Index\nSymbols\n! (opérateur) 35\n!= (opérateur) 33- (opérateur) 27-- (opérateur) 39#deﬁne 9, 23, 205, 206#elif 213#else 211#endif 211#ifdef 211 #ifndef 211#include 9, 205% (opérateur) 27%= (opérateur) 42& (opérateur) 127&& (opérateur) 35* (opérateur) 27, 127*= (opérateur) 42+ (opérateur) 27++ (opérateur) 39+= (opérateur) 42/ (opérateur) 27/= (opérateur) 42< (opérateur) 33<= (opérateur) 33-= (opérateur) 42== (opérateur) 33-> (opérateur) 176> (opérateur) 33>= (opérateur) 33|| (opérateur) 35A\naccès\ndirect 181, 185séquentiel 181\nacos (math.h) 239affectation\nconversions forcées 42de pointeurs 135de tableaux 123opérateurs 37, 41\najustement de type (conversion) 29alignement, contraintes 135argument\nde main 161effectif 97fonction 142muet 97variable en nombre 116\narrangement mémoire (des tableaux) 124arrêt prématuré (de scanf) 60asin (math.h) 239associativité (des opérateurs) 28atan (math.h) 239atan2 (math.h) 239atof (string.h ou stdlib.h) 240atoi (string.h ou stdlib.h) 158, 241atol (string.h ou stdlib.h) 241attribut de signe 217, 218automatique\nclasse 115, 195variable 108Delannoy Livre.book  Page 261  Mercredi, 6. mai 2009  4:27 16\nabs (math.h) 242\nProgrammer en langage C Index\n262 © Éditions EyrollesB\nbibliothèque standard 227\nbit à bit (opérateurs) 220bloc 5, 9, 68boucle 67\ninﬁnie 79\nbreak 73, 86\nC\ncadrage de l’afﬁchage 54calloc (stdlib.h) 199, 241caractère\nde contrôle 6de ﬁn\nde chaîne 146de ligne 189\nimprimable 22notation 22\nhexadécimale 23octale 23spéciale 22\nreprésentable 21type 18, 21\ncast (opérateur) 43ceil (math.h) 240chaîne\ncaractère de ﬁn 146comparaison 156concaténation 154constante 146conversions 158copie 157de caractères 145entrées-sorties 149fonctions 153\ngets 149puts 149\nrecherche dans 158représentation 146type 145\nchamp\nd’une structure 165de bits 222choix 8, 67\nclasse\nautomatique 108, 115d’allocation (des variables) 107, 113registre 114statique 107, 109, 115\ncodage (d’une information) 18code 18code de format 6\nde printf 149de scanf 57, 149\ncommentaires 14comparaison\nde chaînes 156de pointeurs 134\ncompilation\nconditionnelle 205, 211d’un programme 15séparée 110\nconst 24constante\nchaîne 146déclaration 131déclaration de 24entière 19ﬂottante 20\ncontinue (instruction) 87contrainte d’alignement 135conversion\ncast 43chaînes 158d’ajustement de type 29dans les affectations 38de pointeurs 135des arguments d’une fonction 32forcée par une affectation 42implicite 29promotions numériques 30systématique 30\ncopie, chaînes 157cos (math.h) 239cosh (math.h) 240ctype.h 237Delannoy Livre.book  Page 262  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 263 Index Programmer en langage C\nD\ndébordement d’indice 123\ndécalage (opérateurs) 220, 221déclaration 5\nd’une fonction 101de constante 24, 131de ﬁchier 182de tableaux 122, 124instruction 10pointeur 127, 129static 112structure 166typedef 169\ndécrémentation (opérateurs) 39default 74déﬁnition\nde macros 208de symboles 206\ndimension (d’un tableau) 123, 124directives 9, 205do... while (instruction) 77, 79domaine (d’un type) 20donnée\nautomatique 195dynamique 195statique 195\ndouble (type) 20\nE\nédition\nd’un programme 15de liens 16, 112\neffet de bord 210en-tête 5, 96, 100\nﬁchier 16\nentier\nattribut de signe 217codage 216type 18, 216entrées-sorties 51\nde chaînes 149\nénumération 165, 177\nespace de validité 106exp (math.h) 240expression mixte 29\nF\nfabs (math.h) 240fclose (stdio.h) 228feof (stdio.h) 184fgetc (stdio.h) 190, 234fgets (stdio.h) 152, 190, 235ﬁchier 181\naccès\ndirect 181, 185séquentiel 181\ncréation séquentielle 182de type texte 189déclaration 182écriture 183en-tête 9, 16, 103entrées-sorties formatées 189fermeture 183, 184lecture 184liste séquentielle 184ouverture 183, 184, 191prédéﬁni 192source 15, 112stdaux 192stderr 192stdin 192stdout 192stdprt 192\nFILE 182ﬁn de ligne 6, 189ﬂoat (type) 20ﬂoor (math.h) 240ﬂottant (type) 18, 20ﬂux 183Delannoy Livre.book  Page 263  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C Index\n264 © Éditions Eyrollesfonction\narguments 97, 104\neffectifs 97\nmuets 97\ndéclaration 101, 102déﬁnition 95en C 94en-tête 96, 100main 5pointeur sur 141prototype 33récursive 110return 98structure en argument 174transmission par adresse 130utilisation 95valeur de retour 97, 99\nfopen (stdio.h) 183for (instruction) 7, 84formalisme\npointeur 133tableau 133\nformat 6, 7\nlibre 13\nfprintf (stdio.h) 190, 228fputc (stdio.h) 190, 235fputs (stdio.h) 190, 235fread (stdio.h) 184, 236free (stdlib.h) 198, 242fscanf (stdio.h) 190, 231fseek (stdio.h) 186, 236ftell (stdio.h) 237fwrite (stdio.h) 183, 236\nG\ngabarit\nd’afﬁchage 52de lecture 58\ngestion dynamique 195getc (stdio.h) 235getchar (stdio.h) 235gets (stdio.h) 149, 235globale (variable) 107, 112go to (instruction) 88\nI\nidentiﬁcateur 12if (instruction) 69imbrication\nde structures 170des if 70\nincrémentation\nde pointeurs 129opérateurs 39\nindice 121, 123initialisation\ndes structures 168des tableaux 125\nde caractères 147de pointeurs 148\ndes variables 23, 107, 113, 115\ninstruction\nbloc 9, 68break 86continue 87de choix 67de contrôle 67de structuration 9do... while 77, 79expression 26for 7, 84go to 88if 8, 69les différentes sortes 9return 98simple 9switch 72, 76while 80, 81\nint (type) 19isalnum (ctype.h) 237isalpha (ctype.h) 237isupper (ctype.h) 237Delannoy Livre.book  Page 264  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 265 Index Programmer en langage C\nL\nlabs (stdlib.h) 242\nlecture ﬁable au clavier 151, 192liste chaînée (création) 200locale (variable) 107log (math.h) 240log10 (math.h) 240long double (type) 20long int (type) 19lvalue 38, 42, 123, 124, 129, 132\nM\nmacro 16, 208main (fonction) 5malloc (stdlib.h) 196, 241manipulation de bits 220math.h 239modèle de structure 166module 94\nobjet 15\nmot-clé 12\nN\nnom de tableau 132notation\nhexadécimale (caractères) 23octale (caractères) 23\nNULL (stdio.h) 135\nO\nopérateur\n& 127* 127-> 176addition 27affectation 37, 41arithmétique 27associativité 28binaire 27bit à bit 220cast 43conditionnel 44\nde comparaison 33de décalage 220, 221décrémentation 39division 27incrémentation 39logique 35manipulation de bits 220modulo 27multiplication 27opposé 27post-décrémentation 40post-incrémentation 39pré-décrémentation 40pré-incrémentation 39priorités 28relationnel 33séquentiel 45sizeof 47soustraction 27\nopération sur les pointeurs 134\nP\nparamétrage d’appel de fonction 141parenthèses 28pile 195pointeur 121, 127\naffectation 135argument 130comparaison 134conversions 135déclaration 127, 129incrémentation 129nul 135opérations 134soustraction 135sur une fonction 141\npointeur nul 135portée 173\ndes variables 106, 108, 113\npost-décrémentation (opérateurs) 40post-incrémentation (opérateurs) 39pow (math.h) 240Delannoy Livre.book  Page 265  Mercredi, 6. mai 2009  4:27 16\nProgrammer en langage C Index\n266 © Éditions Eyrollesprécision 20\nde l’afﬁchage 53\npré-décrémentation (opérateurs) 40\npré-incrémentation (opérateurs) 39préprocesseur 9, 205printf (stdio.h) 6, 52, 54, 228priorités (des opérateurs) 28programme\ncompilation 15édition 15\nde liens 16\nen-tête 5exécutable 16principal 5règles d’écriture 12source 15structure 5\npromotions numériques 30prototype 33, 102putc (stdio.h) 235putchar (stdio.h) 236puts (stdio.h) 149, 236\nR\nrealloc (stdlib.h) 199, 200, 241recherche dans une chaîne 158récursion (des fonctions) 110redirection des entrées-sorties 192register 114règles d’écriture 12répétition 7, 67représentation des chaînes 146return (instruction) 98\nS\nscalaire (type) 17scanf (stdio.h) 7, 56, 61, 232SEEK_CUR (stdio.h) 186SEEK_END (stdio.h) 186SEEK_SET (stdio.h) 186séparateurs 13, 57short int (type) 19signed 217\nsimple (type) 17sin (math.h) 239sinh (math.h) 240sizeof (opérateur) 47soustraction de pointeurs 135sprintf (stdio.h) 159, 229sqrt (math.h) 240srand (stdlib.h) 241sscanf (stdio.h) 151, 232static (déclaration) 112statique\nclasse 107, 115, 195variable 109\nstdaux 192stderr 192stdin 192stdlib.h 240stdout 192stdprt 192strcat (string.h) 154, 238strchr (string.h) 158, 238strcmp (string.h) 156, 238strcpy (string.h) 157, 238stream 183stricmp (string.h) 157string.h 238strlen (string.h) 239strncat (string.h) 155, 238strncmp (string.h) 156, 238strncpy (string.h) 157, 238strnicmp (string.h) 157strrchr (string.h) 158, 238strspn (string.h) 239strstr (string.h) 158structure 165\nchamp 165d’un programme 5de structures 172déclaration 166en argument 174en valeur de retour 177imbrication 170initialisation 168Delannoy Livre.book  Page 266  Mercredi, 6. mai 2009  4:27 16\n© Éditions Eyrolles 267 Index Programmer en langage C\nmodèle 166\nutilisation 167\nswitch (instruction) 72, 76\nT\ntableau 121\narrangement mémoire 124de structures 171de taille variable 139, 140déclaration 122, 124dimension 123en argument 137indice 121, 123initialisation 125, 147, 148nom 132structure de 170\ntampon 57tan (math.h) 239tanh (math.h) 240tas 196transmission\ndes arguments) 104par adresse 130\ntype\ncaractère 18, 21, 218chaîne 145d’une variable 5domaine 20double 20entier 18, 216énumération 165, 177ﬂoat 20ﬂottant 18, 20int 19long double 20long int 19scalaire 17\nshort int 19simple 17structure 165structuré 17synonyme 169union 224\ntypedef 169\nU\nunion 224unsigned 217\nV\nva_arg (stdarg.h) 116va_end (stdarg.h) 118va_list (stdarg.h) 117va_start (stdarg.h) 116valeur de retour (fonction) 97, 99variable\nautomatique 108, 115classe d’allocation 113globale 105, 112initialisation 23, 113, 115locale 107portée 106, 113statique 109, 115type 5\nvoid 99void * 136\nW\nwhile (instruction) 80, 81Delannoy Livre.book  Page 267  Mercredi, 6. mai 2009  4:27 16\nCet ouvrage est destiné aux étudiants débutants en langage C, mais ayant déjà quelques notions de programmation\nacquises par la pratique – même sommaire – d'un autre langage.\nLes notions fondamentales (types de données, opérateurs, instructions de contrôle, fonctions, tableaux…) sont exposées\navec un grand soin pédagogique, le lecteur étant conduit progressivement vers la maîtrise de concepts plus avancéscomme les pointeurs ou la gestion dynamique de la mémoire. \nChaque notion importante est illustrée d’exemples de programmes complets, accompagnés de résultats d’exécution. \nDe nombreux exercices, dont la solution est fournie en fin d’ouvrage, vous permettront de tester vos connaissances fraîchement acquises et de les approfondir.\nCette cinquième édition inclut les nouveautés de la dernière version de la norme ISO du langage (C99). \nÀ qui s’adresse ce livre ?\n•Aux étudiants de BTS, d’IUT, de licence ou d’écoles d’ingénieur.\n•Aux autodidactes ou professionnels de tous horizons souhaitant s’initier à la programmation en C.\n•Aux enseignants et formateurs à la recherche d’une méthode pédagogique et d’un support de cours structuré pour \nenseigner le C à des débutants.\nAu sommaire\nIntroduction au langage C • Les types de base du C • Les opérateurs et les expressions • Les entrées-sorties : printf, scanf\n• Les instructions de contrôle : if, switch, do…while, while, for… • La programmation modulaire et les fonctions •\nVariables locales et variables globales • Les tableaux et les pointeurs • Les chaînes de caractères • Les structures • Les\nfichiers • Gestion dynamique de la mémoire : fonctions malloc, free, calloc, realloc • Le préprocesseur • Les possibilités\ndu langage proches de la machine : opérateurs de manipulation de bits, champs de bits, unions • Les principales fonctions\nde la bibliothèque standard ( stdio.h, ctype.h, math.h, stdlib.h ) • Corrigé des exercices.\n9782212125467Code éditeur : G12546 • ISBN : 978-2-212-12546-7\nProgrammer en langage CC. Delannoy\nClaude Delannoy\nIngénieur informaticien au CNRS, Claude Delannoy possède une grande pratique de la formationcontinue et de l'enseignement supérieur. Réputés pour la qualité de leur démarche pédagogique,ses ouvrages sur les langages et la programmation totalisent plus de 250 000 exemplairesvendus.\nClaude Delannoy5eédition5eédition\nProgrammerenlangageC\nCours et exercices corrigésProgrammerenlangageC\nCours et exercices corrigés\n19,90 €250 000 ouvrages vendus250 000 ouvrages vendusdel 2009_C  12/05/09  9:51  Page 1",
  "file_type": "document",
  "original_path": "data/uploads\\module_Programmer en langage C  Cours et exercices corrigés - 5ème Edition.pdf"
}