{
  "filename": "module_courscomplet.pdf",
  "extraction_date": "2025-09-29T12:56:30.491808",
  "statistics": {
    "word_count": 18338,
    "character_count": 149722,
    "line_count": 6704
  },
  "top_keywords": [
    [
      "fauconnier",
      378
    ],
    [
      "public",
      284
    ],
    [
      "string",
      227
    ],
    [
      "java",
      179
    ],
    [
      "void",
      169
    ],
    [
      "classe",
      149
    ],
    [
      "system",
      132
    ],
    [
      "peut",
      110
    ],
    [
      "objet",
      109
    ],
    [
      "class",
      102
    ]
  ],
  "extracted_data": {
    "emails": [
      "hf@liafa.jussieu.fr"
    ],
    "urls": [
      "http://www.java.com/fr",
      "http://www.liafa.jussieu.fr/",
      "http://java.sun.com/docs/index.html",
      "http://mindview.net/Books/TIJ4"
    ],
    "dates": []
  },
  "content_preview": "Cours programmation-\norientée objet en Java \nLicence d’informatique \nHugues Fauconnier \nhf@liafa.jussieu.fr \n \n\nPOO-L3 H. Fauconnier \n2 \nPlan du cours \no \nIntroduction:  \nn \nprogrammation objet pourquoi? Comment? Un exemple en Java \no \nClasses et objets (révision) \nn \nMéthodes et variables, constructeurs, contrôle d’accès, constructeurs \no \nHéritage: liaison dynamique et typage \nn \nExtension de classe, méthode et héritage, variables et héritage, constructeurs et héritage \no \nHéritage: com...",
  "full_content": "Cours programmation-\norientée objet en Java \nLicence d’informatique \nHugues Fauconnier \nhf@liafa.jussieu.fr \n \n\nPOO-L3 H. Fauconnier \n2 \nPlan du cours \no \nIntroduction:  \nn \nprogrammation objet pourquoi? Comment? Un exemple en Java \no \nClasses et objets (révision) \nn \nMéthodes et variables, constructeurs, contrôle d’accès, constructeurs \no \nHéritage: liaison dynamique et typage \nn \nExtension de classe, méthode et héritage, variables et héritage, constructeurs et héritage \no \nHéritage: compléments \nn \nclasses abstraites et interfaces, classes internes et emboîtées, classe Object, clonage,  \no \nIntroduction à Swing \no \nExceptions \nn \nExceptions, assertions \no \nDivers: Noms, conversions, héritage et tableaux \no \nGénéricité \nn \nGénéralités, types génériques imbriqués, types paramètres bornés, méthodes génériques \no \nTypes de données \nn \nString et expressions régulières, Collections, Conteneurs, itérations \no \nEntrées-sorties \no \nThreads \no \nCompléments \nn \nReflections, annotations, documentation… \nLe site du cours: http://www.liafa.jussieu.fr/~hf/verif/ens/an11-12/poo/L3.POO.html \nDidel POO \n\nPOO-L3 H. Fauconnier \n3 \nBibliographie \no \nDe nombreux livres sur java (attention \njava >= 1.5) \no \nEn ligne: \nn \nhttp://mindview.net/Books/TIJ4 \nn \nThinking in Java, 4th edition Bruce Eckel \nn \nhttp://java.sun.com/docs/index.html \n \no \nLivre conseillé: \nn \nThe Java Programming language fourth \nedition AW Ken Arnold, James Gosling, \nDavid Holmes  \n \n\nChapitre I \nIntroduction \n\nPOO-L3 H. Fauconnier \n5 \nA) Généralités \no  Problème du logiciel: \nn  Taille \nn  Coût : développement et maintenance \nn  Fiabilité \no  Solutions : \nn  Modularité \nn  Réutiliser le logiciel \nn  Certification  \nn  Comment? \n\nPOO-L3 H. Fauconnier \n6 \nTypage… \no  Histoire: \nn  Fonctions et procédures (60 Fortran) \nn  Typage des données (70) Pascal Algol \nn  Modules: données + fonctions regroupées \n(80) ada \nn  Programmation objet: classes, objets et \nhéritage \n\nPOO-L3 H. Fauconnier \n7 \nB) Principes de base de la POO \no  Objet et classe: \nn  Classe = définitions pour des données \n(variables) + fonctions (méthodes) agissant \nsur ces données \nn  Objet = élément d’une classe (instance) \navec un état \nn  (une méthode ou une variable peut être \no \n de classe = commune à la classe ou  \no \nd’instance = dépendant de l’instance \n ) \n\nPOO-L3 H. Fauconnier \n8 \nPrincipes de bases (suite) \no  Encapsulation et séparation de la \nspécification et de l’implémentation \nn  Séparer l’implémentation de la spécification. \no \nNe doit être visible de l’extérieur que ce qui est \nnécessaire, les détails d’implémentation sont « cachés » \no  Héritage: \nn  Une classe peut hériter des propriétés d’une \nautre classe: un classe peut être une extension \nd’une autre classe. \n\nPOO-L3 H. Fauconnier \n9 \nPrincipes de bases de la POO \no  Mais surtout notion de polymorphisme: \nn  Si une classe A est une extension d’une classe B: \no \nA doit pouvoir redéfinir certaines méthodes (disons f()) \no \nUn objet a de classe A doit pouvoir être considéré \ncomme un objet de classe B \no \nOn doit donc accepter : \nn \nB b; \nn \nb=a; (a a toutes les propriétés d’un B) \nn \nb.f()  \no \nDoit appeler la méthode redéfinie dans A! \nn \nC’est le transtypage \no \n(exemple: méthode paint des interfaces graphiques) \n\nPOO-L3 H. Fauconnier \n10 \nPrincipes de bases \no  Polymorphisme: \nn  Ici l’association entre le nom ‘f()’ et le code \n(code de A ou code de B) a lieu dynamiquement (=à \nl’exécution) \nLiaison dynamique \nn  On peut aussi vouloir « paramétrer » une classe \n(ou une méthode) par une autre classe.  \n Exemple: Pile d’entiers \n Dans ce cas aussi un nom peut correspondre à \nplusieurs codes, mais ici l’association peut avoir \nlieu de façon statique (au moment de la \ncompilation) \n\nPOO-L3 H. Fauconnier \n11 \nC) Comment assurer la \nréutilisation du logiciel? \no  Type abstrait de données \nn  définir le type par ses propriétés (spécification) \no  Interface, spécification et implémentation \nn  Une interface et une spécification (=les \npropriétés à assurer) pour définir un type \nn  Une (ou plusieurs) implémentation du type \nabstrait de données \no \nCes implémentations doivent vérifier la spécification \n\nPOO-L3 H. Fauconnier \n12 \nComment assurer la réutilisation \ndu logiciel? \no  Pour l’utilisateur du type abstrait de \ndonnées \nn  Accès uniquement à l’interface (pas \nd’accès à l’implémentation) \nn  Utilisation des propriétés du type abstrait \ntelles que définies dans la spécification. \nn  (L’utilisateur est lui-même un type \nabstrait avec une interface et une \nspécification) \n\nPOO-L3 H. Fauconnier \n13 \nComment assurer la réutilisation \ndu logiciel? \no  Mais en utilisant un type abstrait \nl’utilisateur n'en connaît pas \nl’implémentation  \nn  il sait uniquement que la spécification du \ntype abstrait est supposée être vérifiée \npar l'implémentation. \no  Pour la réalisation concrète, une \nimplémentation particulière est choisie \no  Il y a naturellement polymorphisme \n\nPOO-L3 H. Fauconnier \n14 \nNotion de contrat (Eiffel) \no \nUn client et un vendeur \no \nUn contrat lie le vendeur et le client (spécification) \no \nLe client ne peut utiliser l’objet que par son \ninterface \no \nLa réalisation de l’objet est cachée au client  \no \nLe contrat est conditionné par l’utilisation correcte \nde l’objet (pré-condition) \no \nSous réserve de la pré-condition le vendeur s’engage \nà ce que l’objet vérifie sa spécification (post-\ncondition) \no \nLe vendeur peut déléguer: l’objet délégué doit \nvérifier au moins le contrat (héritage) \n\nPOO-L3 H. Fauconnier \n15 \nD) Un exemple… \no  Pile abstraite et diverses \nimplémentations \n\nPOO-L3 H. Fauconnier \n16 \nType abstrait de données \nNOM \n    pile[X]  \nFONCTIONS \n    vide : pile[X] -> Boolean \n    nouvelle : -> pile[X] \n    empiler : X x pile[X] -> pile[X] \n    dépiler : pile[X] -> X x pile[X] \nPRECONDITIONS \n    dépiler(s: pile[X]) <=> (not vide(s)) \nAXIOMES \n    forall x in X, s in pile[X] \n            vide(nouvelle()) \n            not vide(empiler(x,s)) \n            dépiler(empiler(x,s))=(x,s) \n\nPOO-L3 H. Fauconnier \n17 \nRemarques \no  Le type est paramétré par un autre \ntype \no  Les axiomes correspondent aux pré- \nconditions \no  Il n’y pas de représentation \no  Il faudrait vérifier que cette définition \ncaractérise bien un pile au sens usuel du \nterme (c’est possible) \n \n\nPOO-L3 H. Fauconnier \n18 \nPile abstraite en java \npackage pile; \n \nabstract class Pile <T>{ \n    abstract public T empiler(T v); \n    abstract public T dépiler(); \n    abstract public Boolean estVide(); \n} \n\nPOO-L3 H. Fauconnier \n19 \nDivers \no  package: regroupement de diverses \nclasses \no  abstract: signifie qu’il n’y a pas \nd’implémentation \no  public: accessible de l’extérieur \no  La classe est paramétrée par un type \n(java 1.5) \n\nPOO-L3 H. Fauconnier \n20 \nImplémentations \no  On va implémenter la pile: \nn   avec un objet de classe Vector (classe \ndéfinie dans java.util.package) en fait \nil s’agit d’un ArrayList \nn  Avec un objet de classe LinkedList \nn  Avec Integer pour obtenir une pile de \nInteger \n\nPOO-L3 H. Fauconnier \n21 \nUne implémentation \npackage pile; \nimport java.util.EmptyStackException; \nimport java.util.Vector; \npublic class MaPile<T> extends Pile<T>{ \n    private Vector<T> items; \n    // Vector devrait être remplacé par ArrayList \n    public MaPile() { \n        items =new Vector<T>(10); \n    } \n    public Boolean estVide(){ \n        return items.size()==0; \n    } \n    public T empiler(T item){ \n        items.addElement(item); \n        return item; \n    } \n    //… \n     \n\nPOO-L3 H. Fauconnier \n22 \nSuite \n//… \npublic synchronized T dépiler(){ \n        int len = items.size(); \n        T item = null; \n        if (len == 0) \n            throw new EmptyStackException(); \n        item = items.elementAt(len - 1); \n        items.removeElementAt(len - 1); \n        return item; \n    }     \n} \n\nPOO-L3 H. Fauconnier \n23 \nAutre implémentation avec listes \npackage pile; \nimport java.util.LinkedList;  \npublic class SaPile<T> extends Pile<T> { \n    private LinkedList<T> items; \n    public SaPile(){ \n        items = new LinkedList<T>(); \n    } \n    public Boolean estVide(){ \n        return items.isEmpty(); \n    } \n    public T empiler(T item){ \n        items.addFirst(item); \n        return item; \n    } \n    public T dépiler(){ \n        return items.removeFirst(); \n    } \n} \n \n\nPOO-L3 H. Fauconnier \n24 \nUne pile de Integer \npublic class PileInteger extends Pile<Integer>{ \n    private Integer[] items; \n    private int top=0; \n    private int max=100; \n    public PileInteger(){ \n        items = new Integer[max]; \n    } \n    public Integer empiler(Integer item){ \n        if (this.estPleine()) \n            throw new EmptyStackException(); \n        items[top++] = item; \n        return item; \n    } \n    //… \n\nPOO-L3 H. Fauconnier \n25 \nSuite… \npublic synchronized Integer dépiler(){ \n        Integer item = null; \n        if (this.estVide()) \n            throw new EmptyStackException(); \n        item = items[--top]; \n        return item; \n    } \n    public Boolean estVide(){ \n        return (top == 0); \n    } \n    public boolean estPleine(){ \n        return (top == max -1); \n    } \n    protected void finalize() throws Throwable { \n        items = null; super.finalize(); \n    } \n} \n\nPOO-L3 H. Fauconnier \n26 \nComment utiliser ces classes? \no  Le but est de pouvoir écrire du code \nutilisant la classe Pile abstraite  \no  Au moment de l’exécution, bien sûr, ce \ncode s’appliquera à un objet concret \n(qui a une implémentation) \no  Mais ce code doit s’appliquer à toute \nimplémentation de Pile \n\nPOO-L3 H. Fauconnier \n27 \nUn main \npackage pile; \npublic class Main { \n    public static void vider(Pile p){ \n        while(!p.estVide()){ \n            System.out.println(p.dépiler()); \n        } \n    } \npublic static void main(String[] args) { \n        MaPile<Integer> p1= new MaPile<Integer>(); \n        for(int i=0;i<10;i++) \n            p1.empiler(i); \n        vider(p1); \n        SaPile<String> p2= new SaPile<String>(); \n        p2.empiler(\"un\"); \n        p2.empiler(\"deux\"); \n        p2.empiler(\"trois\"); \n        vider(p2); \n    } \n     \n} \n\nPOO-L3 H. Fauconnier \n28 \nE) java:  quelques rappels… \no  Un source avec le suffixe .java \no  Une classe par fichier source (en principe) \nmême nom pour la classe et le fichier source \n(sans le suffixe .java) \no  Méthode  \npublic static void main(String[]); \nn  main est le point d’entrée \no  Compilation génère un .class \no  Exécution en lançant la machine java \n\nPOO-L3 H. Fauconnier \n29 \nGénéralités… \no \nUn peu plus qu’un langage de programmation: \nn \n“gratuit”! (licence GPL)  \nn \nIndépendant de la plateforme \nn \nLangage interprété et byte code \nn \nSyntaxe à la C \nn \nOrienté objet (classes héritage) \no \nNombreuses bibliothèques \nn \nPas de pointeurs! (ou que des pointeurs!) \no \nRamasse-miettes \nn \nMulti-thread \nn \nDistribué (WEB) applet, servlet, … \nn \nDernière version Java SE 7 (GPL) \nn \nSite:http://www.java.com/fr \n\nPOO-L3 H. Fauconnier \n30 \nPlateforme Java \no \nLa compilation génère un .class en bytecode (langage \nintermédiaire indépendant de la plateforme). \no \nLe bytecode est interprété par un interpréteur Java \nJVM \nCompilation javac \ninterprétation java \n\nPOO-L3 H. Fauconnier \n31 \nLangage intermédiaire  et \nInterpréteur… \no  Avantage: indépendance de la \nplateforme \nn  Échange de byte-code (applet) \no  Inconvénient: efficacité  \n\nPOO-L3 H. Fauconnier \n32 \nPlateforme Java \no \nLa plateforme java: software au-dessus d’une \nplateforme exécutable sur un hardware (exemple \nMacOs, linux …) \no \nJava VM \no \nJava application Programming Interface (Java API):  \n\nPOO-L3 H. Fauconnier \n33 \nTout un environnement… \no \nJava 2 sdk: JRE (java runtime environment + outils \nde développements compilateur, debogueurs etc…) \n\nTout un environnement… \nPOO-L3 H. Fauconnier \n34 \n\nPOO-L3 H. Fauconnier \n35 \nTrois exemples de base \no  Une application \no  Une applet \no  Une application avec interface \ngraphique \n\nPOO-L3 H. Fauconnier \n36 \nApplication: \no \nFichier Appli.java: \n/**  \n * Une application  basique... \n */ \nclass Appli { \n    public static void main(String[] args) { \n     System.out.println(\"Bienvenue en L3...\"); \n               //affichage \n    } \n} \n\nPOO-L3 H. Fauconnier \n37 \nCompiler, exécuter… \no \nCréer un fichier Appli.java \no \nCompilation: \nn \njavac Appli.java \no \nCréation de Appli.class (bytecode) \no \nInterpréter le byte code: \nn \njava Appli \no \nAttention aux suffixes!!! \nn \n(il faut que javac et java soient dans $PATH) \nException in thread \"main\" java.lang.NoClassDefFoundError:  \nn \nIl ne trouve pas le main -> vérifier le nom! \nn \nVariable CLASSPATH ou option -classpath \n\nPOO-L3 H. Fauconnier \n38 \nRemarques \no \nCommentaires /* … */ et // \no \nDéfinition de classe \nn \nune classe contient des méthodes (=fonctions) et des \nvariables \nn \nPas de fonctions ou de variables globales (uniquement dans \ndes classes ou des instances) \no \nMéthode main: \nn \npublic static void main(String[] arg) \no \npublic \no \nstatic \no \nVoid \no \nString \nn \nPoint d’entrée \n\nPOO-L3 H. Fauconnier \n39 \nRemarques \no  Classe System \nn  out est une variable de la classe System \nn  println méthode de System.out \nn  out est une variable de classe qui fait \nréférence à une instance de la classe \nPrintStream qui implémente un flot de \nsortie. \no \nCette instance a une méthode println \n\nPOO-L3 H. Fauconnier \n40 \nRemarques… \no  Classe: définit des méthodes et des variables \n(déclaration) \no  Instance d’une classe (objet) \nn  Méthode de classe: fonction associée à (toute la) \nclasse. \nn  Méthode d’instance: fonction associée à une \ninstance particulière. \nn  Variable de classe: associée à une classe (globale \net partagée par toutes les instances) \nn  Variable d’instance: associée à un objet \n(instancié) \no  Patience… \n\nPOO-L3 H. Fauconnier \n41 \nApplet: \no  Applet et WEB \nn  Client (navigateur) et serveur WEB \nn  Le client fait des requêtes html, le serveur \nrépond par des pages html \nn  Applet: \no \nLe serveur répond par une page contenant des applets \no \nApplet: byte code \no \nCode exécuté par le client \no \nPermet de faire des animations avec interfaces \ngraphiques sur  le client.  \no \nUne des causes du succès de java. \n  \n\nPOO-L3 H. Fauconnier \n42 \nExemple applet \no \nFichier MonApplet.java: \n/**  \n * Une applet  basique... \n */ \nimport java.applet.Applet; \nimport java.awt.Graphics; \npublic class MonApplet extends Applet { \n    public void paint(Graphics g){ \n g.drawString(\"Bienvenue en en L3...\", 50,25); \n    } \n} \n \n\nPOO-L3 H. Fauconnier \n43 \nRemarques: \no  import et package:  \nn  Un package est un regroupement de classes. \nn  Toute classe est dans un package  \nn  Package par défaut (sans nom) \nn  classpath \no  import java.applet.*; \nn  Importe le package java.applet \no \nApplet est une classe de ce package, \no \nSans importation il faudrait java.applet.Applet  \n\nPOO-L3 H. Fauconnier \n44 \nRemarques: \no  La classe Applet contient ce qu’il faut \npour écrire une applet \no  … extends Applet: \nn  La classe définie est une extension de la \nclasse Applet: \no \nElle contient tout ce que contient la classe \nApplet \no \n(et peut redéfinir certaines méthodes (paint)) \nn  Patience!! \n\nPOO-L3 H. Fauconnier \n45 \nRemarques… \no \nUne Applet contient les méthodes paint start et \ninit. En redéfinissant paint, l’applet une fois \nlancée exécutera ce code redéfini. \no \nGraphics g argument de paint est un objet qui \nreprésente le contexte graphique de l’applet. \nn \ndrawString est une méthode (d’instance) qui affiche une \nchaîne,  \nn \n50, 25: affichage à partir de la position (x,y) à partir du \npoint (0,0) coin en haut à gauche de l’applet.  \n\nPOO-L3 H. Fauconnier \n46 \nPour exécuter l’applet \no  L’applet doit être exécutée dans un \nnavigateur capable d’interpréter du \nbytecode correspondant à des applet. \no  Il faut créer un fichier HTML pour le \nnavigateur. \n\nPOO-L3 H. Fauconnier \n47 \nHtml pour l’applet \no  Fichier Bienvenu.html: \n<HTML> \n<HEAD> \n<TITLE> Une petite applet </TITLE> \n<BODY> \n<APPLET CODE='MonApplet.class' WIDTH=200 \nHeight=50> \n</APPLET> \n</BODY> \n</HTML> \n\nPOO-L3 H. Fauconnier \n48 \nHtml \no  Structure avec balises: \no  Exemples:  \nn \n<HTML> </HTML> \nn  url:  \no \n<a target=\"_blank\" href=\"http://\nwww.liafa.jussieu.f/~hf\">page de hf</a> \no  Ici: \n<APPLET CODE='MonApplet.class' WIDTH=200 \nHeight=50> \n</APPLET> \n\nPOO-L3 H. Fauconnier \n49 \nExemple interface graphique \nFichier MonSwing.java: \n/**  \n * Une application  basique... avec interface graphique \n */ \nimport javax.swing.*;         \npublic class MonSwing { \n    private static void creerFrame() { \n        //Une formule magique... \n        JFrame.setDefaultLookAndFeelDecorated(true); \n        //Creation d'une Frame \n        JFrame frame = new JFrame(\"MonSwing\"); \n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); \n     //Afficher un message \n        JLabel label = new JLabel(\"Bienvenue en L3...\"); \n        frame.getContentPane().add(label); \n        //Afficher la fenêtre \n        frame.pack(); \n        frame.setVisible(true); \n    } \n public static void main(String[] args) { \n     creerFrame(); \n    } \n} \n\nPOO-L3 H. Fauconnier \n50 \nRemarques \no \nImportation de packages \no \nDéfinition d’un conteneur top-level JFrame, \nimplémenté comme instance de la classe JFrame \no \nAffichage de ce conteneur \no \nDéfinition d’un composant JLabel, implémenté \ncomme instance de JLabel \no \nAjout du composant JLabel dans la JFrame \no \nDéfinition du comportement de la Jframe sur un \nclick du bouton de fremeture \no \nUne méthode main qui crée la JFrame \n\nPOO-L3 H. Fauconnier \n51 \nPour finir… \no  Java 1.5  et 6 annotations, types \nméthodes paramétrés par des types \no  Très nombreux packages \no  Nombreux outils de développement \n(gratuits) \nn  eclipse, netbeans.. \n\nPOO-L3 H. Fauconnier \n52 \nEn plus… \no  Entrées-sorties \n\nPOO-L3 H. Fauconnier \n53 \nEntrée-sortie \n public static void main(String[] args) { \n     // sortie avec printf ou \n     double a = 5.6d ; \n     double b = 2d ; \n     String mul = \"multiplié par\" ; \n     String eq=\"égal\"; \n     System.out.printf(Locale.ENGLISH, \n                \"%3.2f X %3.2f = %6.4f \\n\", a ,b , a*b); \n     System.out.printf(Locale.FRENCH, \n          \"%3.2f %s %3.2f %s %6.4f \\n\", a, mul,b, eq,a*b); \n      System.out.format( \n         \"Aujourd'hui %1$tA, %1$te %1$tB,\"+ \n          \" il est: %1$tH h %1$tM min %1$tS \\n\", \n                Calendar.getInstance()); \n        // System.out.flush(); \n         \n\nPOO-L3 H. Fauconnier \n54 \nSortie \n5.60 X 2.00 = 11.2000  \n5,60 multiplié par 2,00 égal 11,2000  \nAujourd'hui mardi, 10 octobre, il est: 15 h \n31 min 01  \n\nPOO-L3 H. Fauconnier \n55 \nScanner \n  Scanner sc = new Scanner(System.in); \n  for(boolean fait=false; fait==false;){ \n      try { \n         System.out.println(\"Répondre o ou O:\"); \n         String s1 =sc.next(Pattern.compile(\"[0o]\")); \n                fait=true; \n      } catch(InputMismatchException e) { \n      sc.next(); \n      } \n  } \n  if (sc.hasNextInt()){ \n      int i= sc.nextInt(); \n      System.out.println(\"entier lu \"+i); \n  } \n  System.out.println(\"next token :\"+sc.next()); \n  sc.close(); \n         \n\nPOO-L3 H. Fauconnier \n56 \nScanner \nif (sc.hasNextInt()){ \n    int i= sc.nextInt(); \n    System.out.println(\"entier lu \"+i); \n} \nSystem.out.println(\"next token :\"+sc.next()); sc.close(); \nString input = \"1 stop 2 stop éléphant gris stop rien\"; \nScanner s = new(Scanner(input).useDelimiter(\"\\\\s*stop\\\\s*\"); \n        System.out.println(s.nextInt()); \n        System.out.println(s.nextInt()); \n        System.out.println(s.next()); \n        System.out.println(s.next()); \n        s.close(); \n    } \n\nPOO-L3 H. Fauconnier \n57 \nSortie \no  next token :o \no  1 \no  2 \no  éléphant gris \no  rien \n\nLes classes… \no  System \nn  System.out variable (static) de classe \nPrintStream \no \nPrintStream contient print (et printf) \nn  System.in variable (static) de classe \nInputStream \no  Scanner  \n \nPOO-L3 H. Fauconnier \n58 \n\nChapitre II \nClasses et objets \n(rappels) \n(mais pas d’héritage) \n\nclasses et objets \nPOO-L3 H. Fauconnier \n60 \nClasses et objets \no  I)   Introduction \no  II) Classe: membres et modificateurs \no  III) Champs: modificateurs \no  IV) Vie et mort des objets, \nConstructeurs \no  V) Méthodes  \no  VI) Exemple \n\nclasses et objets \nPOO-L3 H. Fauconnier \n61 \nI) Introduction \no  Classe \nn  Regrouper des données et des méthodes \no \nVariables de classe \no \nMéthodes de classe \nn  Classes<->type \no  Objet (ou instance) \nn  Résultat de la création d’un objet \no \nVariables d’instance \no \nVariables de classe \no  Toute classe hérite de la classe Object \n\nclasses et objets \nPOO-L3 H. Fauconnier \n62 \nII) Classes \no  Membres d ’une classe sont: \nn  Champs = données \nn  Méthodes = fonctions \nn  Classes imbriquées \n\nclasses et objets \nPOO-L3 H. Fauconnier \n63 \nModificateur de classe \no  Précède la déclaration de la classe \nn  Annotations (plus tard…) \nn  public (par défaut package) \nn  abstract(incomplète, pas d’instance) \nn  final(pas d’extension) \nn  Strictfp (technique…) \n\nclasses et objets \nPOO-L3 H. Fauconnier \n64 \nIII) Champs \no \nModificateurs \nn \nannotations \nn \nContrôle d’accès \no \nprivate \no \nprotected \no \npublic \no \npackage \nn \nstatic (variables de classe) \nn \nfinal (constantes) \nn \ntransient \nn \nVolatile \no \nInitialisations \no \nCréation par opérateur new \n\nclasses et objets \nPOO-L3 H. Fauconnier \n65 \nIV) Vie et mort des objets, \nconstructeurs \no  Création d’une instance: opérateur new \no  Objet mort = plus aucune référence à \ncet objet -> garbage collector \nn  on peut exécuter du code spécifique quand \nun objet est détruit : \nprotected void finalize() throws Throwable \n \n\nclasses et objets \nPOO-L3 H. Fauconnier \n66 \nRéférences \no  Une variable est (en général) une référence à \nun objet \nn  Type primitif: directement une valeur \nn  Type référence : une référence à un objet \n(existant ou créé par new)  \no \nnull : référence universelle \no \nconséquences:  \nn \ndans le passage par valeur un type référence correspond à \nun passage par référence \nn \n‘a == b‘ teste si les a et b référencent le même objet \nn \nMéthode equals qui peut être redéfinie (défaut \nthis==obj) \n\nclasses et objets \nPOO-L3 H. Fauconnier \n67 \nExemple \nint i=0; \nint j=0; \n(i==j) // vrai \nclass A{ \n    int i=0; \n} \nA a; \nA b=new A(); \na=b; \n(a==b) // vrai \nb=new A(); \n(a==b) // faux \n \n \n\nclasses et objets \nPOO-L3 H. Fauconnier \n68 \n Constructeurs \no  Appelés par l’opérateur new pour créer \nun objet \nn  Peuvent avoir des paramètres (avec \nsurcharge) \nn  Initialisent les objets \nn  Constructeur par défaut (si aucun \nconstructeur n’est défini) \nn  Constructeur de copie \n \n\nclasses et objets \nPOO-L3 H. Fauconnier \n69 \nExemple: \npublic class Astre { \n    private long idNum; \n    private String nom = \"<pasdenom>\"; \n    private Astre orbite = null; \n    private static long nextId = 0;     \n    /** Creation d’une nouvelle instance of Astre */ \n    private Astre() { \n        idNum = nextId ++; \n    } \n    public Astre(String nom, Astre enOrbite){ \n        this(); \n        this.nom=nom; \n        orbite=enOrbite; \n    } \n    public Astre(String nom){ \n        this(nom,null); \n    }//… \n     \n\nclasses et objets \nPOO-L3 H. Fauconnier \n70 \nExemples… \no  Copie \n public Astre(Astre a){ \n        idNum = a.idNum; \n        nom=a.nom; \n        orbite=a.orbite; \n    } \n\nStatique - dynamique \no  Statique <-> à la compilation \no  Dynamique <-> à l’exécution \no  Le type d’une variable est déterminé à \nla compilation (déclaration et portée) \no  Avec la possibilité de l’héritage une \nvariable peut être une référence sur un \nobjet d’un autre type que le type de sa \ndéclaration \nclasses et objets \nPOO-L3 H. Fauconnier \n71 \n\nStatic \no  Une variable (une méthode) déclarée \nstatic est une variable (méthode) de \nclasse: elle est associée à la classe (pas à \nune instance particulière). \no  Statique parce qu’elle peut être créée au \nmoment de la compilation (pas de new()). \no  Statique -> les initialisations doivent avoir \nlieu à la compilation. \nclasses et objets \nPOO-L3 H. Fauconnier \n72 \n\nInitialisations \nprivate static long nextId = 0;  \no  Bloc d’initialisation    \nprivate static long netxId = 0; \n{ \n        idNum = nextId++; \n } \nclasses et objets \nPOO-L3 H. Fauconnier \n73 \n\nclasses et objets \nPOO-L3 H. Fauconnier \n74 \nInitialisation static \npublic class Puissancedeux { \n    static int[] tab = new int[12]; \n    static{ \n        tab[0]=1; \n        for(int i=0; i< tab.length-1;i++) \n            tab[i+1]= suivant(tab[i]); \n         } \n    static int suivant(int i){ \n        return i*2; \n    }     \n} \n\nclasses et objets \nPOO-L3 H. Fauconnier \n75 \nV) Méthodes \no  Modificateurs: \nn  Annotations \nn  Contrôle d’accès (comme pour les variables) \nn  abstract \nn  static n’a pas accès aux variables d’instances \nn  final ne peut pas être remplacée \nn  synchronized \nn  native (utilisation de fonctions « native ») \nn  strictfp \n\nclasses et objets \nPOO-L3 H. Fauconnier \n76 \nPassage par valeur \npublic class ParamParVal { \n    public static void parVal(int i){ \n        i=0; \n        System.out.println(\"dans parVal i=\"+i); \n    } \n} \n//… \n int i =100; \n System.out.println(\"Avant i=\"+i); \n ParamParVal.parVal(i); \n System.out.println(\"Avant i=\"+i); \n--------------- \nAvant i=100 \ndans parVal i=0 \nAvant i=100 \n \n\nclasses et objets \nPOO-L3 H. Fauconnier \n77 \nMais… \no \nComme les variables sont de références (sauf les types \nprimitifs)… \n        public static void bidon(Astre a){ \n        a=new Astre(\"bidon\", null); \n        System.out.println(\"bidon a=\"+a); \n    } \n     public static void bidonbis(Astre a){ \n         a.setNom(\"bidon\"); \n         a.setOrbite(null); \n        System.out.println(\"bidonbis a=\"+a); \n    } \n\nclasses et objets \nPOO-L3 H. Fauconnier \n78 \nMéthodes… \no  Contrôler l’accès: \n //… \n    public void setNom(String n){ \n        nom=n; \n    } \n    public void setOrbite(Astre a){ \n        orbite=a; \n    } \n    public String getNom(){ \n        return nom; \n    } \n    public Astre getOrbite(){ \n        return orbite; \n    } \n\nclasses et objets \nPOO-L3 H. Fauconnier \n79 \nMéthodes, remplacement… \n     public String toString(){ \n        String st=idNum + \"(\"+nom+\")\"; \n        if (orbite != null) \n            st += \"en orbite \"+ orbite; \n        return st;        \n    } \nRemplace la méthode toString de la classe Object \n\nclasses et objets \nPOO-L3 H. Fauconnier \n80 \nNombre variable \nd’arguments… \n public static void affiche(String ... list){ \n         for(int i=0;i<list.length;i++) \n             System.out.print(list[i]+\" \"); \n } \n \n//… \n affiche(\"un\", \"deux\",\"trois\"); \n\nclasses et objets \nPOO-L3 H. Fauconnier \n81 \nMéthodes main \n public static void main(String[] args) { \n        for(int j =0; j<args.length;j++){ \n            System.out.print(args[j] + \" \");             \n        } \n} \n \nLe main est le point d’accès et peut avoir des arguments: \n \n \n\nclasses et objets \nPOO-L3 H. Fauconnier \n82 \nVI) exemple: Les astres… \npackage exempleclasses; \n \n/** \n * \n * @author sans \n */ \npublic class Astre { \n    private long idNum; \n    private String nom = \"<pasdenom>\"; \n    private Astre orbite = null; \n    private static long nextId = 0; \n    /** Creates a new instance of Astre */ \n    private Astre() { \n        idNum = nextId ++; \n    } \no \n         \n\nclasses et objets \nPOO-L3 H. Fauconnier \n83 \nSuite \n   public Astre(String nom, Astre enOrbite){ \n        this(); \n        this.nom=nom; \n        orbite=enOrbite; \n    } \n    public Astre(String nom){ \n        this(nom,null); \n    } \n    public Astre(Astre a){ \n        idNum = a.idNum; \n        nom=a.nom; \n        orbite=a.orbite; \n    }//… \n\nclasses et objets \nPOO-L3 H. Fauconnier \n84 \n    public void setNom(String n){ \n        nom=n; \n    } \n    public void setOrbite(Astre a){ \n        orbite=a; \n    } \n    public String getNom(){ \n        return nom; \n    } \n    public Astre getOrbite(){ \n        return orbite; \n    } \n    public String toString(){ \n        String st=idNum + \"(\"+nom+\")\"; \n        if (orbite != null) \n            st += \"en orbite \"+ orbite; \n        return st;        \n    } \n} \n \n\nChapitre III \nHéritage \n\nPOO-L3 H. Fauconnier \n86 \nChapitre III: Héritage \no \nA) Extensions généralités \nn \nAffectation et transtypage \no \nB) Méthodes \nn \nSurcharge et signature \no \nC) Méthodes (suite) \nn \nRedéfinition et liaison dynamique \no \nD) Conséquences \nn \nLes variables \no \nE) Divers \nn \nSuper, accès, final \no \nF) Constructeurs et héritage \n\nPOO-L3 H. Fauconnier \n87 \nA) Extension: généralités \no  Principe de la programmation objet: \no \nun berger allemand est un chien \nn \nil a donc toutes les caractéristiques des chiens \nn \nil peut avoir des propriétés supplémentaires \nn \nun chien est lui-même un mammifère qui est lui-même \nun animal:  hiérarchie des classes \nn  On en déduit: \no \nHiérarchie des classes (Object à la racine) \no \net si B est une extension de A alors un objet de \nB est un objet de A avec des propriétés \nsupplémentaires \n\nPOO-L3 H. Fauconnier \n88 \nExtension: généralités \nQuand B est une extension de la classe A: \nn  Tout objet de B a toutes les propriétés d’un \nobjet de A (+ d’autres). \nn  Donc un objet B peut être considéré comme un \nobjet A. \nn  Donc les variables définies pour un objet de A \nsont aussi présentes pour un objet de B (+ \nd’autres). (Mais elles peuvent être occultées) \nn  Idem pour les méthodes : Les méthodes de A sont \nprésentes pour B et un objet B peut définir de \nnouvelles méthodes. \nn  Mais B peut redéfinir des méthodes de A. \n\nPOO-L3 H. Fauconnier \n89 \nExtension de classe \nSi B est une extension de A \no  pour les variables: \nn  B peut ajouter des variables (et si le nom est \nidentique cela  occultera la variable de même nom \ndans A) \n (occulter = continuer à exister mais \"caché\") \nn  Les variables de A sont toutes présentes pour un \nobjet B, mais certaines peuvent être cachées \no  pour les méthodes \nn  B peut ajouter de nouvelles méthodes \nn  B peut redéfinir des méthodes (même signature) \n\nPOO-L3 H. Fauconnier \n90 \nRemarques: \no \npour les variables \no \nc'est le nom de la variable qui est pris en compte (pas le type). \no \ndans un contexte donné, à chaque nom de variable ne correspond \nqu'une seule déclaration. \no \n(l'association entre le nom de la variable et sa déclaration est faite à \nla compilation) \no \npour les méthodes \nn \nc'est la signature (nom + type des paramètres) qui est prise en \ncompte: \no \non peut avoir des méthodes de même nom et de signatures \ndifférentes (surcharge) \no \ndans un contexte donné, à un nom de méthode et à une signature \ncorrespond une seule définition  \no \n(l'association entre le nom de la méthode et sa déclaration est faite à \nla compilation, mais l'association entre le nom de la méthode et sa \ndéfinition sera faite à l'exécution) \n\nPOO-L3 H. Fauconnier \n91 \nExtension (plus précisément) \no  Si B est une extension de A \n(class B extends A) \nn  Les variables et méthodes de A sont des \nméthodes de B (mais elles peuvent ne pas être \naccessibles: private) \nn  B peut ajouter de nouvelles variables (si le nom \nest identique il y a occultation) \nn  B peut ajouter des nouvelles méthodes si la \nsignature est différente \nn  B redéfinit des méthodes de A si la signature est \nidentique  \n\nPOO-L3 H. Fauconnier \n92 \nRemarques: \no  Java est un langage typé \nn  en particulier chaque variable a un type: celui de \nsa déclaration \nn  à la compilation, la vérification du typage ne peut \nse faire que d'après les déclarations (implicites \nou explicites) \nn  le compilateur doit vérifier la légalité des appels \ndes méthodes et des accès aux variables: \no \na.f() est légal si pour le type de la variable a il existe \nune méthode f() qui peut s'appliquer à un objet de ce \ntype \no \na.m est légal si pour le type de la variable a il existe une \nvariable m qui peut s'appliquer à un objet de ce type \n\nPOO-L3 H. Fauconnier \n93 \nEn conséquence: \no  Une variable déclarée comme étant de classe \nA peut référencer un objet de classe B ou \nplus généralement un objet d’une classe \ndérivée de A: \nn  un tel objet contient tout ce qu’il faut pour être \nun objet de classe A \no  Par contre une variable déclarée de classe B \nne peut référencer un objet de classe A: \nil manque quelque chose! \n \n\nPOO-L3 H. Fauconnier \n94 \nAffectation downcast/upcast \nclass A{ \n    public int i; \n    //... \n} \nclass B extends A{ \n    public int j; \n    //... \n} \npublic class Affecter{ \n    static void essai(){ \n        A a = new A(); \n        B b = new B(); \n        //b=a; impossible que signifierait b.j?? \n        a=b; // a référence un objet B \n        // b=a; \n        b=(B)a; // comme a est un objet B ok!! \n    } \n} \n\nPOO-L3 H. Fauconnier \n95 \nUpcasting \no \nSi  B est une extension de A, alors un objet de B \npeut être considéré comme un objet de A: \nn \nA a=new B(); \no \nOn pourrait aussi écrire: \nn \nA a=(A) new B(); \no \nl'upcasting permet de considérer un objet d'une \nclasse dérivée comme un objet d'une classe de base \no \nUpcasting: de spécifique vers moins spécifique (vers \nle haut dans la hiérarchie des classes) \no \nl'upcasting peut être implicite (il est sans risque!) \no \nattention \nn \nil ne s'agit pas réellement d'une conversion: l'objet n'est \npas modifié \n\nPOO-L3 H. Fauconnier \n96 \nDowncasting \no \nSi  B est une extension de A, il est possible qu'un objet de A soit en \nfait un objet de B. Dans ce cas on peut vouloir le considérer un objet \nde B \nn \nA a=new B(); \nn \nB b=(B)a; \no \nIl faut dans ce cas un cast (transtypage) explicite (la \"conversion\" \nn'est pas toujours possible –l'objet référencé peut ne pas être d'un \ntype dérivé de B) \no \nA l'exécution, on vérifiera que le cast est possible et que l'objet \nconsidéré est bien d'un type dérivé de B \no \ndowncasting: affirme que l'objet considéré est d'un type plus \nspécifique que le type correspondant à sa décalration (vers le bas dans \nla hiérarchie des classes) \no \nle downcasting ne peut pas être implicite (il n'est pas toujours \npossible!) \no \nattention \nn \nil ne s'agit pas réellement d'une conversion: l'objet n'est pas modifié \n\nPOO-L3 H. Fauconnier \n97 \nCasting \no  On peut tester la classe avant de faire \ndu \"downcasting\": \nBase sref; \nDerive dref; \nif(sref instanceof Derive) \n    dref=(Derive) sref \n\nPOO-L3 H. Fauconnier \n98 \nB) Méthodes: Surcharge \no \nMéthodes et signature: \nn \nSignature: le nom et les arguments avec leur type (mais pas \nle type de la valeur retournée) \nn \nSeule la signature compte: \no \nint f(int i) \no \nchar f(int i) \no \nLes deux méthodes ont la  même signature: c'est interdit \nn \nSurcharge possible: \no \nDes  signatures différentes pour un même nom \nint f(int i) \nint f(double f) \no \nLe compilateur détermine par le type des arguments quelle \nfonction est utilisée (on verra les règles…) \n\nPOO-L3 H. Fauconnier \n99 \nSurcharge \no  Un même nom de fonction pour \nplusieurs fonctions qui sont distinguées \npar leur signature \n(Java, C++, Ada permettent la surcharge) \nEn C ’/’ est surchargé \n 3/2 division entière -> 1 \n 3.0/2 division réelle -> 1,5 \n\nPOO-L3 H. Fauconnier \n100 \nSurcharge \n public int f(int i){ \n        return i; \n    } \n//    public double f(int i){ \n//        return Math.sqrt( i); \n//    } \n    public int f(double i){ \n        return (int) Math.sqrt( i); \n    } \n    public int f(char c){ \n        return c; \n    } \n\nPOO-L3 H. Fauconnier \n101 \nRemarques \no  La résolution de la surcharge a lieu à la \ncompilation \no  La signature doit permettre cette résolution \no  (quelques complications du fait du \ntranstypage: \nn  Exemple: un char est converti en int \nn  Exemple: upcasting \n) \n\nPOO-L3 H. Fauconnier \n102 \nC) Méthodes: Redéfinition \no  Un classe hérite des méthodes des \nclasses ancêtres \no  Elle peut ajouter de nouvelles méthodes \no  Elle peut surcharger des méthodes \no  Elle peut aussi redéfinir des méthodes \ndes ancêtres. \n\nPOO-L3 H. Fauconnier \n103 \nExemple \nclass Mere{ \n    void f(int i){ \n        System.out.println(\"f(\"+i+\") de Mere\"); \n    } \n    void f(String st){ \n        System.out.println(\"f(\"+st+\") de Mere\"); \n    } \n} \n\nPOO-L3 H. Fauconnier \n104 \nExemple (suite) \nclass Fille extends Mere{ \n    void f(){ //surcharge \n        System.out.println(\"f() de Fille\"); \n    } \n//  char f(int i){ \n// même signature mais type de retour différent \n//   } \n    void g(){ //nouvelle méthode \n        System.out.println(\"g() de Fille\"); \n        f(); \n        f(3); \n        f(\"bonjour\"); \n    } \n    void f(int i){ // redéfinition \n        System.out.println(\"f(\"+i+\") de Fille\");       \n    } \n} \n\nPOO-L3 H. Fauconnier \n105 \nExemple \n public static void main(String[] args) { \n \n        Mere m=new Mere(); \n        Fille f=new Fille(); \n        m.f(3); \n        f.f(4); \n        m=f; \n        m.f(5); \n        //m.g(); \n        ((Fille)m).g(); \n        f.g(); \n    } \n\nPOO-L3 H. Fauconnier \n106 \nRésultat \nf(3) de Mere \nf(4) de Fille \nf(5) de Fille \ng() de Fille \nf() de Fille \nf(3) de Fille \nf(bonjour) de Mere \ng() de Fille \nf() de Fille \nf(3) de Fille \nf(bonjour) de Mere \n\nPOO-L3 H. Fauconnier \n107 \nD) Conséquences \no  Et les variables?  \nn  Un principe: \no \nUne méthode (re)définie dans une classe A ne \npeut être évaluée que dans le contexte des \nvariables définies dans la classe A. \nn \nPourquoi? \n\nPOO-L3 H. Fauconnier \n108 \nExemple \nclass A{ \n    public int i=4; \n    public void f(){ \n        System.out.println(\"f() de A, i=\"+i); \n    } \n    public void g(){ \n        System.out.println(\"g() de A, i=\"+i); \n    } \n} \nclass B extends A{ \n    public int i=3; \n    public void f(){ \n        System.out.println(\"f() de B, i=\"+i); \n        g(); \n    } \n} \n\nPOO-L3 H. Fauconnier \n109 \nExemple suite: \nA a=new B(); \na.f(); \nSystem.out.println(\"a.i=\"+a.i); \nSystem.out.println(\"((B) a).i=\"+((B)a).i); \n \nDonnera: \nn \nf() de B, i=3 \nn \ng() de A, i=4 \nn \na.i=4 \nn \n((B) a).i=3 \n \n \n \n\nPOO-L3 H. Fauconnier \n110 \nRemarques: \no  La variable i de A est occultée par la variable \ni de B \no  La variable i de A est toujours présente dans \ntout objet de B \no  Le méthode g de A a accès à toutes les \nvariables définies dans A (et uniquement à \ncelles-là) \no  La méthode f de B redéfinit f. f() redéfinie a \naccès à toutes les variables définies dans B \n\nPOO-L3 H. Fauconnier \n111 \nE) Divers \no  super \nn  Le mot clé super permet d’accéder aux \nméthodes de la super classe \no \nEn particulier super permet d’appeler dans \nune méthode redéfinie la méthode d’origine \n  (exemple: super.finalize() appelé dans une \nméthode qui redéfinit le finalize permet \nd'appeler le finalize de la classe de base) \n\nPOO-L3 H. Fauconnier \n112 \nExemple \nclass Base{ \n    protected String nom(){ \n        return \"Base\"; \n    } \n} \nclass Derive extends Base{ \n    protected String nom(){ \n        return \"Derive\"; \n    } \n    protected void print(){ \n        Base maref = (Base) this; \n        System.out.println(\"this.name():\"+this.nom()); \n        System.out.println(\"maref.name():\"+maref.nom()); \n        System.out.println(\"super.name():\"+super.nom()); \n    } \n------------- \nthis.name():Derive \nmaref.name():Derive \nsuper.name():Base \n \n\nPOO-L3 H. Fauconnier \n113 \nContrôle d’accès \no  protected: accès dans les classes dérivées \no  Le contrôle d’accès ne concerne pas la \nsignature  \no  Une méthode redéfinie peut changer le \ncontrôle d’accès mais uniquement pour \nélargir l’accès (de protected à public) \no  Le contrôle d’accès est vérifié à la \ncompilation \n\nPOO-L3 H. Fauconnier \n114 \nInterdire la redéfinition \no  Le modificateur final interdit la \nredéfinition pour une méthode \no  (Bien sûr une méthode de classe ne peut \npas être redéfinie! Mais, elle peut être \nsurchargée) \no  Une variable avec modificateur final \npeut être occultée \n\nPOO-L3 H. Fauconnier \n115 \nE) Constructeurs et héritage \no  Le constructeurs ne sont pas des méthodes \ncomme les autres: \nn   le redéfinition n’a pas de sens. \no  Appeler un constructeur dans un \nconstructeur: \nn  super() appelle le constructeur de la super classe \nn  this() appelle le constructeur de la classe elle-\nmême \nn  Ces appels doivent se faire au début du code du \nconstructeur \n\nPOO-L3 H. Fauconnier \n116 \nConstructeurs  \no  Principes: \nn \nQuand une méthode d’instance est \nappelée l’objet est déjà créé. \nn \nCréation de l’objet (récursivement) \n1. \nInvocation du constructeur de la super classe \n2. \nInitialisations des champs par les \ninitialisateurs et les blocs d’initialisation \n3. \nUne fois toutes ces initialisations faites, appel \ndu corps du constructeur (super() et this() ne \nfont pas partie du corps) \n\nPOO-L3 H. Fauconnier \n117 \nExemple \nclass X{ \n    protected int xMask=0x00ff; \n    protected int fullMask; \n    public X(){ \n        fullMask = xMask; \n    } \n    public int mask(int orig){ \n    return (orig & fullMask); \n    } \n} \nclass Y extends X{ \n    protected int yMask = 0xff00; \n    public Y(){ \n        fullMask |= yMask; \n    } \n} \n\nPOO-L3 H. Fauconnier \n118 \nRésultat \nxMask \nyMask \nfullMask \nVal. par défaut des champs \n0 \n0 \n0 \nAppel Constructeur pour Y \n0 \n0 \n0 \nAppel Constructeur pour X \n0 \n0 \n0 \nInitialisation champ X \n0x00ff \n0 \n0 \nConstructeur X \n0x00FF \n0 \n0x00FF \nInitialisation champs de Y \n0x00FF \n0xFF00 \n0x00FF \nConstructeur Y \n0x00FF \n0xFF00 \n0xFFFF \n\nPOO-L3 H. Fauconnier \n119 \nLa classe Object \no  Toutes les classes héritent de la classe \nObject \no  méthodes: \nn  public final Class<? extends Object> getClass()  \nn  public int hashCode()  \nn  public boolean equals(Object obj) \nn  protected Object clone() throws \nCloneNotSupportedException \nn  public String toString() \nn  protected void finalize() throws Throwable  \nn  (wait, notify,notfyall) \n\nPOO-L3 H. Fauconnier \n120 \nExemple \nclass A{ \n    int i; \n    int j; \n    A(int i,int j){ \n        this.i=i;this.j=j;} \n} \nclass D <T>{ \n    T i; \n    D(T i){ \n        this.i=i; \n    } \n} \n\nPOO-L3 H. Fauconnier \n121 \nSuite \npublic static void main(String[] args) { \n    A a=new A(1,2); \n    A b=new A(1,2); \n    A c=a; \n    if (a==b) \n        System.out.println(\"a==b\"); \n    else \n        System.out.println(\"a!=b\"); \n    if (a.equals(b)) \n        System.out.println(\"a equals b\"); \n    else \n         System.out.println(\"a not equals b\"); \n    System.out.println(\"Objet a: \"+a.toString()+\" classe \"+a.getClass()); \n    System.out.println(\"a.hashCode()\"+a.hashCode()); \n    System.out.println(\"b.hashCode()\"+b.hashCode()); \n    System.out.println(\"c.hashCode()\"+c.hashCode()); \n    D <Integer> x=new D<Integer>(10); \n    System.out.println(\"Objet x: \"+x.toString()+\" classe \"+x.getClass()); \n} \n\nPOO-L3 H. Fauconnier \n122 \nRésultat: \no  a!=b \no  a not equals b \no  Objet a: A@18d107f classe class A \no  a.hashCode()26022015 \no  b.hashCode()3541984 \no  c.hashCode()26022015 \no  Objet x: D@ad3ba4 classe class D \n\nPOO-L3 H. Fauconnier \n123 \nEn redéfinissant equals \nclass B{ \n    int i; \n    int j; \n    B(int i,int j){ \n        this.i=i;this.j=j; \n    } \n    public boolean equals(Object o){ \n        if (o instanceof B) \n            return i==((B)o).i && j==((B)o).j; \n        else return false; \n    } \n} \n\nPOO-L3 H. Fauconnier \n124 \nSuite \n        B d=new B(1,2); \n        B e=new B(1,2); \n        B f=e; \n        if (d==e) \n            System.out.println(\"e==d\"); \n        else \n            System.out.println(\"d!=e\"); \n        if (d.equals(e)) \n            System.out.println(\"d equals e\"); \n        else \n            System.out.println(\"a not equals b\"); \n        System.out.println(\"Objet d: \"+d.toString()); \n        System.out.println(\"Objet e: \"+e.toString()); \n        System.out.println(\"d.hashCode()\"+d.hashCode()); \n        System.out.println(\"e.hashCode()\"+e.hashCode());      \no \n     \n\nPOO-L3 H. Fauconnier \n125 \nRésultat: \no  d!=e \no  d equals e \no  Objet d: B@182f0db \no  Objet e: B@192d342 \no  d.hashCode()25358555 \no  e.hashCode()26399554 \n\nChapitre IV \nInterfaces, classes imbriquées, Object \n\nPOO-L3 H. Fauconnier \n127 \nChapitre IV \n1. \nInterfaces \n2. \nClasses imbriquées \n3. \nObjets, clonage \n\nPOO-L3 H. Fauconnier \n128 \nclasses abstraites \nabstract class Benchmark{ \n    abstract void benchmark(); \n    public final long repeat(int c){ \n        long start =System.nanoTime(); \n        for(int i=0;i<c;i++) \n            benchmark(); \n        return (System.nanoTime() -start); \n    }     \n} \nclass MonBenchmark extends Benchmark{ \n    void benchmark(){ \n    } \n    public static long mesurer(int i){ \n        return new MonBenchmark().repeat(i); \n         \n    } \n} \n\nPOO-L3 H. Fauconnier \n129 \nsuite \npublic static void main(String[] st){ \n System.out.println(\"temps=\"+ \n \n \n MonBenchmark.mesurer(1000000)); \n    }  \n \nRésultat: \ntemps=6981893 \n \n\nPOO-L3 H. Fauconnier \n130 \nInterfaces \no  Il n'y a pas d'héritage multiple en Java: une \nclasse ne peut être l'extension que d'une \nseule classe \no  Par contre une classe peut implémenter \nplusieurs interfaces (et être l'extension \nd'une seule classe) \no  Une interface ne contient (essentiellement) \nque des déclarations de méthodes  \no  Une interface est un peu comme une classe \nsans données membres et dont toutes les \nméthodes seraient abstraites \n\nPOO-L3 H. Fauconnier \n131 \nHéritage \"multiple\" en java \n\nPOO-L3 H. Fauconnier \n132 \nExemple: \ninterface Comparable<T>{ \n    int compareTo(T obj); \n} \nclass Couple implements Comparable<Couple>{ \n    int x,y; \n    // \n    public int compareTo(Couple c){ \n        if(x<c.x)return 1; \n        else if (c.x==x) \n            if (c.y==y)return 0; \n        return -1; \n    } \n} \n\nPOO-L3 H. Fauconnier \n133 \nRemarques… \no  Pourquoi, a priori, l'héritage multiple \nest plus difficile à implémenter que \nl'héritage simple? \no  Pourquoi, a priori, implémenter plusieurs \ninterfaces ne pose pas (trop) de \nproblèmes? \no  (Comment ferait-on dans un langage \ncomme le C?) \n\nPOO-L3 H. Fauconnier \n134 \nQuelques interfaces… \no  Cloneable: est une interface vide(!) un \nobjet qui l'implémente peut redéfinir la \nméthode clone \no  Comparable: est une interface qui permet \nde comparer les éléments (méthode \ncompareTo) \no  runnable: permet de définir des \"threads\" \no  Serializable: un objet qui l'implémente \npeut être \"sérialisé\" = converti en une suite \nd'octets pour être sauvegarder. \n\nPOO-L3 H. Fauconnier \n135 \nDéclarations \no  une interface peut déclarer: \nn  des constantes (toutes les variables \ndéclarées sont static public et final) \nn  des méthodes (elles sont implicitement \nabstract) \nn  des classes internes et des interfaces \n\nPOO-L3 H. Fauconnier \n136 \nExtension \nles interfaces peuvent être étendues avec \nextends: \no  Exemple: \npublic interface SerializableRunnable \nextends Serializable, Runnable; \n(ainsi une interface peut étendre de plusieurs façons \nune même interface, mais comme il n'y a pas \nd'implémentation de méthodes et uniquement des \nconstantes ce n'est pas un problème) \n\nPOO-L3 H. Fauconnier \n137 \nExemple \ninterface X{ \n    int val=0; \n} \ninterface Y extends X{ \n    int val=1; \n    int somme=val+X.val; \n} \nclass Z implements Y{} \n \npublic class InterfaceHeritage { \n    public static void main(String[] st){ \n        System.out.println(\"Z.val=\"+Z.val+\" Z.somme=\"+Z.somme); \n        Z z=new Z(); \n         System.out.println(\"z.val=\"+z.val+ \n                 \" ((Y)z).val=\"+((Y)z).val+ \n                 \" ((X)z).val=\"+((X)z).val); \n    }     \n} \n--------------- \nZ.val=1 Z.somme=1 \nz.val=1 ((Y)z).val=1 ((X)z).val=0 \n \n\nPOO-L3 H. Fauconnier \n138 \nRedéfinition, surcharge \ninterface A{ \n    void f(); \n    void g(); \n} \ninterface B{ \n    void f(); \n    void f(int i); \n    void h(); \n} \ninterface C extends A,B{} \n \nRien n'indique que les deux méthodes void f() ont la même \n\"sémantique\". Comment remplir le double contrat? \n\nPOO-L3 H. Fauconnier \n139 \nChapitre IV \n1. \nInterfaces \n2. \nClasses internes et imbriquées \n3. \nObject, clonage \n\nPOO-L3 H. Fauconnier \n140 \nClasses imbriquées  (nested \nclasses) \no  Classes membres statiques \nn  membres statiques d'une autre classe \no  Classes membres ou classes internes (inner \nclasses) \nn  membres d'une classe englobante \no  Classes locales \nn  classes définies dans un bloc de code \no  Classes anonymes \nn  classes locales sans nom \n\nPOO-L3 H. Fauconnier \n141 \nClasse imbriquée statique  \no  membre statique d'une autre classe \nn  classe ou interface \nn  mot clé static \nn  similaire aux champs ou méthodes \nstatiques: n'est pas associée à une \ninstance et  accès uniquement aux champs \nstatiques \n  \n \n\nPOO-L3 H. Fauconnier \n142 \nExemple \nclass PileChainee{ \n        public static interface Chainable{ \n                public Chainable getSuivant(); \n                public void setSuivant(Chainable noeud); \n        } \n        Chainable tete; \n        public void empiler(Chainable n){ \n            n.setSuivant(tete); \n            tete=n; \n        } \n        public Object depiler(){ \n            Chainable tmp; \n            if (!estVide()){ \n                tmp=tete; \n                tete=tete.getSuivant(); \n                return tmp; \n            } \n            else return null; \n        } \n        public boolean estVide(){ \n            return tete==null; \n        } \n} \n\nPOO-L3 H. Fauconnier \n143 \nexemple (suite) \nclass EntierChainable implements PileChainee.Chainable{ \n    int i; \n    public EntierChainable(int i){this.i=i;} \n    PileChainee.Chainable next; \n    public PileChainee.Chainable getSuivant(){ \n        return next; \n    } \n    public void setSuivant(PileChainee.Chainable n){ \n        next=n; \n    }  \n    public int val(){return i;}        \n} \n\nPOO-L3 H. Fauconnier \n144 \net le main \n public static void main(String[] args) { \n        PileChainee p; \n        EntierChainable n; \n        p=new PileChainee(); \n        for(int i=0; i<12;i++){ \n            n=new EntierChainable(i); \n            p.empiler(n); \n        } \n        while (!p.estVide()){ \n            System.out.println( \n \n \n \n ((EntierChainable)p.depiler()).val());          \n        } \n    } \n\nPOO-L3 H. Fauconnier \n145 \nRemarques \no  Noter l'usage du nom hiérarchique avec \n'.' \no  On peut utiliser un import: \nn  import PileChainee.Chainable; \nn  import PileChainee; \n \n(Exercice: réécrire le programme précédent \nsans utiliser de classes membres \nstatiques) \n\nPOO-L3 H. Fauconnier \n146 \nClasse membre \no  membre non statique d'une classe englobante \no  peut accéder aux champs et méthodes de \nl'instance \no  une classe interne ne peut pas avoir de \nmembres statiques \no  un objet d'une classe interne est une partie \nd'un objet de la classe englobante \n\nPOO-L3 H. Fauconnier \n147 \nExemple \nclass CompteBanquaire{ \n    private long numero; \n    private long balance; \n    private Action der; \n    public class Action{ \n        private String act; \n        private long montant; \n        Action(String act, long montant){ \n            this.act=act; \n            this.montant= montant; \n        } \n        public String toString(){ \n            return numero\"+\":\"+act+\" \"+montant; \n        } \n    } \n\nPOO-L3 H. Fauconnier \n148 \nSuite \n //… \n    public void depot(long montant){ \n        balance += montant; \n        der=new Action(\"depot\",montant); \n    } \n    public void retrait(long montant){ \n        balance -= montant; \n        der=new Action(\"retrait\",montant); \n    } \n     \n} \n\nPOO-L3 H. Fauconnier \n149 \nRemarques \no  numero dans toString \no  this:  \nn  der=this.new Action(…); \nn  CompteBancaire.this.numero \n\nPOO-L3 H. Fauconnier \n150 \nClasse interne et héritage \nclass Externe{ \n    class Interne{} \n} \nclass ExterneEtendue extends Externe{ \n    class InterneEtendue extends Interne{} \n    Interne r=new InterneEtendue(); \n} \nclass Autre extends Externe.Interne{ \n    Autre(Externe r){ \n        r.super(); \n    } \n} \n(un objet Interne (ou d'une de ses extensions) n'a de sens qu'à \nl'intérieur d'un objet Externe) \n\nPOO-L3 H. Fauconnier \n151 \nQuelques petits problèmes \nclass X{ \n    int i; \n    class H extends Y{ \n        void incremente(){i++;} \n    } \n} \nSi i est une donnée membre de Y… c'est ce i qui est \nincrémenté \nX.this.i et this.i lèvent cette ambiguïté. \n\nPOO-L3 H. Fauconnier \n152 \nSuite \nclass H{ \n    void print(){} \n    void print(int i){} \n    class I{ \n        void print(){}; \n        void show(){ \n            print(); \n            H.this.print(); \n        // print(1); tous les print sont occultés \n        } \n    } \n} \n\nPOO-L3 H. Fauconnier \n153 \nClasses locales \no  classes définies à l'intérieur d'un bloc de \ncode, \no  analogue à des variables locales: une classe \ninterne locale n'est pas membre de la classe \net donc pas d'accès, \no  usage: créer des instances qui peuvent être \npassées en paramètres \no  usage: créer des objets d'une extension \nd'une classe qui n'a de sens que localement \n(en particulier dans les interfaces \ngraphiques) \n\nPOO-L3 H. Fauconnier \n154 \nExemple \no  classes Collections (ou Containers): \nclasses correspondant à des structures \nde données.  \nn  exemples: List, Set, Queue,  Map. \no  L'interface Iterator permet de \nparcourir tous les éléments composant \nune structure de données. \n \n \n\nPOO-L3 H. Fauconnier \n155 \nIterator \npublic interface Iterator<E>{ \n    boolean hasNext(); \n    E next() throws NoSuchElementException; \n    void remove()throws  \n \n \n \n \n UnsupportedOperationException,           \n \n IllegalStateException; \n} \n \n\nPOO-L3 H. Fauconnier \n156 \nExemple: MaCollection \nclass MaCollection implements Iterator<Object>{ \n    Object[] data; \n    MaCollection(int i){ \n        data=new Object[i]; \n    } \n    MaCollection(Object ... l){ \n        data=new Object[l.length]; \n        for(int i=0;i<l.length;i++) \n            data[i]=l[i]; \n    } \n    private int pos=0; \n    public boolean hasNext(){ \n        return (pos <data.length); \n    } \n    public Object next() throws NoSuchElementException{ \n        if (pos >= data.length) \n            throw new NoSuchElementException(); \n        return data[pos++]; \n    } \n    public void remove(){ \n        throw new  UnsupportedOperationException(); \n    } \n} \n\nPOO-L3 H. Fauconnier \n157 \nEt une iteration: \npublic class Main { \n    public static void afficher(Iterator it){ \n        while(it.hasNext()){ \n            System.out.println(it.next()); \n        } \n    } \n    public static void main(String[] args) { \n        MaCollection m=new MaCollection(1,2,3,5,6,7); \n        afficher(m); \n    }     \n} \n\nPOO-L3 H. Fauconnier \n158 \nClasse locale \no  Au lieu de créer d'implémenter \nIterator on pourrait aussi créer une \nméthode qui retourne un iterateur. \n\nPOO-L3 H. Fauconnier \n159 \nExemple parcourir \n public static Iterator<Object> parcourir(final Object[] data){ \n        class Iter implements Iterator<Object>{ \n            private int pos=0; \n            public boolean hasNext(){ \n                return (pos <data.length); \n            } \n            public Object next() throws NoSuchElementException{ \n                if (pos >= data.length) \n                    throw new NoSuchElementException(); \n                return data[pos++]; \n            } \n            public void remove(){ \n                throw new  UnsupportedOperationException(); \n            } \n        } \n        return new Iter(); \n    } \n\nPOO-L3 H. Fauconnier \n160 \net l'appel \nInteger[] tab=new Integer[12]; \n//… \nafficher(parcourir(tab)); \n\nPOO-L3 H. Fauconnier \n161 \nRemarques \no  parcourir() retourne un itérateur pour le \ntableau passé en paramètre. \no  l'itérateur implémente Iterator \nn  mais dans une classe locale à la méthode \nparcourir \nn  la méthode parcourir retourne un objet de \ncette classe. \no  data[] est déclaré final:  \nn  même si tous les objets locaux sont dans la portée \nde la classe locale, la classe locale ne peut \naccéder aux variables locales que si elles sont \ndéclarées final. \n\nPOO-L3 H. Fauconnier \n162 \nAnonymat… \no  mais était-il utile de donner un nom à \ncette classe qui ne sert qu'à créer un \nobjet Iter? \n\nPOO-L3 H. Fauconnier \n163 \nClasse anonyme \n public static Iterator<Object> parcourir1( final Object[] data){ \n            return new Iterator<Object>(){ \n            private int pos=0; \n            public boolean hasNext(){ \n                return (pos <data.length); \n            } \n            public Object next() throws NoSuchElementException{ \n                if (pos >= data.length) \n                    throw new NoSuchElementException(); \n                return data[pos++]; \n            } \n            public void remove(){ \n                throw new  UnsupportedOperationException(); \n            } \n        }; \n    } \n\nPOO-L3 H. Fauconnier \n164 \nExemple interface graphique: \n jButton1.addActionListener(new ActionListener(){ \n    public void actionPerformed(ActionEvent evt){\n  \n \n jButton1ActionPerformed(evt); \n    } \n  }); \n \n\nPOO-L3 H. Fauconnier \n165 \nPrincipe… \no  ActionListener est une interface qui \ncontient une seule méthode \nn  void actionPerformed(ActionEvent e)  \nn  cette méthode définit le comportement \nvoulu si on presse le bouton \no  Il faut que le Button jButton1 associe \nl'événement correspondant au fait que \nle bouton est pressé  l'ActionListener \nvoulu: addActionListener \n\nPOO-L3 H. Fauconnier \n166 \nDans l'exemple \n1. \njButton1ActionPerformed est la méthode qui \ndoit être activée \n2. \nCréation d'un objet de type ActionListener: \n1. \n(Re)définition de ActionPerformed dans l'interface \nActionListener: appel de jButton1ActionPerformed \n2. \nclasse anonyme pour ActionListener \n3. \noperateur new \n3. \najout de cet ActionListener comme écouteur des \névénements de ce bouton \njButton1.addActionListener \n\nPOO-L3 H. Fauconnier \n167 \nChapitre IV \n1. \nInterfaces \n2. \nClasses imbriquées \n3. \nObjets, clonage \n\nPOO-L3 H. Fauconnier \n168 \nLe clonage \no  les variables sont des références sur \ndes objets -> l'affectation ne modifie \npas l'objet \no  la méthode clone retourne un nouvel \nobjet dont la valeur initiale est une \ncopie de l'objet \n \n \n\nPOO-L3 H. Fauconnier \n169 \nPoints techniques \no  Par défaut la méthode clone de Object \nduplique les champs de l'objet (et dépend \ndonc de la classe de l'objet) \no  L'interface Cloneable doit être \nimplémentée pour pouvoir utiliser la méthode \nclone de Object \nn  Sinon la méthode clone de Object lance une \nexception CloneNotSupportedException \no  De plus, la méthode clone est protected -> \nelle ne peut être utilisée que dans les \nméthodes définies dans la classe ou ses \ndescendantes (ou dans le même package). \n\nPOO-L3 H. Fauconnier \n170 \nEn conséquence \no \nen implémentant Cloneable, Object.clone() est \npossible pour la classe et les classes descendantes  \nn \nSi CloneNotSupportedException est captée, le clonage \nest possible pour la classe et les descendants \nn \nSi on laisse passer CloneNotSupportedException, le \nclonage peut être possible pour la classe (et les \ndescendants) (exemple dans  une collection le clonage sera \npossible si les éléments de la collection le sont)  \no \nen n'implémentant pas Cloneable, \nObject.clone() lance uniquement l’exception, \n en définissant une méthode clone qui lance  une \nCloneNotSupportedException, le clonage n'est \nplus possible \n\nPOO-L3 H. Fauconnier \n171 \nExemple \nclass A implements Cloneable{ \n    int i,j; \n    A(int i,int j){ \n        this.i=i; this.j=j; \n    } \n    public String toString(){ \n        return \"(i=\"+i+\",j=\"+j+\")\"; \n    } \n    protected Object clone()  \n \n throws CloneNotSupportedException{ \n        return super.clone(); \n    }  \n} \n\nPOO-L3 H. Fauconnier \n172 \nSuite \n        A a1=new A(1,2); \n        A a2=null; \n        try {// nécessaire! \n            a2 =(A) a1.clone(); \n        } catch (CloneNotSupportedException ex) { \n            ex.printStackTrace(); \n        } \ndonnera: \na1=(i=1,j=2) a2=(i=1,j=2) \n \n \n\nPOO-L3 H. Fauconnier \n173 \nSuite \nclass D extends A{ \n    int k; \n    D(int i,int j){  \n        super(i,j); \n        k=0; \n    } \n     public String toString(){ \n        return (\"(k=\"+k+\")\"+super.toString()); \n     } \n} \n//… \n     D d1=new D(1,2); \n     D d2=null; \n     try { //nécessaire \n            d2=(D) d1.clone(); \n     } catch (CloneNotSupportedException ex) { \n            ex.printStackTrace(); \n      } \n     System.out.println(\"d1=\"+d1+\" d2=\"+d2); \n} \n\nRemarques \no   super.clone();dans A est \nnécessaire il duplique tous les champs \nd'un objet de D \no  Pour faire un clone d'un objet D il faut \ncapter l'exception. \nPOO-L3 H. Fauconnier \n174 \n\nPOO-L3 H. Fauconnier \n175 \nSuite \nclass B implements Cloneable{ \n    int i,j; \n    B(int i,int j){ \n        this.i=i; this.j=j; \n    } \n    public String toString(){ \n        return \"(i=\"+i+\",j=\"+j+\")\"; \n    } \n     \n    protected Object clone(){ \n        try { \n            return super.clone(); \n        } catch (CloneNotSupportedException ex) { \n            ex.printStackTrace(); \n            return null; \n        } \n    } \n} \n\nPOO-L3 H. Fauconnier \n176 \nSuite \nclass C extends B{ \n    int k; \n    C(int i,int j){ \n        super(i,j); \n        k=0; \n    } \n    public String toString(){ \n        return (\"(k=\"+k+\")\"+super.toString()); \n    } \n}//... \n B b1=new B(1,2); \n B b2 =(B) b1.clone(); \n C c1=new C(1,2); \n C c2 =(C) c1.clone(); \n         \n\nPOO-L3 H. Fauconnier \n177 \nPourquoi le clonage? \no  Partager ou copier? \no  Copie profonde ou superficielle? \nn  par défaut la copie est superficielle:  \n\nPOO-L3 H. Fauconnier \n178 \nExemple \nclass IntegerStack implements Cloneable{ \n    private int[] buffer; \n    private int sommet; \n    public IntegerStack(int max){ \n        buffer=new int[max]; \n        sommet=-1; \n    } \n    public void empiler(int v){ \n        buffer[++sommet]=v; \n    } \n    public int dépiler(){ \n        return buffer[sommet--]; \n    } \n    public IntegerStack clone(){ \n        try{ \n            return (IntegerStack)super.clone(); \n        }catch(CloneNotSupportedException e){ \n            throw new InternalError(e.toString()); \n        } \n    } \n} \n\nPOO-L3 H. Fauconnier \n179 \nProblème: \nIntegerStack un=new IntegerStack(10); \nun.emplier(3); \nun.empiler(9) \nInetegerStack deux=un.clone(); \n \nLes deux piles partagent les mêmes données… \n\nPOO-L3 H. Fauconnier \n180 \nSolution… \n public IntegerStack clone(){ \n   try{ \n      IntegerStack nObj = (IntegerStack)super.clone(); \n      nObj.buffer=buffer.clone(); \n      return nObj; \n   }catch(CloneNotSupportedException e){ \n        //impossible \n        throw new InternalError(e.toString()); \n    } \n  } \n\nPOO-L3 H. Fauconnier \n181 \nCopie profonde \npublic class CopieProfonde implements Cloneable{ \n    int val; \n    CopieProfonde n=null; \n    public CopieProfonde(int i) { \n        val=i; \n    } \n    public CopieProfonde(int i, CopieProfonde n){ \n        this.val=i; \n        this.n=n; \n    } \n    public Object clone(){ \n        CopieProfonde tmp=null; \n        try{ \n            tmp=(CopieProfonde)super.clone(); \n            if(tmp.n!=null) \n                tmp.n=(CopieProfonde)(tmp.n).clone(); \n        }catch(CloneNotSupportedException ex){} \n        return tmp; \n    } \n} \n\nPOO-L3 H. Fauconnier \n182 \nSuite \nclass essai{ \n    static void affiche(CopieProfonde l){ \n        while(l!=null){ \n            System.out.println(l.val+\" \"); \n            l=l.n; \n        } \n    } \n    public static void main(String[] st){ \n        CopieProfonde l=new CopieProfonde(0); \n        CopieProfonde tmp; \n        for(int i=0;i<10;i++){ \n            tmp=new CopieProfonde(i,l); \n            l=tmp; \n        } \n        affiche(l); \n        CopieProfonde n=(CopieProfonde)l.clone(); \n        affiche(n); \n    } \n} \n\nChapitre V \nEnumeration, tableaux, conversion de types, \nnoms \n\nhéritage \nPOO-L3 H. Fauconnier \n184 \nTypes énumérés \no  Exemple: \nn \nenum Couleur {PIQUE, CŒUR, CARREAU, TREFLE,} \nn \ndéfinit des constantes énumérées (champs static de la \nclasse) \nn \non peut définir des méthodes dans un enum \nn \ndes méthodes \no \npublic static E[] values() retourne les constantes dans l'ordre \nde leur énumeration \no \npublic static E valueOf(String nom) la constante associé au \nnom \nn \nun type enum étend implicitement java.lang.Enum (aucune \nclasse ne peut étendre cette classe) \n\nhéritage \nPOO-L3 H. Fauconnier \n185 \nTableaux \no  collection ordonnée d'éléments, \no  les tableaux sont des Object \no  les composants peuvent être de types \nprimitifs, des références à des objets \n(y compris des références à des \ntableaux), \n\nhéritage \nPOO-L3 H. Fauconnier \n186 \nTableaux \no  int [] tab= new int t[3]; \nn  déclaration d'un tableau d'int \nn  initialisé à un tableau de 3 int \no  indices commencent à 0 \no  contrôle de dépassement \nn  ArrayIndexOutOfBoundException \no  length donne la taille du tableau \n\nhéritage \nPOO-L3 H. Fauconnier \n187 \nTableaux \no \nun tableau final: la référence ne peut être changée \n(mais le tableau référencé peut l'être) \no \ntableaux de tableaux: \no \nexemple: \n public static int[][] duplique(int[][] mat){ \n        int[][] res= new int[mat.length][]; \n        for(int i=0;i<mat.length;i++){ \n            res[i]=new int[mat[i].length]; \n            for (int j=0;j<mat[i].length;j++) \n                res[i][j]=mat[i][j]; \n        } \n        return res; \n    } \n\nhéritage \nPOO-L3 H. Fauconnier \n188 \nTableaux \no  exemple: \n public static void affiche(int [][] tab){ \n        for(int[] d:tab){ \n            System.out.println(); \n            for(int v:d) \n                System.out.print(v+\" \"); \n        } \n    } \n\nhéritage \nPOO-L3 H. Fauconnier \n189 \nInitialisations \n static int[][] pascal={ \n        {1}, \n        {1,1}, \n        {1,2,1}, \n        {1,3,3,1},         \n    }; \n String[] nombre= {\"un\", \"deux\", \"trois\", \"quatre\"}; \n\nhéritage \nPOO-L3 H. Fauconnier \n190 \nExemple \n for(int i=1;i<p.length;i++){ \n      p[i]=new int[i+1]; \n      p[i][0]=1; \n      for(int j=1; j<i;j++){ \n          p[i][j]=p[i-1][j-1]+p[i-1][j]; \n      } \n      p[i][i]=1; \n } \n\nhéritage \nPOO-L3 H. Fauconnier \n191 \nTableau et héritage \no \nY[] yA=new Y[3]; \no \nX[] xA=yA; //ok \no \nxA[0]=new Y(); \no \nxA[1]=new X(); //non \no \nxA[1]=new Z(); //non \nObject \nX \nX[] \nint[] \nY \nZ \nY[] \nZ[] \n\nhéritage \nPOO-L3 H. Fauconnier \n192 \nNoms \no  il ya 6 espaces de noms \nn  package \nn  type \nn  champs \nn  méthode \nn  variable locale \nn  étiquette \n\nhéritage \nPOO-L3 H. Fauconnier \n193 \nNoms!? \npackage divers; \nclass divers{ \n    divers divers(divers divers){ \n        divers: \n            for(;;){ \n            if (divers.divers(divers)==divers) \n                break divers; \n            } \n            return divers; \n    } \n} \n\nhéritage \nPOO-L3 H. Fauconnier \n194 \nTrouver la bonne méthode \no  Il faut pouvoir déterminer une seule \nméthode à partir d'une invocation avec \ndes paramètres \no  problèmes: héritage et surcharge \nn  (en plus des problèmes liés à la généricité) \no  principe trouver la méthode \"la plus \nspécifique\" \n\nhéritage \nPOO-L3 H. Fauconnier \n195 \nRègles \n1. \ndéterminer dans quelle classe chercher la méthode \n(uniquement par le nom) \n2. \ntrouver les méthodes dans la classe qui peuvent \ns'appliquer \n1. \nsans \"boxing\" sans nombre variable d'arguments \n2. \navec boxing \n3. \navec un nombre variable d'arguments \n3. \nsi une méthode a des types de paramètres qui \npeuvent être affectés à une autre des méthodes de \nl'ensemble -> la supprimer \n4. \ns'il ne reste qu'une méthode c'est elle (sinon \nambiguïté sauf s'il s'agit de méthodes abstraites) \n\nhéritage \nPOO-L3 H. Fauconnier \n196 \nExemple \nvoid f(A a,AD2 ad2)//un \nvoid f(AD1 ad1,A a)//deux \nvoid f(ADD1 add1, AD2 s)//trois \nvoid f(A … a)//quatre \n \nf(Aref, AD2ref);//a \nf(ADD1ref, Aref);//b \nf(ADD1ref, ADD2ref);//c \nf(AD1ref, AD2ref);//d \nf(AD2ref, AD1ref);//e \nA \nAD1 \nAD2 \nADD1 \nADD2 \n\nhéritage \nPOO-L3 H. Fauconnier \n197 \nExemple (suite) \no  (a) correspond exactement à (un) \no  (b) correspond à (deux) \no  (c) peut correspondre aux trois \npremiers mais (un) est moins spécifique \nque (trois) idem entre (un) et (trois) \nd'où résultat (trois) \no  (d) (un) et (deux) ne peuvent s'éliminer \no  (e) uniquement (quatre) \n\nChapitre VI \nExceptions \n\nPOO-L3 H. Fauconnier \n199 \nVI) Exceptions \n1. \nPrincipes généraux \n2. \nDéclarations de throws \n3. \ntry, catch et finally \n4. \nTransfert d'information: chainage, pile \n5. \nAssertions \n\nPOO-L3 H. Fauconnier \n200 \nExceptions et assertions \no  principe: \nn  traitement des \"erreurs\" \no \nquand une exception est lancée: \nn \nrupture de l'exécution séquentielle \nn \n\"dépiler\" les méthodes et les blocs \nn \njusqu'à un traite exception adapté \nn  erreur: \no \nrupture du contrat: \nn \nprécondition violée \n \n\nPOO-L3 H. Fauconnier \n201 \nExceptions \no  checked ou unchecked \nn  checked: cas exceptionnel, mais dont l'occurrence \nest prévue et peut être traitée (exemple: valeur \nen dehors des conditions de la précondition, …) \no \nUne méthode qui peut lancer une checked exception \ndoit le déclarer \nn  unchecked: il n'y a rien à faire, (exemple une \nerreur interne de la JVM) ou une erreur à \nl'exécution (dépassement de tableau) \no \nUne méthode qui peut lancer une unchecked exception \nne doit pas le déclarer \n\nPOO-L3 H. Fauconnier \n202 \nExceptions \no  Une exception est un objet d'une classe \ndérivée de Throwable (mais, en fait, en \ngénéral de Exception) \no  Le mécanisme est le même que pour \ntout objets: \nn  on peut définir des sous-classes \nn  des constructeurs \nn  redéfinir des méthodes \nn  ajouter des méthodes \n \n\nPOO-L3 H. Fauconnier \n203 \nExceptions et traite-exceptions \no  Un traite exception déclare dans son \nentête un paramètre \no  Le type du paramètre détermine si le \ntraite-exception correspond à \nl'exception  \nn  même mécanisme que pour les méthodes et \nl'héritage \n\nPOO-L3 H. Fauconnier \n204 \nThrow \no  Certaines exceptions et errors sont \nlancées par la JVM \no  L'utilisateur peut définir ses propres \nexceptions et les lancer lui-même: \nthrow expression; \nl'expression doit s'évaluer comme une \nvaleur ou une variable qui peut être \naffectée à Throwable \n\nPOO-L3 H. Fauconnier \n205 \nEnvironnement \no  Par définition une exception va transférer le \ncontrôle vers un autre contexte \nn  le contexte dans lequel l'exception est traitée est \ndifférent du contexte dans lequel elle est lancée \nn  l'exception elle-même peut permettre de passer \nde l'information par son instanciation \nn  l'état de la pile au moment de l'exception est \naussi transmis  \npublic StackTraceElement[] getStackTrace() et \npublic void printStackTrace() \n\nPOO-L3 H. Fauconnier \n206 \nHiérarchie: \no \njava.lang.Throwable (implements java.io.Serializable)  \nn \njava.lang.Error  \no \njava.lang.AssertionError  \no \njava.lang.LinkageError  \no \njava.lang.ThreadDeath  \no \njava.lang.VirtualMachineError  \nn \nexemple:java.lang.StackOverflowError  \nn \njava.lang.Exception  \no \njava.lang.ClassNotFoundException  \no \njava.lang.CloneNotSupportedException  \no \njava.lang.IllegalAccessException  \no \njava.lang.InstantiationException  \no \njava.lang.InterruptedException  \no \njava.lang.NoSuchFieldException  \no \njava.lang.NoSuchMethodException  \no \njava.lang.RuntimeException  \nn \nexemple: java.lang.IndexOutOfBoundsException  \n\nPOO-L3 H. Fauconnier \n207 \nHiérarchie \no  Throwable: \nn  la super classe des erreurs et des \nexceptions \nn  Error : unchecked \nn  Exception :checked sauf RuntimeException \n\nPOO-L3 H. Fauconnier \n208 \nExemple \npublic class MonException extends Exception{ \n    public final String nom; \n    public MonException(String st) { \n        super(\"le nombre \"+st+\" ne figure pas\"); \n        nom=st; \n    } \n} \n\nPOO-L3 H. Fauconnier \n209 \nExemple (suite) \nclass Essai{ \n    static String[] tab={\"zéro\",\"un\",\"deux\",\"trois\",\"quatre\"};     \n    static int chercher(String st ) throws MonException{ \n        for(int i=0;i<tab.length;i++) \n            if (tab[i].equals(st))return i; \n        throw new MonException(st); \n    } \n     \n    public static void main(String st[]){ \n        try{ \n            chercher(\"zwei\"); \n        }catch(Exception e){ \n            System.out.println(e); \n        } \n         \n    } \n} \n \n\nPOO-L3 H. Fauconnier \n210 \nRésultat \no  Donnera: \nexceptions.MonException: le nombre zwei ne figure pas \n \no   e.printStackTrace(); dans le try bloc \ndonnera: \nexceptions.MonException: le nombre zwei ne figure pas \n        at exceptions.Essai.chercher(MonException.java:29) \n        at exceptions.Essai.main(MonException.java:34) \n\nPOO-L3 H. Fauconnier \n211 \nThrows \no  principe: \nn  toute méthode qui peut générer \ndirectement ou indirectement une \n(checked) exception doit le déclarer par \nune clause \"throws\" dans l'entête de la \nméthode. \no \n(les initialiseurs statiques ne peuvent donc pas \ngénérer d'exceptions) \nn  La vérification a lieu à la compilation \n\nPOO-L3 H. Fauconnier \n212 \nClause throws \no  Une méthode qui appelle une méthode \nqui peut lancer une exception peut \nn  attraper (catch) cette exception dans un \ntry bloc englobant la méthode qui peut \nlancer cette exception \nn  attraper cette exception et la \ntransformer en une exception déclarée \ndans la clause throws de la méthode \nn  déclarer cette exception dans la clause \nthrows de sa déclaration \n\nPOO-L3 H. Fauconnier \n213 \nClause throws et héritage \no  Si une classe dérivée redéfinit (ou \nimplémente) une méthode la clause \nthrows de la méthode redéfinie doit \nêtre compatible avec celle d'origine \nn  compatible = les exceptions de la clause \nthrows sont dérivées de celles de la \nméthode d'origine \nn  pourquoi? \n\nPOO-L3 H. Fauconnier \n214 \ntry, catch, finally \no  On attrape les exceptions dans des try-bloc: \ntry{ \n instructions \n}catch(exception-type1 id1){ \n    instructions \n} catch(exception-type2 id2){ \n    ... \n}finally{ \n instructions \n} \n \n\nPOO-L3 H. Fauconnier \n215 \nPrincipe: \no  le corps du try est exécuté jusqu'à ce qu'il \ntermine ou qu'une exception est lancée \no  Si une exception est lancée les clauses \n\"catch\" sont examinées dans l'ordre \nn  la première dont le type peut correspondre à \nl'exception est choisie et son code exécuté \nn  si aucun catch ne peut correspondre l'exception \nest propagée \nn  si une clause finally figure son code est ensuite \nexécuté (toujours avec ou sans exception) \n\nPOO-L3 H. Fauconnier \n216 \nExemple \nclass A extends Exception{ \n} \nclass B extends A{ \n} \nclass essai{ \n    public static void main(String[] st){ \n        try{ \n            throw new B(); \n        }catch (A a){ \n            System.out.println(a); \n//        }catch (B b){ \n//            System.out.println(b); \n        }finally{ \n            System.out.println(\"finally..\"); \n        } \n    } \n} \n\nPOO-L3 H. Fauconnier \n217 \nfinally \n public boolean rechercher(String fichier,  \n \n String mot) throws StreamException{ \n        Stream input=null; \n        try{ \n            input=new Stream(fichier); \n            while(!input.eof()) \n                if(input.next().equals(mot)) \n                    return true; \n            return false; \n        }finally{ \n            if (input != null) \n                input.close(); \n        } \n    } \n\nPOO-L3 H. Fauconnier \n218 \nChaînage d'exceptions \no  Une exception peut être causée par une \nautre. \no  il peut être utile dans ce cas de \ntransmettre la cause de l'exception \nn  méthode: \npublic Throwable initCause(Throwable cause) \n\nPOO-L3 H. Fauconnier \n219 \nTransmission d'information \no  en définissant une extension de la \nclasse et en définissant des \nconstructeurs \no  par défaut on a les constructeurs \npublic Throwable()  \npublic Throwable(String message) \npublic Throwable(String message, \nThrowable cause)  \n\nPOO-L3 H. Fauconnier \n220 \nTransmission d'information \no  On peut récupérer ces informations: \npublic String getMessage() \npublic Throwable getCause() \no  On peut obtenir l'état de la pile: \npublic void printStackTrace()  \npublic StackTraceElement[] \ngetStackTrace()  \n \n\nPOO-L3 H. Fauconnier \n221 \nExemple \nclass X extends Exception{ \n    public X(){} \n    public X(String details){ \n        super(details); \n    } \n    public X(Throwable e){ \n        super(e); \n    } \n    public X(String details, Throwable e){ \n        super(details,e); \n    } \n} \n\nPOO-L3 H. Fauconnier \n222 \nSuite \n try{ \n      throw new A();          \n  }catch (A a){ \n         try { \n             throw new X(a); \n         } catch (X ex) { \n                ex.printStackTrace(); \n           } \n   } \n } \n----- \nX: A \n        at essai.main(Finally.java:61) \nCaused by: A \n        at essai.main(Finally.java:58) \n \n \n\nPOO-L3 H. Fauconnier \n223 \nRemarque \no  à la place de: \n throw new X(a); \no  on pourrait mettre \nthrow (X) new X().initCause(a); \n \n(pourquoi le cast (X) est nécessaire?) \n\nPOO-L3 H. Fauconnier \n224 \nAssertions \no  Une autre façon de garantir le contrat \nest de définir des assertions qui \nvérifient les invariants (ou les \npréconditions) \no  Si l'assertion n'est pas vérifiée une \nAssertionError est lancée \no  (une option de compilation permet de \nvérifier ou non les assertions) \n\nPOO-L3 H. Fauconnier \n225 \nAssertions \no  Syntaxe: \nassert expr [: detail]; \nn  expr est une expression boolean  \nn  detail est optionnel et sera passé au \nconstructeur de AssertionError  \n(une string ou un Throwable) \no  Exemple: \n assert i!=0 : \"i =\"+i+\" i devrait être non nul\"; \n\nPOO-L3 H. Fauconnier \n226 \nAssertions \no  par défaut les assertions ne sont pas \névaluées \no  pour les évaluer: \nn  -enableassertions:nom_du_package \nn  -disableassertions:nom_du_package \navec en argument le ou les paquetages \nconcernés. \n\nJava Swing \n\nPrincipes de base \no  Des composants graphiques  \n(exemple: JFrame, JButton …) \no \nHiérarchie de classes \no  Des événements et les actions à \neffectuer  \n(exemple presser un bouton) \no  (Et d'autres choses…) \n\nPrincipes \no  Définir les composants (instance de classes) \no  Les placer à la main (layout Manager) dans un \nJPanel ou un content pane ou en utilisant des \noutils comme eclipse ou netbeans \no  Définir les actions associées aux événements \n(Listener) et les associer aux composants \ngraphiques \n \n\nPrincipes \no  Dans une interface graphique, le \nprogramme réagit aux interactions avec \nl'utilisateur \no  Les interactions génèrent des \névénements \no  Le programme est dirigé par les \névénements (event-driven) \n\nAfficher… \no  Pour pouvoir être affiché, il faut que le \ncomposant soit dans un top-level \nconteneur: \n(JFrame, JDialog et JApplet) \no  Hiérarchie des composants: arbre \nracine top-level \n \n\nExemple \no  Correspond à la hiérarchie\t\n\r\n\nLe code \nimport java.awt.*; \nimport javax.swing.*; \n \npublic class TopLevel { \n    /** \n     * Affiche une fenêtre JFrame top level  \n     * avec une barre de menu JMenuBar verte \n     * et un JLabel jaune \n     */ \n    private static void afficherMaFenetre() { \n \n //créer la Jframe \n \n //créer la JMenuBar \n              //créer le Jlabel \n              // mettre le JMenuBar et le Jlable dans la Jframe \n              //afficher la Jframe \n    } \n} \n\nLe code \n      //Creer la JFrame \n        JFrame frame = new JFrame(\"TopLevelDemo\"); \n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); \n        //Créer la JMenuBar \n        JMenuBar greenMenuBar = new JMenuBar(); \n        greenMenuBar.setOpaque(true); \n        greenMenuBar.setBackground(new Color(0, 200, 0)); \n        greenMenuBar.setPreferredSize(new Dimension(200, 20)); \n        //Créer le JLabel \n        JLabel yellowLabel = new JLabel(); \n        yellowLabel.setOpaque(true); \n        yellowLabel.setBackground(new Color(250, 250, 0)); \n        yellowLabel.setPreferredSize(new Dimension(200, 180)); \n        //mettre la JmenuBar et position le JLabel \n        frame.setJMenuBar(greenMenuBar); \n        frame.getContentPane().add(yellowLabel, BorderLayout.CENTER); \n        //afficher... \n        frame.pack(); \n        frame.setVisible(true); \n     \n\nEt le main \n public class TopLevel {//afficherMaFenetre() \n    public static void main(String[] args) { \n        javax.swing.SwingUtilities.invokeLater(new Runnable() { \n            public void run() { \n                afficherMaFenetre(); \n            } \n        }); \n    } \n} \n\nEvénements: principes \no  Dans un système d'interface graphique: \nn  Quand l'utilisateur presse un bouton, un \n\"événement\" est posté et va dans une \nboucle d'événements  \nn  Les événements dans la boucle \nd'événements sont transmis aux \napplications qui se sont enregistrées pour \nécouter.  \n\nEvénements \no  Chaque composant génère des événements: \nn  Presser un JButton génère un ActionEvent \n(système d'interface graphique) \no \nCet ActionEvent contient des infos (quel bouton, \nposition de la souris, modificateurs…) \nn  Un event listener (implémente ActionListener)  \no \ndéfinit une méthode actionPerformed  \no \nS'enregistre auprès du bouton addActionListener \nn  Quand le bouton est \"clické\",l'actionPerformed \nsera exécuté (avec l'ActionEvent comme \nparamètre) \n\nExemples Buttons \n\nUn exemple \no  Un bouton qui \nréagit \n\nLe code: \no  Un JButton \no  Un JLabel \no  Implementer ActionListener \nn  actionPerfomed définit ce qui se passe \nquand le bouton est cliqué \no  Placer le bouton et le label \n\nCode: \nimport java.awt.*; \nimport javax.swing.JFrame; \nimport javax.swing.JPanel; \nimport javax.swing.JButton; \nimport javax.swing.Jcomponent; \nimport java.awt.Toolkit; \nimport java.awt.BorderLayout; \nimport java.awt.event.ActionListener; \nimport java.awt.event.ActionEvent; \nimport javax.swing.JLabel; \n \npublic class UnBouton extends Jpanel implements ActionListener { \n    JButton bouton; \n    String contenu=\"Rien Reçu\"; \n    JLabel label=new JLabel(contenu); \n    int cmp=0; \n    public UnBouton() { //…}  \n    public void actionPerformed(ActionEvent e) {//…}  \n    private static void maFenetre(){//…} \n    public static void main(String[] args) {//…} \n} \n \n\nCode \n public UnBouton() { \n        super(new BorderLayout()); \n        bouton = new JButton(\"Click\"); \n        bouton.setPreferredSize(new Dimension(200, 80)); \n        add(bouton, BorderLayout.NORTH); \n        label = new JLabel(contenu); \n                label.setPreferredSize(new Dimension(200, 80)); \n        add(label,BorderLayout.SOUTH); \n        bouton.addActionListener(this); \n    } \n public void actionPerformed(ActionEvent e) { \n        Toolkit.getDefaultToolkit().beep(); \n        label.setText(\"clické \"+ (++cmp)+ \" fois\"); \n   } \n\nCode \n private static void maFenetre() { \n        JFrame frame = new JFrame(\"UnBouton\"); \n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); \n        JComponent newContentPane = new UnBouton(); \n        newContentPane.setOpaque(true);  \n        frame.setContentPane(newContentPane); \n        frame.pack(); \n        frame.setVisible(true); \n    } \n    public static void main(String[] args) { \n        //Formule magique \n        javax.swing.SwingUtilities.invokeLater(new Runnable() { \n            public void run() { \n                maFenetre(); \n            } \n        }); \n    } \n\nVariante \npublic class UnBoutonBis extends JPanel { \n//… \n bouton.addActionListener(new ActionListener() {  \n            public void actionPerformed(ActionEvent e) {  \n                 Toolkit.getDefaultToolkit().beep(); \n                 label.setText(\"clické \" + (++cmp) + \" fois\");  \n            } }); \n        } \n//… \n} \n  \n\nHiérarchie des classes… \nPOO-L3 H. Fauconnier \n245 \n\n\nUn exemple \no  Un traceur de fonctions \nn  Une interface graphique swing  \n\nOrganisation \no  GrapheSwing contient un\nGraphePanel extension de Jpanel \nn  GraphePanel méthode paintComponent qui \naffiche le graphe de la fonction \no \nGraphe est la classe contenant le gaphe et \ndéfinissant une méthode draw pour l'affichage \no \nCette méthode appelle tracer de la classe \nabstraite Traceur  \nn \nFonctionTraceur étend Traceur \nPOO-L3 H. Fauconnier \n248 \n\nLe main \n public static void main(String[] args) {  new GrapheSwing(unGraphe());} \n \n    public static Graphe unGraphe() { \n        PlotSettings p = new PlotSettings(-2, 2, -1, 1); \n        p.setPlotColor(Color.RED); \n        p.setGridSpacingX(0.5); \n        p.setGridSpacingY(0.5); \n        p.setTitle(\"Une parabole et une sinusoide\"); \n        Graphe graphe = new Graphe(p); \n        graphe.functions.add(new Parabole()); \n        graphe.functions.add(new FonctionTraceur() { \n            public double getY(double x) { \n                return Math.sin(x); \n            } \n            public String getName() { \n                return \"Sin(x)\"; \n            } \n        }); \n        return graphe; \n    } \nPOO-L3 H. Fauconnier \n249 \n\nComposants \no  Modèle Vue Contrôleur \n\nPréliminaires… \no  Lightweight et heavyweight composants \nn  Dépendent ou non du système d’interface \ngraphique \no \nLightweight écrit en Java et dessiné dans un \nheavyweight composant- indépendant de la plateforme \no \nLes heavyweight composants s’adressent directement à \nl’interface graphique du système \nn  (certaines caractéristiques dépendent du « look \nand feel »). \n\nLook and feel \no  Look and feel: \nPossibilité de choisir l’apparence de l’interface \ngraphique. \nUIManager gère l’apparence de l’interface \npublic static void main(String[] args) { \n    try { \n        UIManager.setLookAndFeel( \n            UIManager.getCrossPlatformLookAndFeelClassName()); \n    } catch (Exception e) { } \n \n    new SwingApplication(); //Create and show the GUI. \n} \n \n\nMultithreading \no  Attention au « modèle, contrôleur, \nvue » en cas de multithreading: \nn  Tous les événements de dessin de \nl’interface graphiques sont dans une \nunique file d’event-dispatching dans une \nseule thread. \nn  La mise à jour du modèle doit se faire tout \nde suite après l’événement de visualisation \ndans cette thread. \n\nPlus précisément \no  Swing prend en charge la gestion des \ncomposants qui sont dessinés en code \nJava (lightweight) \no  Les composants AWT sont eux liés aux \ncomposants natifs (heavyweight) \no  Swing dessine le composants dans un \ncanevas AWT et utilise le traitement \ndes événements de AWT \n\nSuite \nLes  threads \no  Main application thread \no  Toolkit thread \no  Event dispatcher thread \no  Toutes Les opérations  \nd'affichage ont lieu dans \nune seule thread l'EDT \n \n\nPrincipes \no  Une tâche longue ne doit pas être \nexécutée dans l'EDT \no  Un composant Swing doit s'exécuter \ndans l'EDT \n\nExemple \n public void actionPerformed(ActionEvent e){     \n    try {       \n        Thread.sleep(4000);    \n } catch (InterruptedException e) {    }  } \n \nProvoque une interruption de l'affichage pendant \n4 secondes \n\nUne solution \npublic void actionPerformed(ActionEvent e){ \n  try{   \n    SwingUtilities.invokeLater(newRunnable(  \n           { public void run() {      \n                 //opération longue    \n                 }       \n            }); \n   } catch (InterruptedException ie) {} \n     catch (InvocationTargetException ite) {} \n   }  \n} \n\nLe main \no  Normalement la création d'une fenêtre \nne devrait avoir lieu que dans l'EDT: \n public static void main(String[] args) { \n        //Formule magique \n        javax.swing.SwingUtilities.invokeLater(new Runnable() { \n                                    public void run() {maFenetre(); } \n        }); \n    } \ninvokeLater crée une nouvelle thread qui poste la thread crée dans \nl'EDT \n\nAttendre le résultat: \n    try { \n            SwingUtilities.invokeAndWait(new Runnable() { \n                public void run() { \n                    show(); \n                } \n            }); \n        } catch (InterruptedException ie) { \n        } catch (InvocationTargetException ite) { \n        } \n\nChapitre VII \nGénéricité \n\nGénéricité \nPOO-L3 H. Fauconnier \n262 \nChapitre VII \n1. \nPrincipes généraux \n2. \nTypes génériques imbriqués \n3. \nTypes paramètres bornés \n4. \nMéthodes génériques \n\nGénéricité \nPOO-L3 H. Fauconnier \n263 \nPrincipes \no  Paramétrer une classe ou une méthode par un \ntype: \nn  une pile de X \no  En java toute classe étant dérivée de Object, \ncela permet d'obtenir une forme de \ngénéricité sans contrôle des types \nn  une pile d'Object \no  La généricité en Java est un mécanisme \n\"statique\" assez complexe \no  la généricité existe dans d'autres langages \n(exemple C++ et Ada) (mais de façon \ndifférente) \n\nGénéricité \nPOO-L3 H. Fauconnier \n264 \nExemple: File \npublic class Cellule<E>{ \n    private Cellule<E> suivant; \n    private E element; \n    public Cellule(E val) { \n        this.element=val; \n    } \n    public Cellule(E val, Cellule suivant){ \n        this.element=val; this.suivant=suivant; \n    } \n    public E getElement(){ return element;} \n    public void setElement(E v){ \n        element=v; \n    } \n    public Cellule<E> getSuivant(){ return suivant;} \n    public void setSuivant(Cellule<E> s){ \n        this.suivant=s; \n    } \n} \n\nGénéricité \nPOO-L3 H. Fauconnier \n265 \nSuite \nclass File<E>{ \n    protected Cellule<E> tete; \n    protected Cellule<E> queue; \n    private int taille=0; \n    public boolean estVide(){ \n        return taille==0; \n    } \n    public void enfiler(E item){ \n        Cellule<E> c=new Cellule<E>(item); \n        if (estVide()) \n            tete=queue=c; \n        else{ \n            queue.setSuivant(c); \n            queue=c; \n        } \n        taille++; \n    } //.. \n     \n\nGénéricité \nPOO-L3 H. Fauconnier \n266 \nsuite \n   public E defiler(){ \n        if (estVide()) \n            return null; \n        Cellule<E> tmp=tete; \n        tete=tete.getSuivant(); \n        taille--; \n        return tmp.getElement(); \n    } \n     public int getTaille(){ \n        return taille; \n    } \n} \n \n\nGénéricité \nPOO-L3 H. Fauconnier \n267 \nUsage \n  \nCellule<Integer> cel=new Cellule<Integer>(23); \nFile<Integer> fi=new File<Integer>(); \nFile<String> fs=new File<String>(); \nFile<Object> fobj=new File<Object>(); \nString[] st={\"zéro\",\"un\",\"deux\", \n            \"trois\",\"quatre\",\"cinq\"}; \nfor(int i=0;i<st.length;i++){ \n     fs.enfiler(st[i]); \n     fi.enfiler(i); \n } \n\nGénéricité \nPOO-L3 H. Fauconnier \n268 \nRemarques \no  Une déclaration de type générique peut \navoir plusieurs paramètres: \nn  Map<K,V> \no  Contrôle de type \nn  fs.enfiler(4) est refusé à la compilation \n \n \n\nTypes génériques, pourquoi? \no  Vérification de type: \n List myIntList = new LinkedList();  \n myIntList.add(new Integer(0));  \n Integer x = (Integer) myIntList.iterator().next();  \nEt: \n List<Integer> myIntList = new LinkedList<Integer>(); \nmyIntList.add(new Integer(0));  \n x=myIntList.iterator().next();  \n \nPOO-L3 H. Fauconnier \n269 \n\nInvocation et type en \nparamètre \npublic interface List <E>{    \n             void add(E x);     \n             Iterator<E> iterator(); \n} \npublic interface Iterator<E>{ E next();    boolean hasNext();} \n \nList<Integer> pourrait correspondre à (comme en C++): \npublic interface IntegerList {     \n void add(Integer x);     \n Iterator<Integer> iterator(); \n} \nMais… une déclaration d'un type générique crée un vrai type (qui est \ncompilé comme un tout) et il n'y a pas de type pour List<Integer> \nPOO-L3 H. Fauconnier \n270 \n\nGénéricité \nPOO-L3 H. Fauconnier \n271 \nTypage \no  Une invocation ne crée pas un nouveau type: \nn  (fs.getClass()==fi.getClass()) est vrai \nn  la classe est ici File \nn  il s'agit surtout d'un contrôle (effectué à la \ncompilation) \nn  à l'exécution fi n'a plus aucune information sur \nquelle invocation a permis sa construction \n\nGénéricité \nPOO-L3 H. Fauconnier \n272 \nConséquences \no  Aucune instanciation n'est possible \npour un type argument \nn  Dans l'exemple: E v=new E(); \n est impossible \nn  Pas de tableau de E \n \n\nGénéricité \nPOO-L3 H. Fauconnier \n273 \nExemple \npublic E[] toArray(File<E> f){ \n      E[] tab=new E[f.getTaille()]; //non \n      for(int i=0;i<f.getTaille();i++)                 \n \n   tab[i]=f.defiler(); \n} \n \no \nComment construire un tableau sans connaître le \ntype de base? \no \nLa classe Array et la méthode \nArray.newInstance() permettraient de résoudre \nce problème (mais sans contrôle de type)  \no \nOn peut aussi utiliser la classe Object. \n\nGénéricité \nPOO-L3 H. Fauconnier \n274 \nObject \n public static <E> Object[] toArray(File<E> f){ \n  Object[] tab=new  Object[f.getTaille()]; \n  for(int i=0;i<f.getTaille();i++) \n      tab[i]=f.defiler(); \n  return tab; \n} \n \nmais on perd l'avantage du contrôle de type. \n\nGénéricité \nPOO-L3 H. Fauconnier \n275 \nContrôle du type \no  Pourtant, on peut passer un objet d'un \ntype avec paramètre à une méthode. \no  Comment se fait le passage des \nparamètres? \nn  le compilateur passe le type le plus \ngénéral (Object)  et utilise le cast \npour assurer le contrôle du typage. \n\nGénéricité \nPOO-L3 H. Fauconnier \n276 \nChapitre VII \n1. \nPrincipes généraux \n2. \nTypes génériques imbriqués \n3. \nTypes paramètres bornés \n4. \nMéthodes génériques \n\nGénéricité \nPOO-L3 H. Fauconnier \n277 \nTypes génériques imbriqués \npublic class FileSimpleChainageb <E>{ \n    public class Cellule{ \n        private Cellule suivant; \n        private E element; \n        public Cellule(E val) { \n            this.element=val; \n        } \n        public Cellule(E val, Cellule suivant){ \n            this.element=val; \n            this.suivant=suivant; \n        } \n        public E getElement(){ \n            return element; \n        } \n        public void setElement(E v){ \n            element=v; \n        }//... \n         \n\nGénéricité \nPOO-L3 H. Fauconnier \n278 \nSuite \n   public Cellule getSuivant(){ \n            return suivant; \n        } \n   public void setSuivant(Cellule s){ \n            this.suivant=s; \n        } \n    } \n    protected Cellule tete; \n    protected Cellule queue; \n    private int taille=0; \n    public boolean estVide(){ \n        return taille==0; \n    } \n    public int getTaille(){ \n        return taille; \n    } \n     \n\nGénéricité \nPOO-L3 H. Fauconnier \n279 \nFin… \n    public void enfiler(E item){ \n        Cellule c=new Cellule(item); \n        if (estVide()) \n            tete=queue=c; \n        else{ \n            queue.setSuivant(c); \n            queue=c; \n        } \n        taille++; \n    } \n    public E defiler(){ \n        if (estVide()) \n            return null; \n        Cellule tmp=tete; \n        tete=tete.getSuivant(); \n        taille--; \n        return tmp.getElement(); \n    } \n     \n} \n\nGénéricité \nPOO-L3 H. Fauconnier \n280 \nChapitre VII \n1. \nPrincipes généraux \n2. \nTypes génériques imbriqués \n3. \nTypes en paramètres bornés \n4. \nMéthodes génériques \n\nSous-typage \nList<String> ls = new ArrayList<String>(); \nList<Object> lo = ls; //1 \nlo.add(new Object());//2 \nString s = ls.get(0); //3 ! \n \nSi A est une extension de B, F<A> n'est pas une extension de F<B>: \n//1 est interdit \n \nPour les tableaux: \nn \nsi A est une extension de B un tableau de A est une extension de tableau \nde B.  \nn \n//1 est autorisé, mais ensuite //2 est interdit \n     \nPOO-L3 H. Fauconnier \n281 \n\nJoker '?' \nvoid printCollection(Collection<Object> c) { \n for (Object e : c) { System.out.println(e);} \n} \nNe fonctionne pas avec une Collection<Integer> \nUne collection de n'importe quoi ('?') \nvoid printCollection(Collection<?> c) {  \n for (Object e : c){ System.out.println(e);} \n} \nest possible (n'importe quoi est un objet). \nMais \nCollection<?> c = new ArrayList<String>(); \nc.add(new Object()); // erreur compilation \n \nPOO-L3 H. Fauconnier \n282 \n\nMais \no  Ce n'est pas suffisant… \nn  On peut vouloir borner le type paramètre: \ncomparable est une interface générique \nqui indique la possibilité de comparer des \nobjets \nclass valeur implements Comparable<Valeur>{..} \nn  Une SortedCollection est construite sur \ndes classes E qui implémentent \nComparable<E> d'où: \ninterface SortedCollection<E extends Comparable<E>>{} \n \nPOO-L3 H. Fauconnier \n283 \n\nGénéricité \nPOO-L3 H. Fauconnier \n284 \nExemple \n    static double somme(List<Number> l){ \n        double res=0.0; \n        for(Number n:l) \n            res+=n.doubleValue(); \n        return res; \n    } \n    public static void main(String[] st){ \n        List<Integer> l= new ArrayList<Integer>(); \n        for(int i=0;i<10;i++)l.add(i); \n        double s=somme(l); //incorrect \n    } \nMais \n\nGénéricité \nPOO-L3 H. Fauconnier \n285 \nType paramètre borné \no  Au moins un number: \no  List<? extends Number> une liste \nconstituée de n'importe quel type \ndérivé de Number \n static double somme2(List<? extends Number> l){ \n        double res=0.0; \n        for(Number n:l) \n            res+=n.doubleValue(); \n        return res; \n    } \n\nGénéricité \nPOO-L3 H. Fauconnier \n286 \nTypes bornés \no  List<? extends Number> \nn  indique que le type doit au moins être un \nNumber (tout type qui dérive de Number) \nn  borné par le bas : au moins un Number \no  On peut aussi imposer que le type soit \nune superclasse d'un autre type \nn  List<? super Integer> \nn  borné par le haut : au plus un Integer \n(super-classe de Integer) \n\nGénéricité \nPOO-L3 H. Fauconnier \n287 \nSous-typage \no  List<?> est une super classe de \n List<Object> \nEt: \no  List<?> \nn  List<? extends Number> \no \nList<Number> \no \nList<? extends Integer> \nn  List<Integer> \n\nGénéricité \nPOO-L3 H. Fauconnier \n288 \nTypes en paramètres bornés \no  Exemple: \nn   SortedCollection est composée d'éléments du \ntype E et ces éléments peuvent être comparés.  \nMais <E extends comparable<E>> est trop fort: \nil suffit que E extends Comparable<T> pour T égal à E \nou T superclasse de E \n(si E extends Comparable<Object> a fortiori on peut \ncomparer les éléments de E) d'où: \n<E extends Comparable<? super E>> \n \n\nGénéricité \nPOO-L3 H. Fauconnier \n289 \nMais attention \n File<?> str=new File<String>(); \n str.enfiler(\"un\"); \nprovoque une erreur à la compilation: \nenfiler(capture of ?) in generique.File<capture of ?> \ncannot be applied to (java.lang.String) \nde même: \nFile<? extends Number> num=new File<Number>(); \nnum.enfiler(Integer.valueOf(12)); \nen effet File<? extends Number> peut être par exemple une File \nd'un type dérivé de Number. \nPar contre: \nFile<? super Number> num=new File<Number>(); \nnum.enfiler(Integer.valueOf(12));  \nest correct \n \n\nGénéricité \nPOO-L3 H. Fauconnier \n290 \nJoker '?' \nenfiler(capture of ?) in generique.File<capture of ?\n> cannot be applied to (java.lang.String) \no  signifie que le type de str est \nFile<capture of ?> qui n'est pas \ncompatible avec String \n\nGénéricité \nPOO-L3 H. Fauconnier \n291 \nQuelques explications \no  ? peut correspondre à n'importe quel type \nenfiler(a) où a est de type A ne peut \nfonctionner si le type correspondant à ? est \ndérivé de A \no  de même ?  dans <? extends X> ne peut \nfonctionner car si ? est Y dérivé de X il faut \nun paramètre d'une classe dérivée de Y \no  par contre ? dans <? super X> ne pouvant \ncorrespondre qu'à une classe \"avant\" X, tout \nZ dérivé de X fonctionne \n\nGénéricité \nPOO-L3 H. Fauconnier \n292 \nMais \no  inversement pour la valeur retournée \n(avec la méthode défiler par exemple) \nn  pour <?> quelque soit le type X \ncorrespondant on peut l'affecter à Object \net à X \nn  idem pour <? extends X> \nn  mais pour <? super Y> si Z correspond à ? \npour T  un type quelconque on ne peut \nsavoir si T peut être affecté par un Z \n\nGénéricité \nPOO-L3 H. Fauconnier \n293 \nChapitre VII \n1. \nPrincipes généraux \n2. \nTypes génériques imbriqués \n3. \nTypes paramètres bornés \n4. \nMéthodes génériques \n\nGénéricité \nPOO-L3 H. Fauconnier \n294 \nMéthodes génériques \no  Supposons que l'on veuille convertir en \ntableau une File de E \nn  on a vu précédemment que l'on ne pouvait \nni instancier un objet E ni créer un tableau \nde E \nn  on peut cependant passer un tableau de la \ntaille appropriée à une méthode qui \nretourne ce tableau: \n\nGénéricité \nPOO-L3 H. Fauconnier \n295 \nenTableau1 \n public E[] enTableau1(E[] tab){ \n      Object[] tmp = tab; \n      int i=0; \n      for(Cellule<E> c= tete; c != null && i< tab.length; \n      c=c.getSuivant()) \n           tab[i++] = c.getElement(); \n      return tab;        \n    } \no \nenTableau1 est une nouvelle méthode de File: \n File<String> fs=new File<String>(); \n String[]  u; \n u=fs.enTableau1(new String[fs.getTaille()]); \n\nGénéricité \nPOO-L3 H. Fauconnier \n296 \nenTableau \no  Mais, \nn   il faut que le tableau passé en paramètre \nsoit un tableau de E, alors qu'un tableau \nd'une super-classe de E devrait \nfonctionner (si F est une superclasse de E \nun tableau de F peut contenir des objets \nE). \nn  avec une méthode générique: \n\nGénéricité \nPOO-L3 H. Fauconnier \n297 \nenTableau \n    public <T> T[] enTableau(T[] tab){ \n        Object[] tmp = tab; \n        int i=0; \n        for(Cellule<E> c= tete; c != null && i< tab.length; \n        c=c.getSuivant()) \n            tmp[i++] = c.getElement(); \n        return tab;         \n    } \no \nla déclaration impose que le type du tableau retourné soit du \ntype du tableau de l'argument \no \nNotons que tmp est un tableau d'Object ce qui est nécessaire \npour le getSuivant \no \nNotons que normalement il faudrait que T soit une superclasse \nde E (à l'exécution il peut y avoir une erreur). \no \nNotons enfin que 'T' ne sert pas dans le corps de la méthode. \n\nGénéricité \nPOO-L3 H. Fauconnier \n298 \nRemarque \n public <T> T[] enTableaubis(T[] tab){    \n        int i=0; \n        for(Cellule<E> c= tete;  \n \n \n c != null && i< tab.length; \n            c=c.getSuivant()) \n            tab[i++] = (T)c.getElement(); \n        return tab; \n } \no  provoque un warning \"Cellule.java uses unchecked \nor unsafe operations\". \no  (l'\"effacement\" ne permet pas de vérifier le \ntype) \n\nGénéricité \nPOO-L3 H. Fauconnier \n299 \nAvec Reflection… \no  Une autre solution peut être, si on veut \ncréer un vrai tableau, d'utiliser \nArray.newInstance de la classe: \njava.lang.reflect \n\nGénéricité \nPOO-L3 H. Fauconnier \n300 \nExemple avec Reflection \n public E[] enTableau2(Class<E> type){ \n        int taille = getTaille(); \n        E[] arr=(E[])Array.newInstance(type,taille); \n        int i=0; \n        for(Cellule<E> c= tete; c != null && i< taille; \n        c=c.getSuivant()) \n            arr[i++] = c.getElement(); \n        return arr; \n } \no \non crée ainsi un tableau de \"E\"  \no \n\"unchecked warning\": le cast (E[]) n'a pas le sens usuel \no \npour fs déclaré comme précédemment on aura: \n String[] u=fs.enTableau2(String.class); //ok \n Object[] v=fs.enTableau2(Object.class); //non \no \ncar le type doit être exact \n\nGénéricité \nPOO-L3 H. Fauconnier \n301 \nAvec une méthode générique \n   public <T> T[] enTableau3(Class<T> type){ \n        int taille = getTaille(); \n        T[] arr=(T[])Array.newInstance(type,taille); \n        int i=0; \n        Object[] tmp=arr; \n        for(Cellule<E> c= tete; c != null && i< taille; \n        c=c.getSuivant()) \n            tmp[i++] = c.getElement(); \n        return arr; \n    } \n\nGénéricité \nPOO-L3 H. Fauconnier \n302 \nInférence de type \no  Comment invoquer une méthode \ngénérique? \no  Exemple: \n static <T> T identite(T obj){ \n        return obj; \n    } \n\nGénéricité \nPOO-L3 H. Fauconnier \n303 \nInvocations \no  On peut explicitement préciser le type: \n        String s1=\"Bonjour\"; \n        String s2= Main.<String>identite(s1); \no  Mais le compilateur peut, lui-même, trouver le \ntype le plus spécifique: \n        String s1=identite(\"Bonjour\"); \no   On aura: \n        Object o1=identite(s1);          //ok \n        Object o2=identite((Object)s1);  //ok \n        s2=identite((Object) s1);        //non!!! \n        s2=(String)identite((Object) s1);//ok \n\nGénéricité \nPOO-L3 H. Fauconnier \n304 \nComment ça marche? \no \nMécanisme de l'effacement (\"erasure\")  \no \nPour chaque type générique il n'y a qu'une classe: \nCellule<String> et Cellule<Integer> ont la même classe \no \nEffacement: \nn \nCellule<String> -> Cellule \no \nCellule est un type brut \nn \nPour une variable type: \no \n<E> -> Object  \no \n<E extends Number> -> Number \no \nLe compilateur remplace chaque variable type par son \neffacement \n\nGénéricité \nPOO-L3 H. Fauconnier \n305 \nComment ça marche? \no  Si le résultat de l'effacement du \ngénérique ne correspond pas à la \nvariable type, le compilateur génère un \ncast: \nn  par effacement le type variable de File<E> \nest Object \nn  pour un \"defiler\" sur un objet File<String> \nle compilateur insère un cast sur String \n\nGénéricité \nPOO-L3 H. Fauconnier \n306 \nComment ça marche? \no  A cause de l'effacement, rien de ce qui \nnécessite de connaître la valeur d'un \nargument type n'est autorisé. Par exemple: \nn  on ne peut pas instancier un type en paramètre: \npas de new T() ou de new T[] \nn  on ne peut pas utiliser instanceof pour une \ninstance de type paramétré \nn  on ne peut pas créer de tableau sur un type \nparamétré sauf s'il est non borné new \nList<String>[10] est interdit mais new \nList<?>[10] est possible. \n\nGénéricité \nPOO-L3 H. Fauconnier \n307 \nComment ça marche? \no  les \"cast\" sont possibles mais n'ont pas la \nmême signification que pour les  types non \nparamétrés: \nn  le cast est remplacé par un cast vers le type \nobtenu par effacement et génère un \"unchecked \nwarning\" à la compilation.  \nn  Exemple:  \no \non peut caster paramètre File<?> vers un File<String> \npour un enfiler (ce qui génère le warning) \no \nA l'exécution si le type effectif est File<Number> cela \npasse… mais le defiler provoquera un \nClassCastException. \n\nGénéricité \nPOO-L3 H. Fauconnier \n308 \nComment ça marche? \no  Exemple: \n        List<String> l=new ArrayList<String>(); \n        Object o=identite(l); \n        List<String> l1=(List<String>)o;// warning \n        List<String> l2=(List)o;//warning \n        List<?> l3=(List) o; //ok  \n        List<?> l4=(List<?>)o; //ok \n\nGénéricité \nPOO-L3 H. Fauconnier \n309 \nApplication: surcharge \no  avoir la même signature s'étend aux \nméthodes avec variables types \no  même signature pour des variables \ntypes = même type et même borne \n(modulo bien sûr renommage!) \no  signatures équivalentes par annulation: \nmêmes signatures où l'effacement des  \nsignatures sont identiques \n\nGénéricité \nPOO-L3 H. Fauconnier \n310 \nSurcharge \nclass Base<T>{ \n    void m(int x){}; \n    void m(T t){}; \n    void m(String s){}; \n    <N extends Number> void m(N n){}; \n    void m(File<?> q){}; \n} \n----- \nm(int) \nm(Object) \nm(String) \nm(Number) \nm(File) \n\nGénéricité \nPOO-L3 H. Fauconnier \n311 \nEt héritage… \no  exemple: \nclass D<T> extends Base<T>{ \n    void m(Integer i){} //nouveau \n    void m(Object t){}  // redéfinit m(T t) \n    void m(Number n){}   // redéfinit m(N n) \n} \n\nChapitre VIII \nStrings, \n\nStrings \nPOO-L3 H. Fauconnier \n313 \nPlan \no  A) String \no  B) Expressions régulières \no  C) Chaînes et tableaux (char et byte) \no  D) Chaînes modifiables \n\nStrings \nPOO-L3 H. Fauconnier \n314 \nString \no  Une String est une chaîne de caractères \nnon modifiable \nn  (attention les caractères en java sont en Unicode) \no  StringBuilder et StringBuffer sont des \nclasses de chaînes qui peuvent être \nmodifiées. \no  String StringBuilder et StringBuffer \nimplémentent l'interface CharSequence \n\nStrings \nPOO-L3 H. Fauconnier \n315 \nCharSequence \no   Interface: \nn  char charAt(int index)  \n          Retourne le char the char en position index.  \nn  int length()  \n          Retourne la longueur de la séquence.  \nn  CharSequence subSequence(int start, int end)  \n          Retourne une sous CharSequence \nn  String toString()  \n          Retourne la string correspondant à la \nséquence  \n\nStrings \nPOO-L3 H. Fauconnier \n316 \nString \no  De nombreuses méthodes pour manipuler les \nchaines (attention un objet String n'est pas \nmodifiable) \nn  constructeurs \nn  indexOf, lastIndexOf retourne la première \n(dernière) position \nn  conversion valueOf( valeur d'un type primitif) \nn  replace, trim, split  \nn  toLowerCase, toupperCase() \nn  … \n\nStrings \nPOO-L3 H. Fauconnier \n317 \nComparaison \no  '==' ne compare les contenus, MAIS \ndeux littéraux ayant le même contenu \nsont identiques: \n     String st1=\"bonjour\"; \n   String st2=\"bonjour\" \nif(st1==st2)System.out.println(\"égal\"); \n   else System.out.println(\"différent\"); \ndonnera égal \nLa méthode intern permet de retourner un \nString de même référence \n\nStrings \nPOO-L3 H. Fauconnier \n318 \nManipulations sur les chaînes \no \n char charAt(int index) \no \nint compareTo(String anotherString) comparaison \nlexicographique \no \nboolean contains(CharSequence s)  \no \nboolean equals(Object anObject)  \no \n int length() \no \n boolean matches(String regex)  \no \nboolean regionMatches(boolean ignoreCase, int toffset, \nString other, int ooffset, int len) \no \nboolean regionMatches(boolean ignoreCase, int toffset, \nString other, int ooffset, int len)  \no \nString replace(CharSequence target, \nCharSequence replacement)   \no \n String[] split(String regex) \no \nString trim()  \n\nStrings \nPOO-L3 H. Fauconnier \n319 \nExemples \n   String string = \"Madam, I am Adam\"; \n    boolean  b = string.startsWith(\"Mad\");  // true \n    b = string.endsWith(\"dam\");             // true \n    b = string.indexOf(\"I am\") > 0;         // true \n    b = string.matches(\"(?i)mad.*\"); \n    b = string.matches(\"(?i).*adam\"); \n    b = string.matches(\"(?i).*i am.*\"); \n\nStrings \nPOO-L3 H. Fauconnier \n320 \nExemple: remplacement \n static String replace(String str, String pattern,            \n \n String replace) { \n        int s = 0; \n        int e = 0; \n        StringBuffer result = new StringBuffer(); \n         \n        while ((e = str.indexOf(pattern, s)) >= 0) { \n            result.append(str.substring(s, e)); \n            result.append(replace); \n            s = e+pattern.length(); \n        } \n        result.append(str.substring(s)); \n        return result.toString(); \n } \n\nStrings \nPOO-L3 H. Fauconnier \n321 \nExemple \n    Strinf st1=\"bonjour\"; \n    String st3=new String(\"bonjour\"); \n    if(st1==st3)System.out.println(\"égal\"); \n    else System.out.println(\"différent\"); \n    String st4=st3.intern(); \n    if(st1==st4)System.out.println(\"égal\"); \n    else System.out.println(\"différent\"); \n(la comparaison des références est bien sûr moins \ncoûteuse que la comparaison des contenus) \n(de plus dans tous les cas des chaînes de même contenus \nont le même hashcode) \n\nStrings \nPOO-L3 H. Fauconnier \n322 \nExpressions régulières \no  Les expressions régulières permettent \nde définir un motif (pattern) objet de \nla classe Pattern. \no  Un motif est créé par la méthode \ncompile \nn  Pattern pat = Pattern.compile(\"[a-z]*\") \n\nStrings \nPOO-L3 H. Fauconnier \n323 \nExpressions régulières \no \nla syntaxe des expressions régulières (rationnelles) est assez \nlarge: \nn \ncaractères \no \nexemples \\t , a ,\\xhh , \nn \nclasses de caractères \no \nexemples [a-z], [^a-z], [a-z&&0-9] \nn \nclasses de caractères prédéfinis \no \nexemples . , \\d, \\D, \\w, \\W, \\s, \\S \nn \nclasses prédéfinies ASCII, Character \no \nexemples \\p{Blank}, \\p{javaLowerCase} \nn \nbords \no \nexemples  ^, $,\\b (bord d'un mot) \nn \nitérations \no \nexemples [a-z]?, [1-9][0-9]+, \\W*, \nn \ncapture et restitution \no \n(X) définit la capture de X \no \n\\n correspond à la n-ième capture \n\nStrings \nPOO-L3 H. Fauconnier \n324 \nRecherche de motif \no  Principe: \nPattern pat=Pattern.compile(regex); \nMatcher matcher=pat.match(entrée); \nboolean trouve = matcher.find(); \n \nla classe Matcher contient les méthodes pour \nchercher (find()), retourner la sous-\nséquence trouvée (group()) \n\nStrings \nPOO-L3 H. Fauconnier \n325 \nExemple: rechercher \n String patternStr = \"b\"; \n Pattern pattern = Pattern.compile(patternStr);     \n CharSequence inputStr = \"a b c b\"; \n Matcher matcher = pattern.matcher(inputStr); \n boolean matchFound = matcher.find();    // true     \n String match = matcher.group();         // b     \n int start = matcher.start();            // 2 \n int end = matcher.end();                // 3 \n matchFound = matcher.find();            // true \n \n\nStrings \nPOO-L3 H. Fauconnier \n326 \nRemplacer \n CharSequence inputStr = \"ab12 cd efg34\"; \n String patternStr = \"([a-zA-Z]+[0-9]+)\";       \n Pattern pattern = Pattern.compile(patternStr); \n Matcher matcher = pattern.matcher(inputStr);         \n // Remplacer toutes les occurrences \n StringBuffer buf = new StringBuffer(); \n boolean found = false; \n while ((found = matcher.find())) { \n     String replaceStr = matcher.group(); \n     replaceStr = replaceStr.toUpperCase(); \n     matcher.appendReplacement(buf, replaceStr); \n } \n matcher.appendTail(buf); \n String result = buf.toString();  \n// AB12 cd EFG34  \n\nStrings \nPOO-L3 H. Fauconnier \n327 \nChaines et tableaux de char \no  Une string n'est pas un tableau de char \nmais on peut passer de l'un à l'autre \no  constructeurs \nString(char[] value)  \nString(char[] value, int offset, int count)  \no  méthode: \nvoid getChars(int srcBegin, int srcEnd, \nchar[] dst, int dstBegin) \n\nStrings \nPOO-L3 H. Fauconnier \n328 \nChaînes et tableaux de byte \no  les chaines contiennent des caractères \ncodés en UTF-16.  \no  On peut convertir ces caractères en \nbyte suivant un codage \no  De même on peut coder des bytes en \ncaractères unicode. \no  (par exemple un byte Latin-1 se code en \nUnicode en ajoutant un octet de 0) \n\nStrings \nPOO-L3 H. Fauconnier \n329 \nCharset \no  la classe Charset permet de faire \ncorrespondre des séquences d'unicode \net des bytes. En standard: \nn  US-ASCII  \nn  ISO-8859-1  \nn  UTF-8 \nn  UTF-16BE \nn  UTF-16LE \nn  UTF-16 \n\nStrings \nPOO-L3 H. Fauconnier \n330 \ntableau de byte \no \nconstructeurs: \nn \nString(byte[] bytes) (conversion suivant le jeu de \ncaractère par défaut) \nn \nString(byte[] bytes, int offset, int length)  \nn \nString(byte[] bytes, String charsetName)  \n(suivant le charset) \nn \nString(byte[] bytes, int offset, int length, \nString charsetName) (suivant le charset) \no \nméthodes \nn \n byte[]getBytes()  \nn \n byte[]getBytes(String charsetName)  \n\nStrings \nPOO-L3 H. Fauconnier \n331 \nExemple: \n try { \n    // Conversion Unicode en x-MacRoman \n    String string = \"abcéçùà\\u563b\"; \n    System.out.println(string); \n    byte[] mac = string.getBytes(\"x-MacRoman\"); \n    System.out.println(new String(mac)); \n    // Conversion x-MacRoman vers Unicode \n    string = new String(utf8, \"x-MacRoman\"); \n    System.out.println(string); \n} catch (UnsupportedEncodingException e) { \n} \no \nabcéçùà? \no \nabcŽ??ˆ? \no \nabcéçùà? \n \n\nStrings \nPOO-L3 H. Fauconnier \n332 \nExemples: \n for(String nom: Charset.availableCharsets().keySet()) \n            System.out.println(nom); \naffichera la liste des jeux de caractères: \no \nEUC-JP \no \nEUC-KR \no \nGB18030 \no \nGB2312 \no \nGBK \no \nIBM-Thai \no \nIBM00858 \no \nIBM01140 \no \nIBM01141 \no \nIBM01142 \no \nIBM01143 \no \nIBM01144 \no \nIBM01145 \no \nIBM01146 \no \nIBM01147 \no \nIBM01148 \no \n… \n \n \n\nStrings \nPOO-L3 H. Fauconnier \n333 \nExemple \n    Charset charset = Charset.forName(\"ISO-8859-1\"); \n    CharsetDecoder decoder = charset.newDecoder(); \n    CharsetEncoder encoder = charset.newEncoder();     \n    try { \n        // Convertit une string vers ISO-LATIN-1 \n        ByteBuffer bbuf =     \n \n \n \n \n      encoder.encode(CharBuffer.wrap(\"une chaîne\")); \n     \n        // Convertit ISO-LATIN-1 bytes en string. \n        CharBuffer cbuf = decoder.decode(bbuf); \n        String s = cbuf.toString(); \n    } catch (CharacterCodingException e) { \n    } \n\nStrings \nPOO-L3 H. Fauconnier \n334 \nExemple: \n try { \n        // Conversion vers ISO-LATIN-1 de bytes \n        ByteBuffer bbuf = \nencoder.encode(CharBuffer.wrap(\"une chaîne\")); \n     \n        // Conversion de ISO-LATIN-1 vers bytes  \n        CharBuffer cbuf = decoder.decode(bbuf); \n        String s = cbuf.toString(); \n        System.out.println(s); \n    } catch (CharacterCodingException e) { \n    } \n\nStrings \nPOO-L3 H. Fauconnier \n335 \nStringBuilder \no  La classe StringBuilder peut contenir des \nchaînes qui peuvent être modifiées. \no  Il s'agit d'une structure de données \ndynamique: la taille de la chaîne est \naugmentée automatiquement \no  La taille initiale peut être précisée dans le \nconstructeur (16 par défaut). \no  (Il existe aussi une classe StringBuffer qui \nest \"thread-safe\") \no  méthodes insert, append, delete \n\nChapitre IX \nEntrées-sorties \n\nI/O package \nPOO-L3 H. Fauconnier \n337 \nPrincipes généraux \no  entrées sorties \nn  streams dans java.io \nn  channels dans java.nio (\"n\" pour non-blocking) \no  streams: séquences de données ordonnées \navec une source (stream d'entrée) ou une \ndestination (stream de sortie) \no  channels et buffer. Buffer contient les \ndonnées et le channel correspond à des \nconnections \n \n\nI/O package \nPOO-L3 H. Fauconnier \n338 \nStreams \no   Deux grandes sortes de Stream \nn  character Streams contiennet des \ncaractères UTF-16 \nn  byte Streams contiennent des octets \no  Character versus byte \nn  imput ou output stream pour les byte \nn  reader, writer pour les character \nn  deux hiérarchies qui se correspondent \n\nI/O package \nPOO-L3 H. Fauconnier \n339 \nHiérarchie \no \njava.io.InputStream (implements java.io.Closeable)  \nn \njava.io.ByteArrayInputStream  \nn \njava.io.FileInputStream  \nn \njava.io.FilterInputStream  \no \njava.io.BufferedInputStream  \no \njava.io.DataInputStream (implements java.io.DataInput)  \no \njava.io.LineNumberInputStream  \no \njava.io.PushbackInputStream \nn \njava.io.ObjectInputStream (implements \njava.io.ObjectInput, java.io.ObjectStreamConstants)  \nn \njava.io.PipedInputStream  \nn \njava.io.SequenceInputStream  \nn \njava.io.StringBufferInputStream \n\nI/O package \nPOO-L3 H. Fauconnier \n340 \nHiérarchie \no \njava.io.OutputStream (implements java.io.Closeable, \njava.io.Flushable)  \nn \njava.io.ByteArrayOutputStream  \nn \njava.io.FileOutputStream  \nn \njava.io.FilterOutputStream  \no \njava.io.BufferedOutputStream  \no \njava.io.DataOutputStream (implements java.io.DataOutput)  \no \njava.io.PrintStream (implements java.lang.Appendable, \njava.io.Closeable)  \nn \njava.io.ObjectOutputStream (implements \njava.io.ObjectOutput, java.io.ObjectStreamConstants)  \nn \njava.io.PipedOutputStream \n\nI/O package \nPOO-L3 H. Fauconnier \n341 \nHiérachie… \no  java.io.Reader (implements java.io.Closeable, \njava.lang.Readable)  \nn  java.io.BufferedReader  \no \njava.io.LineNumberReader \nn  java.io.CharArrayReader  \nn  java.io.FilterReader  \no \njava.io.PushbackReader \nn  java.io.InputStreamReader  \no \njava.io.FileReader \nn  java.io.PipedReader  \nn  java.io.StringReader \n\nI/O package \nPOO-L3 H. Fauconnier \n342 \nHiérarchie \nn  java.io.Writer (implements java.lang.Appendable, \njava.io.Closeable, java.io.Flushable)  \no \njava.io.BufferedWriter  \no \njava.io.CharArrayWriter  \no \njava.io.FilterWriter  \no \njava.io.OutputStreamWriter  \nn \njava.io.FileWriter \no \njava.io.PipedWriter  \no \njava.io.PrintWriter  \no \njava.io.StringWriter \n\nI/O package \nPOO-L3 H. Fauconnier \n343 \nStreams d'octets \no  Class InputStream \n(toutes ces méthodes peuvent lancer IOEXception) \nn  abstract  int read() lit un octet \nn  int read (byte[] b) lit et écrit dans b, (le nombre \nd'octets lus dépend de b et est retourné  \nn   int read(byte[] b, int off, int len) \nn   long skip(long n)  \nn  int available() n d'octets pouvant être lus \nn   void mark(int readlimit) et  void reset() pose \nd'une marque et retour à la marque \nn  voidclose()  \n\nI/O package \nPOO-L3 H. Fauconnier \n344 \nStream d'octets \no  OutputStream \n(toutes ces méthodes peuvent lancer \nIOEXception) \nn  abstract  void write(int b) écrit un octet \nn   void write(byte[] b)  \nn   void write(byte[] b, int off, int len)  \nn  voidclose()  \nn  voidflush()  \n\nI/O package \nPOO-L3 H. Fauconnier \n345 \nExemples \n   public static int compteIS(String st)  \n \n throws IOException{ \n        InputStream in; \n        int n=0; \n        if (st==null)in=System.in; \n        else \n            in= new FileInputStream(st); \n        for(; in.read() != -1;n++); \n        return n; \n    } \n\nI/O package \nPOO-L3 H. Fauconnier \n346 \nExemples \n    public static void trOS(String f, char from, char to){ \n        int b; \n        OutputStream out=null; \n        try{ \n          if(f==null) out=System.out; \n           else \n            out=new FileOutputStream(f); \n            while((b= System.in.read())!=-1) \n                out.write(b==from? to:b); \n            out.flush(); \n            out.close(); \n        }catch(IOException ex){ \n                ex.printStackTrace(); \n        } \n    } \n\nI/O package \nPOO-L3 H. Fauconnier \n347 \nReader-Writer \no  Reader et Writer sont les deux classes \nabstraites pour les streams de \ncaractères: \nn  le read de InputStream retourne un byte \ncomme octet de poids faible d'un int alors \nque le read de Reader retourne un char à \npartir de 2 octets de poids faible d'un int \n\nI/O package \nPOO-L3 H. Fauconnier \n348 \nReader \no \nessentiellement les mêmes méthodes que pour \nInputStream:  \nn \nint read()  \nn \nint read(char[] cbuf)  \nn \nabstract  int read(char[] cbuf, int off, int len) \nn \n int read(CharBuffer target)  \nn \n boolean ready() si prêt à lire \nn \n voidreset()  \nn \n voidmark(int readAheadLimit)  \nn \nbooleanmarkSupported()  \nn \nlongskip(long n)  \n \n\nI/O package \nPOO-L3 H. Fauconnier \n349 \nWriter \no \nsimilaire à OutputStream mais avec des caractères \nau lieu d'octets. \nn \n void write(char[] cbuf)  \nn \nabstract  void write(char[] cbuf, int off, int len)  \nn \n void write(int c) \nn \n void write(int c)  \nn \n void write(String str) \nn \n void write(String str, int off, int len) \nn \n Writer append(char c)  \nn \nWriter append(CharSequence csq)  \nn \n Writer append(CharSequence csq, int start, int end)  \nn \nabstract  void close() \nn \nabstract  void flush()  \n\nI/O package \nPOO-L3 H. Fauconnier \n350 \nExemples \n    public static int compteR(String st) \n \n throws IOException{ \n      Reader in; \n      int n=0; \n      if (st==null) \n       in=new InputStreamReader(System.in); \n      else \n       in= new FileReader(st); \n      for(; in.read() != -1;n++); \n      return n; \n    } \n\nI/O package \nPOO-L3 H. Fauconnier \n351 \nExemples \n    public static void trWr(String f, char from, char to){ \n        int b; \n        Writer out=null; \n        try { \n            if(f==null)  \n                out= new OutputStreamWriter(System.out); \n            else \n                out=new FileWriter(f); \n            while((b= System.in.read())!=-1) \n                    out.write(b==from? to:b); \n            out.flush(); \n            out.close(); \n       }catch(IOException e){System.out.println(e);}       \n    } \n\nI/O package \nPOO-L3 H. Fauconnier \n352 \nRemarques \no  les streams standard System.in et \nSystem.out sont des streams d'octets \no  InputStreamReader permet de passer \nde InputStream à Reader \no  System.in et System.out sont des \nPrintStream (obsolète à remplacer par \nla version caractère PrintWriter) \n\nI/O package \nPOO-L3 H. Fauconnier \n353 \nInputStreamReader   et \nOutputStreamWriter  \no \nconversion entre caractères et octets, la conversion \nest donnée par un charset \no \nConstructeurs:  \nn \nInputStreamReader(InputStream in)  \nn \nInputStreamReader(InputStream in, Charset cs)  \nn \nInputStreamReader(InputStream in, String charsetName)   \nn \nOutputStreamWriter(OutputStream out)  \nn \nOutputStreamWriter(OutputStream out, Charset cs)  \nn \nOutputStreamWriter(OutputStream out, \nCharsetEncoder enc) \nn \nOutputStreamWriter(OutputStream out, \nString charsetName)  \n\nI/O package \nPOO-L3 H. Fauconnier \n354 \nAutres classes \no  FileInputStream  \no  FileOutputStream  \no  FileReader  \no  FileWriter  \no  Ces classes permettent d'associer une \nstream à un fichier donné par son nom \n(String) par un objet File ou un objet \nFileDescriptor (un mode append peut être \ndéfini pour les ecritures) \n\nI/O package \nPOO-L3 H. Fauconnier \n355 \nQuelques autres classes \no \nLes filtres  \nn \nFilterInputStream  \nn \nFilterOutputStream  \nn \nFilterReader  \nn \nFilterWriter  \no \nBuffered \nn \nBufferedInputStream  \nn \nBufferedOutputStream  \nn \nBufferedReader  \nn \nBufferedWriter  \no \nTubes \nn \nPipedInputStream  \nn \nPipedOutputStream \nn \n PipedReader \n  \nn \nPipedWriter  \n\nI/O package \nPOO-L3 H. Fauconnier \n356 \nExemple d'un filtre \nclass conversionMaj extends FilterReader{ \n    public conversionMaj(Reader in){ \n        super(in); \n    } \n    public int read() throws IOException{ \n        int c=super.read(); \n        return(c==-1?c:Character.toUpperCase((char)c)); \n    } \n    public int read(char[] buf, int offset, int count)throws \nIOException{ \n        int nread=super.read(buf,offset,count); \n        int last=offset+nread; \n        for(int i=offset; i<last;i++) \n            buf[i] = Character.toUpperCase(buf[i]); \n        return nread; \n    } \n} \n\nI/O package \nPOO-L3 H. Fauconnier \n357 \nExemple suite: \nStringReader source=new StringReader(\"ma chaîne\"); \nFilterReader filtre=new conversionMaj(source); \nint c; \ntry{ \n  while((c=filtre.read())!= -1) \n      System.out.print((char)c); \n  }catch(IOException e){ \n  e.printStackTrace(System.err); \n } \n\nI/O package \nPOO-L3 H. Fauconnier \n358 \nPipe (tube) \no  Un tube associe une entrée et un \nsortie: on lit à une extrémité et on \nécrit à l'autre. \n\nI/O package \nPOO-L3 H. Fauconnier \n359 \nExemple pipe \nclass PipeExemple extends Thread{ \n    private Writer out; \n    private Reader in; \n    public PipeExemple(Writer out,Reader in){ \n        this.out=out; \n        this.in=in; \n    } \n    public void run(){ \n        int c; \n        try{ \n            try{ \n                while ((c=in.read())!=-1){ \n                    out.write(Character.toUpperCase((char)c)); \n                } \n            }finally{out.close();} \n        }catch(IOException e){e.printStackTrace(System.err);} \n    } \n} \n\nI/O package \nPOO-L3 H. Fauconnier \n360 \nSuite \n           PipedWriter out1=new PipedWriter(); \n        PipedReader in1=new PipedReader(out1); \n        PipedWriter out2=new PipedWriter(); \n        PipedReader in2=new PipedReader(out2); \n        PipeExemple pipe=new PipeExemple(out1, in2); \n        pipe.start();         \n        try{ \n            for(char c='a';c<='z';c++) { \n                out2.write(c); \n                System.out.print((char)(in1.read())); \n            }             \n        }finally { \n            out2.close(); \n        } \n\nI/O package \nPOO-L3 H. Fauconnier \n361 \nByteArray, String… \no \njava.io.InputStream (implements java.io.Closeable)  \nn \njava.io.ByteArrayInputStream \nn \njava.io.StringBufferInputStream  \no \njava.io.OutputStream (implements java.io.Closeable, \njava.io.Flushable)  \nn \njava.io.ByteArrayOutputStream \no \njava.io.Reader (implements java.io.Closeable, java.lang.Readable)  \nn \njava.io.CharArrayReader \nn \njava.io.StringReader  \no \njava.io.Writer (implements java.lang.Appendable, \njava.io.Closeable, java.io.Flushable)  \nn \njava.io.CharArrayWriter  \nn \njava.io.StringWriter \n  \n  \n\nI/O package \nPOO-L3 H. Fauconnier \n362 \nPrint Streams \no  java.io.PrintStream (implements \njava.lang.Appendable, java.io.Closeable)  \no  java.io.PrintWriter  \nn  méthode println() \n\nI/O package \nPOO-L3 H. Fauconnier \n363 \nStreams pour les données \no  DataInput: interface pour lire des \nbytes d'une stream binaire et les \ntransformer en données java de type \nprimitif \no  DataOutput: interface pour convertir \ndes valeurs de type primitif en stream \nbinaire. \n\nI/O package \nPOO-L3 H. Fauconnier \n364 \nSérialisation \no  sauvegarder des objets java en flot d'octets: \nn  objet vers byte: sérialisation \nn  byte vers objet: désérialisation \no \njava.io.ObjectInputStream (implements \njava.io.ObjectInput, java.io.ObjectStreamConstants)  \no \njava.io.ObjectInputStream (implements \njava.io.ObjectInput, java.io.ObjectStreamConstants)  \n\nI/O package \nPOO-L3 H. Fauconnier \n365 \nSauver des objets \no  la serialisation-désérialisation doit \npermettre de sauvegarder et restituer \ndes objets. \no  sauver et restituer des objets n'est \npas si simple. Pourquoi? \no  interface serializable \no  (alternative XML) \n\nI/O package \nPOO-L3 H. Fauconnier \n366 \nManipuler des fichiers… \no  java.io.File (implements \njava.lang.Comparable<T>, \njava.io.Serializable)  \n\nI/O package \nPOO-L3 H. Fauconnier \n367 \nnio \no  entrée sorties de haute performance \navec contrôle sur les buffers. \n\nCollections \n\nPOO-L3 H. Fauconnier \n369 \nCollections \no  types de données \nn  interfaces \nn  implémentations \nn  algorithmes \no  Interfaces: \n\nPOO-L3 H. Fauconnier \n370 \nCollections: les interfaces \nLes collections sont des interfaces génériques \no \nCollection<E>: add, remove size toArray… \nn \nSet<E>: éléments sans duplication \no \nSortedSet<E>: ensembles ordonnés \nn \nList<E>: des listes éléments non ordonnés et avec duplication \nn \nQueue<E>:  files avec tête: peek, poll (défiler), offer (enfiler) \no \nMap<K,V>:association clés valeurs \no \nSortedMap<K,V> avec clés triées \nCertaines méthodes sont optionnelles (si elles ne sont pas implémentées \nUnsupportedOperationException). \nEn plus: \no \nIterator<E>: interface qui retourne successivement les éléments \nnext(), hasNext(), remove() \no \nListIterator<E>: itérateur pour des List, set(E) previous, add(E) \n\nPOO-L3 H. Fauconnier \n371 \nCollection \npublic interface Collection<E> extends Iterable<E> { \n    // operations de base \n    int size(); \n    boolean isEmpty(); \n    boolean contains(Object element); \n    boolean add(E element);         //optionnel \n    boolean remove(Object element); //optionnel \n    Iterator<E> iterator(); \n \n    // operations des collections \n    boolean containsAll(Collection<?> c); \n    boolean addAll(Collection<? extends E> c); //optionnel \n    boolean removeAll(Collection<?> c);        //optionnel \n    boolean retainAll(Collection<?> c);        //optionnel \n    void clear();                              //optionnel \n \n    // Array \n    Object[] toArray(); \n    <T> T[] toArray(T[] a); \n} \n \n\nPOO-L3 H. Fauconnier \n372 \nCollection \no  Les collections sont génériques \no  Parcours: \nn  On peut parcourir les éléments par « for »: \nfor (Object o : collection) \n    System.out.println(o); \nn  Ou avec un Iterator: \nstatic void filter(Collection<?> c) { \n    for (Iterator<?> it = c.iterator(); it.hasNext();) \n         if (!cond(it.next())) \n       it.remove(); \n} \n\nPOO-L3 H. Fauconnier \n373 \nCollection \no  On peut convertir une collection en \ntableau \nn  En tableaux de Object \nn  En tableaux d’objet du type paramètre de \nla collection \no  Il existe aussi une classe Collections qui \ncontient des méthodes statiques utiles \n\nPOO-L3 H. Fauconnier \n374 \nSet \no  Interface pour contenir des objets \ndifférents \nn  Opérations ensemblistes \nn  SortedSet pour des ensembles ordonnés \no  Implémentations: \nn  HashSet par hachage (preformances) \nn  TreeSet arbre rouge-noir \nn  LinkedHashSet ordonnés par ordre \nd’insertion \n\nPOO-L3 H. Fauconnier \n375 \nSet \npublic interface Set<E> extends Collection<E> { \n    // opérations de base \n    int size(); \n    boolean isEmpty(); \n    boolean contains(Object element); \n    boolean add(E element);         //optionnel \n    boolean remove(Object element); //optionnel \n    Iterator<E> iterator(); \n \n    // autres \n    boolean containsAll(Collection<?> c); // sous-ensemble \n    boolean addAll(Collection<? extends E> c); //optionnel- union \n    boolean removeAll(Collection<?> c);        //optionnel- différence \n    boolean retainAll(Collection<?> c);        //optionnel- intersection \n    void clear();                              //optionnel \n \n    // Array \n    Object[] toArray(); \n    <T> T[] toArray(T[] a); \n} \n \n\nPOO-L3 H. Fauconnier \n376 \nExemple: \n public static void chercheDoublons(String ... st){ \n        Set<String> s = new HashSet<String>(); \n        for (String a : st) \n            if (!s.add(a)) \n                System.out.println(\"Doublon: \" + a); \n \n        System.out.println(\"il y a \"+s.size() + \" mots différents: \" + s); \n } \n public static void chercheDoublonsbis(String st[]){ \n        Set<String> s=new HashSet<String>(); \n        Set<String> sdup=new HashSet<String>(); \n        for(String a :st) \n            if (!s.add(a)) \n                sdup.add(a); \n        s.removeAll(sdup); \n        System.out.println(\"Mots uniques:    \" + s); \n        System.out.println(\"Mots dupliqués: \" + sdup); \n  } \n\nPOO-L3 H. Fauconnier \n377 \nLists \no  En plus de Collection: \nn  Accès par position de l ’élément \nn  Recherche qui retourne la position de \nl’élément \nn  Sous-liste entre deux positions \no  Implémentations: \nn  ArrayList  \nn  LinkedList  \n\nPOO-L3 H. Fauconnier \n378 \nList \npublic interface List<E> extends Collection<E> { \n    // accès par position \n    E get(int index); \n    E set(int index, E element);    //optional \n    boolean add(E element);         //optional \n    void add(int index, E element); //optional \n    E remove(int index);            //optional \n    boolean addAll(int index, \n        Collection<? extends E> c); //optional \n \n    // recherche \n    int indexOf(Object o); \n    int lastIndexOf(Object o); \n \n    // Iteration \n    ListIterator<E> listIterator(); \n    ListIterator<E> listIterator(int index); \n \n    // sous-liste \n    List<E> subList(int from, int to); \n} \n \n\nPOO-L3 H. Fauconnier \n379 \nItérateur pour listes \npublic interface ListIterator<E> extends Iterator<E> { \n    boolean hasNext(); \n    E next(); \n    boolean hasPrevious(); \n    E previous(); \n    int nextIndex(); \n    int previousIndex(); \n    void remove(); //optional \n    void set(E e); //optional \n    void add(E e); //optional \n} \n\nPOO-L3 H. Fauconnier \n380 \nExemple \n public static <E> void swap(List<E> a, int i, int j) { \n        E tmp = a.get(i); \n        a.set(i, a.get(j)); \n        a.set(j, tmp); \n } \n public static void melange(List<?> list, Random rnd) { \n        for (int i = list.size(); i > 1; i--) \n            swap(list, i - 1, rnd.nextInt(i)); \n } \n\nPOO-L3 H. Fauconnier \n381 \nSuite… \n public static <E> List<E> uneMain(List<E> deck, int n) { \n        int deckSize = deck.size(); \n        List<E> handView = deck.subList(deckSize - n, deckSize); \n        List<E> hand = new ArrayList<E>(handView); \n        handView.clear(); \n        return hand; \n } \n public static void distribuer(int nMains, int nCartes) { \n        String[] couleurs = new String[]{\"pique\",\"coeur\",\"carreau\",\"trèfle\"}; \n        String[] rank = new String[] \n        {\"as\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\", \"9\",\"10\",\"valet\",\"dame\",\"roi\"}; \n        List<String> deck = new ArrayList<String>(); \n        for (int i = 0; i < couleurs.length; i++) \n            for (int j = 0; j < rank.length; j++) \n                deck.add(rank[j] + \" de \" + couleurs[i]);      \n        melange(deck,new Random());        \n        for (int i=0; i < nMains; i++) \n            System.out.println(uneMain(deck,nCartes)); \n    } \n\nPOO-L3 H. Fauconnier \n382 \nMap \no  Map associe des clés à des valeurs \nn  Association injective: à une clé correspond \nexactement une valeur. \nn  Trois implémentations, comme pour set \no \nHashMap,  \no \nTreeMap,  \no \nLinkedHashMap  \nn  Remplace Hash \n\nPOO-L3 H. Fauconnier \n383 \nMap \npublic interface Map<K,V> { \n    // Basic operations \n    V put(K key, V value); \n    V get(Object key); \n    V remove(Object key); \n    boolean containsKey(Object key); \n    boolean containsValue(Object value); \n    int size(); \n    boolean isEmpty(); \n    // Bulk operations \n    void putAll(Map<? extends K, ? extends V> m); \n    void clear(); \n    // Collection Views \n    public Set<K> keySet(); \n    public Collection<V> values(); \n    public Set<Map.Entry<K,V>> entrySet(); \n    // Interface for entrySet elements \n    public interface Entry { \n        K getKey(); \n        V getValue(); \n        V setValue(V value); \n    } \n} \n\nPOO-L3 H. Fauconnier \n384 \nExemples \n public static void mapFreq(String ... t) { \n        Map<String, Integer> m = new HashMap<String,          \n \n \n \n \n \n \n Integer>(); \n        for (String a : t) { \n            Integer freq = m.get(a); \n            m.put(a, (freq == null) ? 1 : freq + 1); \n        } \n        System.out.println(\"Il y a: \" + m.size() +  \n            \" mots différents:\\n\"+m); \n    } \n// ordre arbitraire \n\nPOO-L3 H. Fauconnier \n385 \nExemples \n public static void mapFreq(String ... t) { \n        Map<String, Integer> m = new TreeMap<String, \n \n \n \n \n \n \n Integer>(); \n        for (String a : t) { \n            Integer freq = m.get(a); \n            m.put(a, (freq == null) ? 1 : freq + 1); \n        } \n        System.out.println(\"Il y a: \" + m.size() +  \n            \" mots différents:\\n\"+m); \n    } \n// ordre arbitraire \n\nPOO-L3 H. Fauconnier \n386 \nExemples \n public static void mapFreq(String ... t) { \n        Map<String, Integer> m = new LinkedHashMap<String, \n \n \n \n \n \n \n Integer>(); \n        for (String a : t) { \n            Integer freq = m.get(a); \n            m.put(a, (freq == null) ? 1 : freq + 1); \n        } \n        System.out.println(\"Il y a: \" + m.size() +  \n            \" mots différents:\\n\"+m); \n    } \n// ordre arbitraire \n\nPOO-L3 H. Fauconnier \n387 \nQueue \no  Pour représenter une file (en principe \nFIFO):  \nn  Insertion: offer -add \nn  Extraction: poll - remove \nn  Pour voir: peek –element \nn  (retourne une valeur - exception \no  PriorityQueue implémentation pour une \nfile à priorité \n\nPOO-L3 H. Fauconnier \n388 \nInterface Queue \npublic interface Queue<E> extends \nCollection<E> { \n    E element(); \n    boolean offer(E e); \n    E peek(); \n    E poll(); \n    E remove(); \n} \n\nPOO-L3 H. Fauconnier \n389 \nExemple \n public static void compteur(int n) \n            throws InterruptedException { \n        Queue<Integer> file = new           \n \n              LinkedList<Integer>(); \n        for (int i = n; i >= 0; i--) \n            file.add(i); \n        while (!file.isEmpty()) { \n            System.out.println(file.remove()); \n            Thread.sleep(1000); \n        } \n    } \n\nPOO-L3 H. Fauconnier \n390 \nExemple \nstatic <E> List<E> heapSort(Collection<E> c) { \n    Queue<E> queue = new PriorityQueue<E>(c); \n    List<E> result = new ArrayList<E>(); \n    while (!queue.isEmpty()) \n        result.add(queue.remove()); \n    return result; \n} \n\nPOO-L3 H. Fauconnier \n391 \nDes implémentations \no \nHashSet<E>: implémentation de Set comme table de hachage. \nRecherche/ ajout suppression en temps constant \no \nTreeSet<E>: SortedSet comme arbre binaire équilibré O(log(n)) \no \nArrayList<E>: liste implémentée par des tableaux à taille \nvariable accès en O(1) ajout et suppression en O(n-i) (i position \nconsidérée) \no \nLinkedList<E>: liste doublement chaînée implémente List et \nQueue accès en O(i) \no \nHashMap<K,V>: implémentation de Map par table de hachage \najout suppression et recherche en O(1) \no \nTreeMap<K,V>: implémentation de SortedMap à partir d'arbres \néquilibrés ajout, suppression et recherche en O(log(n)) \no \nWeakHashMap<K,V>: implémentation de Map par table de \nhachage \no \nPriorityQueue<E>: tas à priorité. \n\nI/O package \nPOO-L3 H. Fauconnier \n392 \nComparaisons \no  Interface Comparable<T>  contient la \nméthode \nn  public int compareTo(T e) \nn  \"ordre naturel\" \no  Interface Comparator<T> contient la \nméthode \nn  public int compare(T o1, T o2) \n \n\nI/O package \nPOO-L3 H. Fauconnier \n393 \nQuelques autres packages \no  System méthodes static pour le \nsystème: \nn  entrée-sorties standard \nn  manipulation des propriétés systèmes \nn  utilitaires \"Runtime\" exit(), gc() … \n\nI/O package \nPOO-L3 H. Fauconnier \n394 \nRuntime, Process \no  Runtime permet de créer des processus \npour exécuter des commande: exec \no  Process retourné par un exec méthodes \nn  destroy() \nn  exitValue() \nn  getInputStream() \nn  getOutputStream() \nn  getErrorStream() \n\nI/O package \nPOO-L3 H. Fauconnier \n395 \nExemple \no  exécuter une commande (du système \nlocal) \nn  associer l'entrée de la commande sur \nSystem.in \nn  associer la sortie sur System.out. \n\nI/O package \nPOO-L3 H. Fauconnier \n396 \nExemple \nclass plugTogether extends Thread { \n    InputStream from; \n    OutputStream to; \n    plugTogether(OutputStream to, InputStream from ) { \n        this.from = from; this.to = to; \n    } \n    public void run() { \n        byte b; \n        try { \n            while ((b= (byte) from.read()) !=  -1) to.write(b); \n        } catch (IOException e) { \n            System.out.println(e); \n        } finally { \n            try { \n                to.close(); \n                from.close(); \n            } catch (IOException e) { \n                System.out.println(e); \n            } \n        } \n    } \n} \n\nI/O package \nPOO-L3 H. Fauconnier \n397 \nExemple suite \npublic class Main { \n    public static Process userProg(String cmd) \n    throws IOException { \n      Process proc = Runtime.getRuntime().exec(cmd); \n      Thread thread1 = new plugTogether(proc.getOutputStream(), System.in); \n      Thread thread2 = new plugTogether(System.out, proc.getInputStream()); \n      Thread thread3 = new plugTogether(System.err, proc.getErrorStream()); \n      thread1.start(); thread2.start(); thread3.start();         \n      try {proc.waitFor();} catch (InterruptedException e) {} \n        return proc; \n    } \n    public static void main(String args[]) \n    throws IOException { \n       String cmd = args[0]; \n       System.out.println(\"Execution de: \"+cmd); \n       Process proc = userProg(cmd);    \n    } \n} \n\nChapitre X \nthreads \n\nthread \nPOO-L3 H. Fauconnier \n399 \nThreads \no  threads: plusieurs activités qui coexistent et \npartagent des données \nn  exemples: \no \npendant un chargement long faire autre chose \no \ncoopérer \no \nprocessus versus threads \nn  problème de l'accès aux ressources partagées \no \nverrous \no \nmoniteur \no \nsynchronisation  \n \n\nthread \nPOO-L3 H. Fauconnier \n400 \nPrincipes de base \no  extension de la classe Thread \nn  méthode run est le code qui sera exécuté. \nn  la création d'un objet dont la superclasse est \nThread crée la thread (mais ne la démarre pas) \nn  la méthode start démarre la thread (et retourne \nimmédiatement) \nn  la méthode join permet d'attendre la fin de la \nthread \nn  les exécutions des threads sont asynchrones et \nconcurrentes \n \n\nthread \nPOO-L3 H. Fauconnier \n401 \nExemple \nclass ThreadAffiche extends Thread{ \n    private String mot; \n    private int delay; \n    public ThreadAffiche(String w,int duree){ \n        mot=w; \n        delay=duree; \n    } \n    public void run(){ \n        try{ \n            for(;;){ \n                System.out.println(mot); \n                Thread.sleep(delay); \n            } \n        }catch(InterruptedException e){ \n        } \n    } \n} \n\nthread \nPOO-L3 H. Fauconnier \n402 \nSuite \n public static void main(String[] args) { \n       new ThreadAffiche(\"PING\", 10).start(); \n       new ThreadAffiche(\"PONG\", 30).start(); \n       new ThreadAffiche(\"Splash!\",60).start(); \n  } \n\nthread \nPOO-L3 H. Fauconnier \n403 \nAlternative: Runnable \no  Une autre solution: \nn  créer une classe qui implémente \nl'interface Runnable (cette interface \ncontient la méthode run) \nn  créer une Thread à partir du constructeur \nThread avec un Runnable comme \nargument. \n\nthread \nPOO-L3 H. Fauconnier \n404 \nExemple \nclass RunnableAffiche implements Runnable{ \n    private String mot; \n    private int delay; \n    public RunnableAffiche(String w,int duree){ \n        mot=w; \n        delay=duree; \n    } \n    public void run(){ \n        try{ \n            for(;;){ \n                System.out.println(mot); \n                Thread.sleep(delay); \n            } \n        }catch(InterruptedException e){ \n        } \n    } \n} \n\nthread \nPOO-L3 H. Fauconnier \n405 \nSuite \n public static void main(String[] args) { \n     Runnable ping=new RunnableAffiche(\"PING\", 10); \n     Runnable pong=new RunnableAffiche(\"PONG\", 50);       \n     new Thread(ping).start(); \n     new Thread(pong).start(); \n} \n\nthread \nPOO-L3 H. Fauconnier \n406 \nSynchronisation \no  les threads s'exécutent \nconcurremment et peuvent accéder \nconcurremment à des objets: \nn  il faut contrôler l'accès: \nn \nthread un lit une variable  (R1) puis modifie cette \nvariable (W1) \nn \nthread deux lit la même variable (R2) puis la modifie \n(W2) \nn \nR1-R2-W2-W1 \nn \nR1-W1-R2-W2 résultat différent! \n\nthread \nPOO-L3 H. Fauconnier \n407 \nExemple \n    class X{ \n        int val; \n    } \n    class Concur extends Thread{ \n        X x; \n        int i; \n        String nom; \n        public Concur(String st, X x){ \n            nom=st; \n            this.x=x; \n        }     \n        public void run(){ \n            i=x.val; \n            System.out.println(\"thread:\"+nom+\" valeur x=\"+i); \n            try{ \n            Thread.sleep(10); \n            }catch(Exception e){} \n            x.val=i+1; \n            System.out.println(\"thread:\"+nom+\" valeur x=\"+x.val); \n        } \n    } \n\nthread \nPOO-L3 H. Fauconnier \n408 \nSuite \n public static void main(String[] args) { \n        X x=new X(); \n        Thread un=new Concur(\"un\",x); \n        Thread deux=new Concur(\"deux\",x); \n        un.start(); deux.start(); \n        try{ \n            un.join(); \n            deux.join();             \n        }catch (InterruptedException e){} \n        System.out.println(\"X=\"+x.val); \n    } \ndonnera (par exemple) \no \nthread:un valeur x=0 \no \nthread:deux valeur x=0 \no \nthread:un valeur x=1 \no \nthread:deux valeur x=1 \no \nX=1 \n \n \n \n\nthread \nPOO-L3 H. Fauconnier \n409 \nDeuxième exemple \nclass Y{ \n    int val=0; \n    public int increment(){ \n        int tmp=val; \n        tmp++; \n        try{ \n            Thread.currentThread().sleep(100); \n        }catch(Exception e){} \n        val=tmp; \n        return(tmp); \n    } \n    int getVal(){return val;} \n} \nclass Concur1 extends Thread{ \n    Y y; \n    String nom; \n    public Concur1(String st, Y y){ \n        nom=st; \n        this.y=y; \n    } \n    public void run(){ \n        System.out.println(\"thread:\"+nom+\" valeur=\"+y.increment()); \n    } \n} \n\nthread \nPOO-L3 H. Fauconnier \n410 \nSuite \n  public static void main(String[] args) { \n        Y y=new Y(); \n        Thread un=new Concur1(\"un\",y); \n        Thread deux=new Concur1(\"deux\",y); \n        un.start(); deux.start(); \n        try{ \n            un.join(); \n            deux.join(); \n        }catch (InterruptedException e){} \n        System.out.println(\"Y=\"+y.getVal()); \n    } \n----------- \no \nthread:un valeur=1 \no \nthread:deux valeur=1 \no \nY=1 \n \n\nthread \nPOO-L3 H. Fauconnier \n411 \nVerrous \no  à chaque objet est associé un verrou \nn  synchronized(expr) {instructions} \no \nexpr doit s'évaluer comme une référence à un \nobjet \no \nverrou sur cet objet pour la durée de \nl'exécution de instructions \nn  déclarer les méthodes comme \nsynchronized: la thread obtient le verrou \net le relâche quand la méthode se termine \n \n\nthread \nPOO-L3 H. Fauconnier \n412 \nsynchronised(x) \nclass Concur extends Thread{ \n    X x; \n    int i; \n    String nom; \n    public Concur(String st, X x){ \n        nom=st; \n        this.x=x; \n    } \n    public void run(){ \n        synchronized(x){ \n            i=x.val; \n            System.out.println(\"thread:\"+nom+\" valeur x=\"+i); \n            try{ \n                Thread.sleep(10); \n            }catch(Exception e){} \n            x.val=i+1; \n            System.out.println(\"thread:\"+nom+\" valeur x=\"+x.val); \n        } \n    } \n} \n\nthread \nPOO-L3 H. Fauconnier \n413 \nMéthode synchronisée \nclass Y{ \n    int val=0; \n    public synchronized int increment(){ \n        int tmp=val; \n        tmp++; \n        try{ \n            Thread.currentThread().sleep(100); \n        }catch(Exception e){} \n        val=tmp; \n        return(tmp); \n    } \n    int getVal(){return val;} \n} \n------------ \no \nthread:un valeur=1 \no \nthread:deux valeur=2 \no \nY=2 \n \n\nthread \nPOO-L3 H. Fauconnier \n414 \nMais… \no  la synchronisation par des verrous peut \nentraîner un blocage: \nn  la thread un (XA) pose un verrou sur l'objet  A et \n(YB) demande un verrou sur l'objet B \nn  la thread deux (XB) pose un verrou sur l'objet B \net (YA) demande un verrou sur l'objet A \nn  si XA –XB : ni YA ni YB ne peuvent êter \nsatisfaites -> blocage \no  (pour une méthode synchronisée, le verrou \nconcerne l'objet globalement et pas \nseulement la méthode) \n\nthread \nPOO-L3 H. Fauconnier \n415 \nExemple \nclass Dead{ \n    Dead partenaire; \n    String nom; \n    public Dead(String st){ \n        nom=st; \n    } \n    public synchronized void f(){ \n        try{ \n            Thread.currentThread().sleep(100); \n        }catch(Exception e){} \n        System.out.println(Thread.currentThread().getName()+ \n                \" de \"+ nom+\".f() invoque \"+ partenaire.nom+\".g()\"); \n        partenaire.g();    } \n    public synchronized void g(){ \n        System.out.println(Thread.currentThread().getName()+ \n                \" de \"+ nom+\".g()\"); \n    } \n    public void setPartenaire(Dead d){ \n        partenaire=d; \n    } \n} \n\nthread \nPOO-L3 H. Fauconnier \n416 \nExemple (suite) \n        final Dead un=new Dead(\"un\"); \n        final Dead deux= new Dead(\"deux\"); \n        un.setPartenaire(deux); \n        deux.setPartenaire(un); \n        new Thread(new Runnable(){public void run(){un.f();} \n        },\"T1\").start(); \n        new Thread(new Runnable(){public void run(){deux.f();} \n        },\"T2\").start(); \n------------ \no \nT1 de un.f() invoque deux.g() \no \nT2 de deux.f() invoque un.g() \n \n\nthread \nPOO-L3 H. Fauconnier \n417 \nSynchronisation… \no  wait, notifyAll notify \nn  attendre une condition / notifier le \nchangement de condition: \nsynchronized void fairesurcondition(){ \nwhile(!condition){ \nwait(); \nfaire ce qu'il faut quand la condition est vraie \n} \n----------------- \nsynchronized void changercondition(){ \n … changer quelque chose concernant la condition \n notifyAll(); // ou notify() \n} \n\nthread \nPOO-L3 H. Fauconnier \n418 \nExemple (file: rappel Cellule) \npublic class Cellule<E>{ \n    private Cellule<E> suivant; \n    private E element; \n    public Cellule(E val) { \n        this.element=val; \n    } \n    public Cellule(E val, Cellule suivant){ \n        this.element=val; \n        this.suivant=suivant; \n    } \n    public E getElement(){ \n        return element; \n    } \n    public void setElement(E v){ \n        element=v; \n    } \n    public Cellule<E> getSuivant(){ \n        return suivant; \n    } \n    public void setSuivant(Cellule<E> s){ \n        this.suivant=s; \n    }  \n\nthread \nPOO-L3 H. Fauconnier \n419 \nFile synchronisées \nclass File<E>{ \n    protected Cellule<E> tete, queue; \n    private int taille=0; \n \n    public synchronized void enfiler(E item){ \n        Cellule<E> c=new Cellule<E>(item); \n        if (queue==null) \n            tete=c; \n        else{ \n            queue.setSuivant(c); \n        } \n        c.setSuivant(null); \n        queue = c; \n        notifyAll(); \n } \n\nthread \nPOO-L3 H. Fauconnier \n420 \nFile (suite) \n public synchronized E defiler() throws InterruptedException{ \n        while (tete == null) \n            wait(); \n        Cellule<E> tmp=tete; \n        tete=tete.getSuivant(); \n        if (tete == null) queue=null; \n        return tmp.getElement(); \n }",
  "file_type": "document",
  "original_path": "data/uploads\\module_courscomplet.pdf"
}